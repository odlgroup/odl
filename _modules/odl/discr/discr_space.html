

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.discr.discr_space &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.discr.discr_space</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.discr.discr_space</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Lebesgue L^p type discretizations of function spaces.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.discr.discr_utils</span> <span class="kn">import</span> <span class="n">point_collocation</span><span class="p">,</span> <span class="n">sampling_function</span>
<span class="kn">from</span> <span class="nn">odl.discr.partition</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">RectPartition</span><span class="p">,</span> <span class="n">uniform_partition</span><span class="p">,</span> <span class="n">uniform_partition_fromintv</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.set</span> <span class="kn">import</span> <span class="n">IntervalProd</span><span class="p">,</span> <span class="n">RealNumbers</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="kn">import</span> <span class="n">ProductSpace</span>
<span class="kn">from</span> <span class="nn">odl.space.base_tensors</span> <span class="kn">import</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">TensorSpace</span>
<span class="kn">from</span> <span class="nn">odl.space.entry_points</span> <span class="kn">import</span> <span class="n">tensor_space_impl</span>
<span class="kn">from</span> <span class="nn">odl.space.weighting</span> <span class="kn">import</span> <span class="n">ConstWeighting</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">apply_on_boundary</span><span class="p">,</span> <span class="n">array_str</span><span class="p">,</span> <span class="n">dtype_str</span><span class="p">,</span> <span class="n">is_floating_dtype</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span> <span class="n">normalized_nodes_on_bdry</span><span class="p">,</span> <span class="n">normalized_scalar_param_list</span><span class="p">,</span>
    <span class="n">repr_string</span><span class="p">,</span> <span class="n">safe_int_conv</span><span class="p">,</span> <span class="n">signature_string_parts</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;DiscretizedSpace&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DiscretizedSpaceElement&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniform_discr_frompartition&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniform_discr_fromintv&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniform_discr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;uniform_discr_fromdiscr&#39;</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="DiscretizedSpace"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.html#odl.discr.discr_space.DiscretizedSpace">[docs]</a><span class="k">class</span> <span class="nc">DiscretizedSpace</span><span class="p">(</span><span class="n">TensorSpace</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Discretization of a Lebesgue :math:`L^p` space.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiscretizedSpace.__init__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.html#odl.discr.discr_space.DiscretizedSpace.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partition</span><span class="p">,</span> <span class="n">tspace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        partition : `RectPartition`</span>
<span class="sd">            Partition of a rectangular spatial domain.</span>
<span class="sd">        tspace : `TensorSpace`</span>
<span class="sd">            Space of elements used for data storage. It must have the same</span>
<span class="sd">            `TensorSpace.shape` as ``partition``.</span>
<span class="sd">        axis_labels : sequence of str, optional</span>
<span class="sd">            Names of the axes to use for plotting etc.</span>
<span class="sd">            Default:</span>

<span class="sd">            - 1D: ``[&#39;$x$&#39;]``</span>
<span class="sd">            - 2D: ``[&#39;$x$&#39;, &#39;$y$&#39;]``</span>
<span class="sd">            - 3D: ``[&#39;$x$&#39;, &#39;$y$&#39;, &#39;$z$&#39;]``</span>
<span class="sd">            - nD: ``[&#39;$x_1$&#39;, &#39;$x_2$&#39;, ..., &#39;$x_n$&#39;]``</span>

<span class="sd">            Note: The ``$`` signs ensure rendering as LaTeX.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">RectPartition</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`partition` must be a `RectPartition`, got </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tspace</span><span class="p">,</span> <span class="n">TensorSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`tspace` must be a `TensorSpace`, got </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tspace</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">partition</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">tspace</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`partition.shape` must be equal to `tspace.shape`, but &#39;</span>
                <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">tspace</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__tspace</span> <span class="o">=</span> <span class="n">tspace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__partition</span> <span class="o">=</span> <span class="n">partition</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">DiscretizedSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tspace</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">tspace</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Set axis labels</span>
        <span class="n">axis_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axis_labels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="s1">&#39;$z$&#39;</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="s1">&#39;$x_</span><span class="si">{}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                                           <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">axis_labels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;got unexpected keyword arguments </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span></div>

    <span class="c1"># --- Meta-info</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`DiscretizedSpaceElement`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DiscretizedSpaceElement</span>

    <span class="c1"># --- Constructor args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`RectPartition` of the function domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__partition</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tspace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Space for the coefficients of the elements of this space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tspace</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axis_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Labels for axes when displaying space elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__axis_labels</span>

    <span class="c1"># --- Pass-through `partition` attributes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set on which functions are defined before discretization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">set</span>

    <span class="c1"># --- Pass-through `tspace` attributes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This space&#39;s weighting scheme.&quot;&quot;&quot;</span>
        <span class="c1"># TODO(kohr-h): `weighting` is optional in `tspace`, how should we</span>
        <span class="c1"># handle that?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">weighting</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if the ``tspace`` is weighted.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="p">,</span> <span class="s1">&#39;is_weighted&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the implementation back-end.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">impl</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent of this space, the ``p`` in ``L^p``.&quot;&quot;&quot;</span>
        <span class="c1"># TODO(kohr-h): `exponent` is optional in `tspace`, how should we</span>
        <span class="c1"># handle that?</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">exponent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">min_pt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector of minimal coordinates of the function domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">min_pt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">max_pt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector of maximal coordinates of the function domain.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">max_pt</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniform_byaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Boolean tuple showing uniformity of ``self.partition`` per axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">is_uniform_byaxis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if `partition` is uniform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">is_uniform</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sampling grid of the discretization mappings.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape of the underlying partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of dimensions (= number of axes).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of underlying partition cells.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Side lengths of a cell in an underlying *uniform* partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_sides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cell volume of an underlying *uniform* partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_volume</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All sampling points in the partition as a sparse meshgrid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">meshgrid</span>

<div class="viewcode-block" id="DiscretizedSpace.points"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.points.html#odl.discr.discr_space.DiscretizedSpace.points">[docs]</a>    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;All sampling points in the partition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;}</span>
<span class="sd">            Axis ordering in the resulting point array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        points : `numpy.ndarray`</span>
<span class="sd">            The shape of the array is ``size x ndim``, i.e. the points</span>
<span class="sd">            are stored as rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">order</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default storage order for new elements in this space.</span>

<span class="sd">        This is equal to the default order of `tspace`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">default_order</span>

<div class="viewcode-block" id="DiscretizedSpace.default_dtype"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.default_dtype.html#odl.discr.discr_space.DiscretizedSpace.default_dtype">[docs]</a>    <span class="k">def</span> <span class="nf">default_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default data type for new elements in this space.</span>

<span class="sd">        This is equal to the default data type of `tspace`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">(</span><span class="n">field</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace.available_dtypes"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.available_dtypes.html#odl.discr.discr_space.DiscretizedSpace.available_dtypes">[docs]</a>    <span class="k">def</span> <span class="nf">available_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Available data types for new elements in this space.</span>

<span class="sd">        This is equal to the available data types of `tspace`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">available_dtypes</span><span class="p">()</span></div>

    <span class="c1"># --- Derived properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tspace_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tensor space type of this space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tangent_bundle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The tangent bundle associated with `domain` using `partition`.</span>

<span class="sd">        The tangent bundle of a space ``X`` of functions ``R^d --&gt; F`` can be</span>
<span class="sd">        interpreted as the space of vector-valued functions ``R^d --&gt; F^d``.</span>
<span class="sd">        This space can be identified with the power space ``X^d`` as used</span>
<span class="sd">        in this implementation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_uniformly_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if the weighting is the same for all space points.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_uniformly_weighted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_uniformly_weighted</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">is_uniformly_weighted</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="p">,</span> <span class="s1">&#39;is_weighted&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__is_uniformly_weighted</span> <span class="o">=</span> <span class="n">is_uniformly_weighted</span>

        <span class="k">return</span> <span class="n">is_uniformly_weighted</span>

    <span class="c1"># --- Element creation</span>

<div class="viewcode-block" id="DiscretizedSpace.element"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.element.html#odl.discr.discr_space.DiscretizedSpace.element">[docs]</a>    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an element from ``inp`` or from scratch.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : optional</span>
<span class="sd">            Input used to initialize the new element. The following options</span>
<span class="sd">            are available:</span>

<span class="sd">            - ``None``: an empty element is created with no guarantee of</span>
<span class="sd">              its state (memory allocation only). The new element will</span>
<span class="sd">              use ``order`` as storage order if provided, otherwise</span>
<span class="sd">              `default_order`.</span>

<span class="sd">            - array-like: an element wrapping a `tensor` is created,</span>
<span class="sd">              where a copy is avoided whenever possible. This usually</span>
<span class="sd">              requires correct `shape`, `dtype` and `impl` if applicable,</span>
<span class="sd">              and if ``order`` is provided, also contiguousness in that</span>
<span class="sd">              ordering. See the ``element`` method of `tspace` for more</span>
<span class="sd">              information.</span>

<span class="sd">              If any of these conditions is not met, a copy is made.</span>

<span class="sd">            - callable: a new element is created by sampling the function</span>
<span class="sd">              using `point_collocation`.</span>

<span class="sd">        order : {None, &#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">            Storage order of the returned element. For ``&#39;C&#39;`` and ``&#39;F&#39;``,</span>
<span class="sd">            contiguous memory in the respective ordering is enforced.</span>
<span class="sd">            The default ``None`` enforces no contiguousness.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Additional arguments passed on to `point_collocation` when</span>
<span class="sd">            called on ``inp``, in the form</span>
<span class="sd">            ``point_collocation(inp, points, **kwargs)``.</span>
<span class="sd">            This can be used e.g. for functions with parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element : `DiscretizedSpaceElement`</span>
<span class="sd">            The discretized element, calculated as ``point_collocation(inp)``</span>
<span class="sd">            or ``tspace.element(inp)``, tried in this order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Elements can be created from array-like objects that represent</span>
<span class="sd">        an already discretized function:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(-1, 1, 4)</span>
<span class="sd">        &gt;&gt;&gt; space.element([1, 2, 3, 4])</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([ 1.,  2.,  3.,  4.])</span>
<span class="sd">        &gt;&gt;&gt; vector = odl.rn(4).element([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; space.element(vector)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([ 0.,  1.,  2.,  3.])</span>

<span class="sd">        On the other hand, non-discretized objects like Python functions</span>
<span class="sd">        can be discretized &quot;on the fly&quot;:</span>

<span class="sd">        &gt;&gt;&gt; space.element(lambda x: x * 2)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([-1.5, -0.5, 0.5, 1.5])</span>

<span class="sd">        This works also with parameterized functions, however only</span>
<span class="sd">        through keyword arguments (not positional arguments with</span>
<span class="sd">        defaults):</span>

<span class="sd">        &gt;&gt;&gt; def f(x, c=0.0):</span>
<span class="sd">        ...     return np.maximum(x, c)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(-1, 1, 4)</span>
<span class="sd">        &gt;&gt;&gt; space.element(f, c=0.5)</span>
<span class="sd">        uniform_discr(-1.0, 1.0, 4).element([ 0.5 ,  0.5 ,  0.5 ,  0.75])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inp</span>
        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span> <span class="ow">and</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">sampling_function</span><span class="p">(</span>
                <span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">out_dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sampled</span> <span class="o">=</span> <span class="n">point_collocation</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">sampled</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sequence-type input</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace.zero"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.zero.html#odl.discr.discr_space.DiscretizedSpace.zero">[docs]</a>    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the element of all zeros.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">zero</span><span class="p">())</span></div>

<div class="viewcode-block" id="DiscretizedSpace.one"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.one.html#odl.discr.discr_space.DiscretizedSpace.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the element of all ones.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">one</span><span class="p">())</span></div>

    <span class="c1"># --- Casting</span>

    <span class="k">def</span> <span class="nf">_astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal helper for ``astype``.&quot;&quot;&quot;</span>
        <span class="n">tspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">tspace</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">)</span>

    <span class="c1"># --- Slicing</span>

    <span class="c1"># TODO: add `byaxis`_out when discretized tensor-valued functions are</span>
    <span class="c1"># available</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">byaxis_in</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Object to index along input (domain) dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Indexing with integers or slices:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr([0, 0, 0], [1, 2, 3], (5, 10, 15))</span>
<span class="sd">        &gt;&gt;&gt; space.byaxis_in[0]</span>
<span class="sd">        uniform_discr(0.0, 1.0, 5)</span>
<span class="sd">        &gt;&gt;&gt; space.byaxis_in[1]</span>
<span class="sd">        uniform_discr(0.0, 2.0, 10)</span>
<span class="sd">        &gt;&gt;&gt; space.byaxis_in[1:]</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 2.,  3.], (10, 15))</span>

<span class="sd">        Lists can be used to stack spaces arbitrarily:</span>

<span class="sd">        &gt;&gt;&gt; space.byaxis_in[[2, 1, 2]]</span>
<span class="sd">        uniform_discr([ 0.,  0.,  0.], [ 3.,  2.,  3.], (15, 10, 15))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">DiscretizedSpaceByaxisIn</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;Helper class for indexing by domain axes.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.</span>

<span class="sd">                Parameters</span>
<span class="sd">                ----------</span>
<span class="sd">                indices : index expression</span>
<span class="sd">                    Object used to index the space domain.</span>

<span class="sd">                Returns</span>
<span class="sd">                -------</span>
<span class="sd">                space : `DiscretizedSpace`</span>
<span class="sd">                    The resulting space with indexed domain and otherwise</span>
<span class="sd">                    same properties (except possibly weighting).</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">):</span>
                    <span class="c1"># Need to manually construct `tspace` since it doesn&#39;t</span>
                    <span class="c1"># know where its weighting factor comes from</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">iter</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                        <span class="n">newshape</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

                    <span class="n">weighting</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">cell_volume</span>
                    <span class="n">tspace</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">tspace</span><span class="p">)(</span>
                        <span class="n">newshape</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="n">exponent</span><span class="o">=</span><span class="n">space</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Other weighting schemes are handled correctly by</span>
                    <span class="c1"># the tensor space</span>
                    <span class="c1"># TODO(kohr-h): `byaxis` is not guaranteed to exist in</span>
                    <span class="c1"># `tspace`, how to handle that?</span>
                    <span class="n">tspace</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">DiscretizedSpace</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">tspace</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.byaxis_in&#39;</span>

        <span class="k">return</span> <span class="n">DiscretizedSpaceByaxisIn</span><span class="p">()</span>

    <span class="c1"># --- Identity</span>

<div class="viewcode-block" id="DiscretizedSpace.__eq__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace.__eq__.html#odl.discr.discr_space.DiscretizedSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            ``True`` if ``other`` is a `DiscretizedSpace` with equal</span>
<span class="sd">            `tspace`, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Optimizations for simple cases</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">DiscretizedSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">tspace</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span>
                <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">partition</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``hash(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DiscretizedSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(),</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># --- Space functions</span>

<div class="viewcode-block" id="DiscretizedSpace._lincomb"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._lincomb.html#odl.discr.discr_space.DiscretizedSpace._lincomb">[docs]</a>    <span class="k">def</span> <span class="nf">_lincomb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw linear combination.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">_lincomb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace._multiply"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._multiply.html#odl.discr.discr_space.DiscretizedSpace._multiply">[docs]</a>    <span class="k">def</span> <span class="nf">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw pointwise multiplication of two elements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">_multiply</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace._divide"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._divide.html#odl.discr.discr_space.DiscretizedSpace._divide">[docs]</a>    <span class="k">def</span> <span class="nf">_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raw pointwise multiplication of two elements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">_divide</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

    <span class="c1"># The inherited methods by default use a weighting by a constant</span>
    <span class="c1"># (the grid cell size). In dimensions where the partitioned set contains</span>
    <span class="c1"># only a fraction of the outermost cells (e.g. if the outermost grid</span>
    <span class="c1"># points lie at the boundary), the corresponding contributions to</span>
    <span class="c1"># discretized integrals need to be scaled by that fraction.</span>
<div class="viewcode-block" id="DiscretizedSpace._inner"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._inner.html#odl.discr.discr_space.DiscretizedSpace._inner">[docs]</a>    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.inner(x, y)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="c1"># TODO: implement without copying x</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">x_arr</span> <span class="o">=</span> <span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x_arr</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace._norm"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._norm.html#odl.discr.discr_space.DiscretizedSpace._norm">[docs]</a>    <span class="k">def</span> <span class="nf">_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.norm(x)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="c1"># TODO: implement without copying x</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
            <span class="n">x_arr</span> <span class="o">=</span> <span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x_arr</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpace._dist"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpace._dist.html#odl.discr.discr_space.DiscretizedSpace._dist">[docs]</a>    <span class="k">def</span> <span class="nf">_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self.dist(x, y)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniform</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_uniformly_weighted</span><span class="p">:</span>
            <span class="n">bdry_fracs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">boundary_cell_fractions</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="n">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
            <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">apply_on_boundary</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func_list</span><span class="p">,</span> <span class="n">only_once</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arrs</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tensor</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="c1"># Clunky check if the factory repr can be used</span>
        <span class="k">if</span> <span class="n">uniform_partition_fromintv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">:</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">uniform_partition_fromintv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">set</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">:</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_uniform</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">use_uniform</span><span class="p">:</span>
            <span class="n">ctor</span> <span class="o">=</span> <span class="s1">&#39;uniform_discr&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">posmod</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_pt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
                <span class="n">posmod</span> <span class="o">=</span> <span class="p">[</span><span class="n">array_str</span><span class="p">,</span> <span class="n">array_str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>

            <span class="n">default_dtype_s</span> <span class="o">=</span> <span class="n">dtype_str</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">(</span><span class="n">RealNumbers</span><span class="p">())</span>
            <span class="p">)</span>

            <span class="n">dtype_s</span> <span class="o">=</span> <span class="n">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s1">&#39;impl&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
                <span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">dtype_s</span><span class="p">,</span> <span class="n">default_dtype_s</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Add weighting stuff if not equal to default</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_floating_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># In these cases, weighting constant 1 is the default</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">)</span>
                    <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_volume</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

            <span class="n">optmod</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">optargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">optmod</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;!s&#39;</span>

            <span class="n">inner_parts</span> <span class="o">=</span> <span class="n">signature_string_parts</span><span class="p">(</span>
                <span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="p">[</span><span class="n">posmod</span><span class="p">,</span> <span class="n">optmod</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">repr_string</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="n">inner_parts</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tspace</span><span class="p">]</span>
            <span class="n">inner_parts</span> <span class="o">=</span> <span class="n">signature_string_parts</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="p">[])</span>
            <span class="k">return</span> <span class="n">repr_string</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="n">inner_parts</span><span class="p">,</span> <span class="n">allow_mixed_seps</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="DiscretizedSpaceElement"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.html#odl.discr.discr_space.DiscretizedSpaceElement">[docs]</a><span class="k">class</span> <span class="nc">DiscretizedSpaceElement</span><span class="p">(</span><span class="n">Tensor</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Representation of a `DiscretizedSpace` element.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiscretizedSpaceElement.__init__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.html#odl.discr.discr_space.DiscretizedSpaceElement.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">tensor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiscretizedSpaceElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tensor</span> <span class="o">=</span> <span class="n">tensor</span></div>

    <span class="c1"># --- Constructor args</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Structure for data storage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tensor</span>

    <span class="c1"># --- Pass-through `space` properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Side lengths of a cell in an underlying *uniform* partition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">cell_sides</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cell_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cell volume of an underlying regular grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">cell_volume</span>

    <span class="c1"># --- Pass-through `tensor` properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Data container of ``self``, depends on ``space.impl``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Type of data storage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of data storage.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``len(self)``.</span>

<span class="sd">        Equivalent to ``self.shape[0]`` if possible. Zero-dimensional</span>
<span class="sd">        tensors have no length and produce a `TypeError`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>

<div class="viewcode-block" id="DiscretizedSpaceElement.copy"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.copy.html#odl.discr.discr_space.DiscretizedSpaceElement.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an identical (deep) copy of this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="DiscretizedSpaceElement.asarray"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.asarray.html#odl.discr.discr_space.DiscretizedSpaceElement.asarray">[docs]</a>    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the data of this array as a numpy array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            Array in which the result should be written in-place.</span>
<span class="sd">            Has to be contiguous and of the correct dtype.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscretizedSpaceElement.astype"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.astype.html#odl.discr.discr_space.DiscretizedSpaceElement.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this element with new ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype :</span>
<span class="sd">            Scalar data type of the returned space. Can be provided</span>
<span class="sd">            in any way the `numpy.dtype` constructor understands, e.g.</span>
<span class="sd">            as built-in type or as a string. Data types with non-trivial</span>
<span class="sd">            shapes are not allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newelem : `DisceteLpElement`</span>
<span class="sd">            Version of this element with given data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="DiscretizedSpaceElement.__eq__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.__eq__.html#odl.discr.discr_space.DiscretizedSpaceElement.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            ``True`` if all entries of ``other`` are equal to this</span>
<span class="sd">            element&#39;s entries, ``False`` otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">tensor</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span></div>

<div class="viewcode-block" id="DiscretizedSpaceElement.__getitem__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.__getitem__.html#odl.discr.discr_space.DiscretizedSpaceElement.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : int or `slice`</span>
<span class="sd">            The position(s) that should be accessed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : `Tensor`</span>
<span class="sd">            The value(s) at the index (indices).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self **= p``.&quot;&quot;&quot;</span>
        <span class="c1"># The concrete `tensor` can specialize `__ipow__` for non-integer</span>
        <span class="c1"># `p` so we want to use it here. Otherwise we get the default</span>
        <span class="c1"># `LinearSpaceElement.__ipow__` which only works for integer `p`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="fm">__ipow__</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Real part of this element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        real : `DiscretizedSpaceElement`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get the real part:</span>

<span class="sd">        &gt;&gt;&gt; discr = odl.uniform_discr(0, 1, 3, dtype=complex)</span>
<span class="sd">        &gt;&gt;&gt; x = discr.element([5+1j, 3, 2-2j])</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 5.,  3.,  2.])</span>

<span class="sd">        Set the real part:</span>

<span class="sd">        &gt;&gt;&gt; x = discr.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; zero = discr.real_space.zero()</span>
<span class="sd">        &gt;&gt;&gt; x.real = zero</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 0.,  0.,  0.])</span>

<span class="sd">        Other array-like types and broadcasting:</span>

<span class="sd">        &gt;&gt;&gt; x.real = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 1.,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; x.real = [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 2.,  3.,  4.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the real part of this element to ``newreal``.</span>

<span class="sd">        This method is invoked by ``x.real = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newreal : array-like or scalar</span>
<span class="sd">            Values to be assigned to the real part of this element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">newreal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Imaginary part of this element.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        imag : `DiscretizedSpaceElement`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get the imaginary part:</span>

<span class="sd">        &gt;&gt;&gt; discr = uniform_discr(0, 1, 3, dtype=complex)</span>
<span class="sd">        &gt;&gt;&gt; x = discr.element([5+1j, 3, 2-2j])</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 1.,  0., -2.])</span>

<span class="sd">        Set the imaginary part:</span>

<span class="sd">        &gt;&gt;&gt; x = discr.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; zero = discr.real_space.zero()</span>
<span class="sd">        &gt;&gt;&gt; x.imag = zero</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 0.,  0.,  0.])</span>

<span class="sd">        Other array-like types and broadcasting:</span>

<span class="sd">        &gt;&gt;&gt; x.imag = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 1.,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; x.imag = [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 2.,  3.,  4.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the imaginary part of this element to ``newimag``.</span>

<span class="sd">        This method is invoked by ``x.imag = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newimag : array-like or scalar</span>
<span class="sd">            Values to be assigned to the imaginary part of this element.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the space is real, i.e., no imagninary part can be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot set imaginary part in real spaces&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">newimag</span>

<div class="viewcode-block" id="DiscretizedSpaceElement.conj"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.conj.html#odl.discr.discr_space.DiscretizedSpaceElement.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Complex conjugate of this element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `DiscretizedSpaceElement`, optional</span>
<span class="sd">            Element to which the complex conjugate is written.</span>
<span class="sd">            Must be an element of this element&#39;s space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `DiscretizedSpaceElement`</span>
<span class="sd">            The complex conjugate element. If ``out`` is provided,</span>
<span class="sd">            the returned object is a reference to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; discr = uniform_discr(0, 1, 4, dtype=complex)</span>
<span class="sd">        &gt;&gt;&gt; x = discr.element([5+1j, 3, 2-2j, 1j])</span>
<span class="sd">        &gt;&gt;&gt; y = x.conj()</span>
<span class="sd">        &gt;&gt;&gt; print(y)</span>
<span class="sd">        [ 5.-1.j,  3.-0.j,  2.+2.j,  0.-1.j]</span>

<span class="sd">        The out parameter allows you to avoid a copy:</span>

<span class="sd">        &gt;&gt;&gt; z = discr.element()</span>
<span class="sd">        &gt;&gt;&gt; z_out = x.conj(out=z)</span>
<span class="sd">        &gt;&gt;&gt; print(z)</span>
<span class="sd">        [ 5.-1.j,  3.-0.j,  2.+2.j,  0.-1.j]</span>
<span class="sd">        &gt;&gt;&gt; z_out is z</span>
<span class="sd">        True</span>

<span class="sd">        It can also be used for in-place conjugation:</span>

<span class="sd">        &gt;&gt;&gt; x_out = x.conj(out=x)</span>
<span class="sd">        &gt;&gt;&gt; print(x)</span>
<span class="sd">        [ 5.-1.j,  3.-0.j,  2.+2.j,  0.-1.j]</span>
<span class="sd">        &gt;&gt;&gt; x_out is x</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="DiscretizedSpaceElement.__setitem__"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.__setitem__.html#odl.discr.discr_space.DiscretizedSpaceElement.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set values of this element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : int or `slice`</span>
<span class="sd">            The position(s) that should be set</span>
<span class="sd">        values : scalar or `array-like`</span>
<span class="sd">            Value(s) to be assigned.</span>
<span class="sd">            If ``indices`` is an integer, ``values`` must be a scalar</span>
<span class="sd">            value.</span>
<span class="sd">            If ``indices`` is a slice, ``values`` must be</span>
<span class="sd">            broadcastable to the size of the slice (same size,</span>
<span class="sd">            shape ``(1,)`` or scalar).</span>
<span class="sd">            For ``indices == slice(None)``, i.e. in the call</span>
<span class="sd">            ``vec[:] = values``, a multi-dimensional array of correct</span>
<span class="sd">            shape is allowed as ``values``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">tensor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">tensor</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">tensor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interface to Numpy&#39;s ufunc machinery.</span>

<span class="sd">        This method is called by Numpy version 1.13 and higher as a single</span>
<span class="sd">        point for the ufunc dispatch logic. An object implementing</span>
<span class="sd">        ``__array_ufunc__`` takes over control when a `numpy.ufunc` is</span>
<span class="sd">        called on it, allowing it to use custom implementations and</span>
<span class="sd">        output types.</span>

<span class="sd">        This includes handling of in-place arithmetic like</span>
<span class="sd">        ``npy_array += custom_obj``. In this case, the custom object&#39;s</span>
<span class="sd">        ``__array_ufunc__`` takes precedence over the baseline</span>
<span class="sd">        `numpy.ndarray` implementation. It will be called with</span>
<span class="sd">        ``npy_array`` as ``out`` argument, which ensures that the</span>
<span class="sd">        returned object is a Numpy array. For this to work properly,</span>
<span class="sd">        ``__array_ufunc__`` has to accept Numpy arrays as ``out`` arguments.</span>

<span class="sd">        See the `corresponding NEP`_ and the `interface documentation`_</span>
<span class="sd">        for further details. See also the `general documentation on</span>
<span class="sd">        Numpy ufuncs`_.</span>

<span class="sd">        .. note::</span>
<span class="sd">            When using operations that alter the shape (like ``reduce``),</span>
<span class="sd">            or the data type (can be any of the methods),</span>
<span class="sd">            the resulting array is wrapped in a space of the same</span>
<span class="sd">            type as ``self.space``, propagating all essential properties</span>
<span class="sd">            like weighting, exponent etc. as closely as possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ufunc : `numpy.ufunc`</span>
<span class="sd">            Ufunc that should be called on ``self``.</span>
<span class="sd">        method : str</span>
<span class="sd">            Method on ``ufunc`` that should be called on ``self``.</span>
<span class="sd">            Possible values:</span>

<span class="sd">            ``&#39;__call__&#39;``, ``&#39;accumulate&#39;``, ``&#39;at&#39;``, ``&#39;outer&#39;``,</span>
<span class="sd">            ``&#39;reduce&#39;``</span>

<span class="sd">        input1, ..., inputN :</span>
<span class="sd">            Positional arguments to ``ufunc.method``.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Keyword arguments to ``ufunc.method``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ufunc_result : `DiscretizedSpaceElement`, `numpy.ndarray` or tuple</span>
<span class="sd">            Result of the ufunc evaluation. If no ``out`` keyword argument</span>
<span class="sd">            was given, the result is a `DiscretizedSpaceElement` or a tuple</span>
<span class="sd">            of such, depending on the number of outputs of ``ufunc``.</span>
<span class="sd">            If ``out`` was provided, the returned object or sequence members</span>
<span class="sd">            refer(s) to ``out``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We apply `numpy.add` to elements of a one-dimensional space:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(0, 1, 3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([-1, -2, -3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y)</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; np.add(x, y)  # same mechanism for Numpy &gt;= 1.13</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 0.,  0.,  0.])</span>

<span class="sd">        As ``out``, a `DiscretizedSpaceElement` can be provided as well as a</span>
<span class="sd">        `Tensor` of appropriate type, or its underlying data container</span>
<span class="sd">        type (wrapped in a sequence):</span>

<span class="sd">        &gt;&gt;&gt; out = space.element()</span>
<span class="sd">        &gt;&gt;&gt; res = x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y, out=(out,))</span>
<span class="sd">        &gt;&gt;&gt; out</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; res is out</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; out_tens = odl.rn(3).element()</span>
<span class="sd">        &gt;&gt;&gt; res = x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y, out=(out_tens,))</span>
<span class="sd">        &gt;&gt;&gt; out_tens</span>
<span class="sd">        rn(3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; res is out_tens</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; out_arr = np.empty(3)</span>
<span class="sd">        &gt;&gt;&gt; res = x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y, out=(out_arr,))</span>
<span class="sd">        &gt;&gt;&gt; out_arr</span>
<span class="sd">        array([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; res is out_arr</span>
<span class="sd">        True</span>

<span class="sd">        With multiple dimensions:</span>

<span class="sd">        &gt;&gt;&gt; space_2d = odl.uniform_discr([0, 0], [1, 2], (2, 3))</span>
<span class="sd">        &gt;&gt;&gt; x = y = space_2d.one()</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y)</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 1.,  2.], (2, 3)).element(</span>
<span class="sd">            [[ 2.,  2.,  2.],</span>
<span class="sd">             [ 2.,  2.,  2.]]</span>
<span class="sd">        )</span>

<span class="sd">        The ``ufunc.accumulate`` method retains the original space:</span>

<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;accumulate&#39;, x)</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 1.,  3.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; np.add.accumulate(x)  # same mechanism for Numpy &gt;= 1.13</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([ 1.,  3.,  6.])</span>

<span class="sd">        For multi-dimensional space elements, an optional ``axis`` parameter</span>
<span class="sd">        can be provided (default is 0):</span>

<span class="sd">        &gt;&gt;&gt; z = space_2d.one()</span>
<span class="sd">        &gt;&gt;&gt; z.__array_ufunc__(np.add, &#39;accumulate&#39;, z, axis=1)</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 1.,  2.], (2, 3)).element(</span>
<span class="sd">            [[ 1.,  2.,  3.],</span>
<span class="sd">             [ 1.,  2.,  3.]]</span>
<span class="sd">        )</span>

<span class="sd">        The method also takes a ``dtype`` parameter:</span>

<span class="sd">        &gt;&gt;&gt; z.__array_ufunc__(np.add, &#39;accumulate&#39;, z, dtype=complex)</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 1.,  2.], (2, 3), dtype=complex).element(</span>
<span class="sd">            [[ 1.+0.j,  1.+0.j,  1.+0.j],</span>
<span class="sd">             [ 2.+0.j,  2.+0.j,  2.+0.j]]</span>
<span class="sd">        )</span>

<span class="sd">        The ``ufunc.at`` method operates in-place. Here we add the second</span>
<span class="sd">        operand ``[5, 10]`` to ``x`` at indices ``[0, 2]``:</span>

<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;at&#39;, x, [0, 2], [5, 10])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        uniform_discr(0.0, 1.0, 3).element([  6.,   2.,  13.])</span>

<span class="sd">        For outer-product-type operations, i.e., operations where the result</span>
<span class="sd">        shape is the sum of the individual shapes, the ``ufunc.outer``</span>
<span class="sd">        method can be used:</span>

<span class="sd">        &gt;&gt;&gt; space1 = odl.uniform_discr(0, 1, 2)</span>
<span class="sd">        &gt;&gt;&gt; space2 = odl.uniform_discr(0, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; x = space1.element([0, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space2.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;outer&#39;, x, y)</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 1.,  2.], (2, 3)).element(</span>
<span class="sd">            [[ 1.,  2.,  3.],</span>
<span class="sd">             [ 4.,  5.,  6.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; y.__array_ufunc__(np.add, &#39;outer&#39;, y, x)</span>
<span class="sd">        uniform_discr([ 0.,  0.], [ 2.,  1.], (3, 2)).element(</span>
<span class="sd">            [[ 1.,  4.],</span>
<span class="sd">             [ 2.,  5.],</span>
<span class="sd">             [ 3.,  6.]]</span>
<span class="sd">        )</span>

<span class="sd">        Using ``ufunc.reduce`` in 1D produces a scalar:</span>

<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;reduce&#39;, x)</span>
<span class="sd">        6.0</span>

<span class="sd">        In multiple dimensions, ``axis`` can be provided for reduction over</span>
<span class="sd">        selected axes:</span>

<span class="sd">        &gt;&gt;&gt; z = space_2d.element([[1, 2, 3],</span>
<span class="sd">        ...                       [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; z.__array_ufunc__(np.add, &#39;reduce&#39;, z, axis=1)</span>
<span class="sd">        uniform_discr(0.0, 1.0, 2).element([  6.,  15.])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. _corresponding NEP:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/neps/ufunc-overrides.html</span>

<span class="sd">        .. _interface documentation:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/arrays.classes.html\</span>
<span class="sd">#numpy.class.__array_ufunc__</span>

<span class="sd">        .. _general documentation on Numpy ufuncs:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/ufuncs.html</span>

<span class="sd">        .. _reduceat documentation:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/generated/\</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Process `out` --- #</span>

        <span class="c1"># Unwrap out if provided. The output parameters are all wrapped</span>
        <span class="c1"># in one tuple, even if there is only one.</span>
        <span class="n">out_tuple</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="p">())</span>

        <span class="c1"># Check number of `out` args, depending on `method`</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;need 0 or </span><span class="si">{}</span><span class="s2"> `out` arguments for `method=&#39;__call__&#39;`, &quot;</span>
                <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;__call__&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;need 0 or 1 `out` arguments for `method=</span><span class="si">{!r}</span><span class="s2">`, &quot;</span>
                <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)))</span>

        <span class="c1"># We allow our own element type, tensors and their data containers</span>
        <span class="c1"># as `out`</span>
        <span class="n">valid_out_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                           <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="p">),</span>
                           <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">valid_out_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span>
                   <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Assign to `out` or `out1` and `out2`, respectively (using the</span>
        <span class="c1"># `tensor` attribute if available)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out1</span> <span class="o">=</span> <span class="n">out2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out2</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># --- Process `inputs` --- #</span>

        <span class="c1"># Pull out the `tensor` attributes from `DiscretizedSpaceElement`</span>
        <span class="c1"># instances</span>
        <span class="c1"># since we want to pass them to `self.tensor.__array_ufunc__`</span>
        <span class="n">input_tensors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">elem</span><span class="o">.</span><span class="n">tensor</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">else</span> <span class="n">elem</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># --- Get some parameters for later --- #</span>

        <span class="c1"># Need to filter for `keepdims` in case `method=&#39;reduce&#39;` since it&#39;s</span>
        <span class="c1"># invalid (happening below)</span>
        <span class="n">keepdims</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;keepdims&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Determine list of remaining axes from `axis` for `&#39;reduce&#39;`</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reduced_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">),)</span>

            <span class="n">reduced_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>

        <span class="c1"># --- Evaluate ufunc --- #</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">,)</span>
                <span class="n">res_tens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span>
                    <span class="n">ufunc</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">input_tensors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Wrap result tensor in appropriate DiscretizedSpace space.</span>
                    <span class="n">res_space</span> <span class="o">=</span> <span class="n">DiscretizedSpace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span>
                        <span class="n">res_tens</span><span class="o">.</span><span class="n">space</span><span class="p">,</span>
                        <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span>
                    <span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res_tens</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">result</span>

            <span class="k">elif</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">)</span>
                <span class="n">res1_tens</span><span class="p">,</span> <span class="n">res2_tens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span>
                    <span class="n">ufunc</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">input_tensors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">out1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Wrap as for nout = 1</span>
                    <span class="n">res_space</span> <span class="o">=</span> <span class="n">DiscretizedSpace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span>
                        <span class="n">res1_tens</span><span class="o">.</span><span class="n">space</span><span class="p">,</span>
                        <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span>
                    <span class="p">)</span>
                    <span class="n">result1</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res1_tens</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result1</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">out2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Wrap as for nout = 1</span>
                    <span class="n">res_space</span> <span class="o">=</span> <span class="n">DiscretizedSpace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span>
                        <span class="n">res2_tens</span><span class="o">.</span><span class="n">space</span><span class="p">,</span>
                        <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span>
                    <span class="p">)</span>
                    <span class="n">result2</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res2_tens</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result2</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;nout = </span><span class="si">{}</span><span class="s1"> not supported&#39;</span>
                                          <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reduce&#39;</span> <span class="ow">and</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`keepdims=True` cannot be used in `reduce` since there is &#39;</span>
                <span class="s1">&#39;no unique way to determine a function domain in collapsed &#39;</span>
                <span class="s1">&#39;axes&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reduceat&#39;</span><span class="p">:</span>
            <span class="c1"># Makes no sense since there is no way to determine in which</span>
            <span class="c1"># space the result should live, except in special cases when</span>
            <span class="c1"># axes are being completely collapsed or don&#39;t change size.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`reduceat` not supported&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;inputs must be of type </span><span class="si">{}</span><span class="s2"> for `method=&#39;outer&#39;`, &quot;</span>
                <span class="s1">&#39;got types </span><span class="si">{}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># method != &#39;__call__&#39;, and otherwise valid</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;at&#39;</span><span class="p">:</span>
                <span class="c1"># No kwargs allowed for &#39;at&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="p">,)</span>

            <span class="n">res_tens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensor</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span>
                <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">input_tensors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Shortcut for scalar or no return value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">res_tens</span><span class="p">)</span> <span class="ow">or</span> <span class="n">res_tens</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># The first occurs for `reduce` with all axes,</span>
                <span class="c1"># the second for in-place stuff (`at` currently)</span>
                <span class="k">return</span> <span class="n">res_tens</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Wrap in appropriate DiscretizedSpace space depending</span>
                <span class="c1"># on `method`</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;accumulate&#39;</span><span class="p">:</span>
                    <span class="n">res_space</span> <span class="o">=</span> <span class="n">DiscretizedSpace</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span>
                        <span class="n">res_tens</span><span class="o">.</span><span class="n">space</span><span class="p">,</span>
                        <span class="n">axis_labels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span>
                    <span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res_tens</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
                    <span class="c1"># Concatenate partitions and axis_labels,</span>
                    <span class="c1"># and determine `tspace` from the result tensor</span>
                    <span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span> <span class="o">=</span> <span class="n">inputs</span>
                    <span class="n">part</span> <span class="o">=</span> <span class="n">inp1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp2</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">)</span>
                    <span class="n">labels1</span> <span class="o">=</span> <span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39; (1)&#39;</span> <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">inp1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">]</span>
                    <span class="n">labels2</span> <span class="o">=</span> <span class="p">[</span><span class="n">lbl</span> <span class="o">+</span> <span class="s1">&#39; (2)&#39;</span> <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">inp2</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">]</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels1</span> <span class="o">+</span> <span class="n">labels2</span>

                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">):</span>
                        <span class="c1"># For constant weighting, use the product of the</span>
                        <span class="c1"># two weighting constants. The result tensor space</span>
                        <span class="c1"># cannot know about the &quot;correct&quot; way to combine the</span>
                        <span class="c1"># two constants, so we need to do it manually here.</span>
                        <span class="n">weighting</span> <span class="o">=</span> <span class="p">(</span><span class="n">inp1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                                     <span class="n">inp2</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span><span class="p">)</span>
                        <span class="n">tspace</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">res_tens</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span>
                            <span class="n">res_tens</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">res_tens</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                            <span class="n">exponent</span><span class="o">=</span><span class="n">res_tens</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                            <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Otherwise `TensorSpace` knows how to handle this</span>
                        <span class="n">tspace</span> <span class="o">=</span> <span class="n">res_tens</span><span class="o">.</span><span class="n">space</span>

                    <span class="n">res_space</span> <span class="o">=</span> <span class="n">DiscretizedSpace</span><span class="p">(</span>
                        <span class="n">part</span><span class="p">,</span> <span class="n">tspace</span><span class="p">,</span> <span class="n">axis_labels</span><span class="o">=</span><span class="n">labels</span>
                    <span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res_tens</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;reduce&#39;</span><span class="p">:</span>
                    <span class="c1"># Index space by axis using `reduced_axes`</span>
                    <span class="n">res_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">byaxis_in</span><span class="p">[</span><span class="n">reduced_axes</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="n">res_tens</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">res_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res_tens</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad `method`&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># `out` may be `out_tuple[0].tensor`, but we want to return</span>
                <span class="c1"># the original one</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="DiscretizedSpaceElement.show"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.DiscretizedSpaceElement.show.html#odl.discr.discr_space.DiscretizedSpaceElement.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">force_show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the function graphically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Set the title of the figure</span>

<span class="sd">        method : string, optional</span>
<span class="sd">            1d methods:</span>

<span class="sd">            - ``&#39;plot&#39;`` : graph plot (default for 1d data)</span>
<span class="sd">            - ``&#39;scatter&#39;`` : scattered 2d points (2nd axis &lt;-&gt; value)</span>

<span class="sd">            2d methods:</span>

<span class="sd">            - ``&#39;imshow&#39;`` : image plot with coloring according to value,</span>
<span class="sd">              including a colorbar (default for 2d data).</span>
<span class="sd">            - ``&#39;scatter&#39;`` : cloud of scattered 3d points</span>
<span class="sd">              (3rd axis &lt;-&gt; value)</span>

<span class="sd">        coords : `array-like`, optional</span>
<span class="sd">            Display a slice of the array instead of the full array.</span>
<span class="sd">            The values are shown accordinging to the given values,</span>
<span class="sd">            where ``None`` means all values along that dimension. For</span>
<span class="sd">            example, ``[None, None, 0.5]`` shows all values in the first</span>
<span class="sd">            two dimensions, with the third coordinate equal to 0.5.</span>
<span class="sd">            If a sequence is provided, it specifies the minimum and maximum</span>
<span class="sd">            point to be shown, i.e. ``[None, [0, 1]]`` shows all of the</span>
<span class="sd">            first axis and values between 0 and 1 in the second.</span>
<span class="sd">            This option is mutually exclusive with ``indices``.</span>

<span class="sd">        indices : int, slice, Ellipsis or sequence, optional</span>
<span class="sd">            Display a slice of the array instead of the full array.</span>
<span class="sd">            If a sequence is given, the i-th entry indexes the i-th axis,</span>
<span class="sd">            with the following behavior for the different types of entries:</span>

<span class="sd">                - ``int``: take entries with this index along axis ``i``,</span>
<span class="sd">                  removing this axis from the result</span>
<span class="sd">                - ``slice``: take a subset along axis ``i``, keeping it</span>
<span class="sd">                  intact</span>
<span class="sd">                - ``None``: equivalent to ``slice(None)``</span>
<span class="sd">                - ``Ellipsis`` (``...``): equivalent to the number of</span>
<span class="sd">                  ``None`` entries required to fill up the sequence to</span>
<span class="sd">                  correct length.</span>

<span class="sd">            The typical use case is to show a slice for a fixed index in</span>
<span class="sd">            a specific axis, which can be done most easily by setting, e.g.,</span>
<span class="sd">            ``indices=[None, 50, None]`` to take the 2d slice parallel to</span>
<span class="sd">            the x-z coordinate plane at index ``y = 50``.</span>

<span class="sd">            A single ``int`` or ``slice`` object indexes the first</span>
<span class="sd">            axis, i.e., is treated as ``(int_or_slice, Ellipsis)``.</span>
<span class="sd">            For the default ``None``, the array is kepty as-is for data</span>
<span class="sd">            that has at most 2 dimensions. For higher-dimensional</span>
<span class="sd">            data, the 2d slice in the first two axes at the middle</span>
<span class="sd">            position along the remaining axes is shown</span>
<span class="sd">            (semantically ``[:, :, shape[2:] // 2]``).</span>
<span class="sd">            This option is mutually exclusive with ``coords``.</span>

<span class="sd">        force_show : bool, optional</span>
<span class="sd">            Whether the plot should be forced to be shown now or deferred until</span>
<span class="sd">            later. Note that some backends always displays the plot, regardless</span>
<span class="sd">            of this value.</span>

<span class="sd">        fig : `matplotlib.figure.Figure`, optional</span>
<span class="sd">            The figure to show in. Expected to be of same &quot;style&quot;, as</span>
<span class="sd">            the figure given by this function. The most common use case</span>
<span class="sd">            is that ``fig`` is the return value of an earlier call to</span>
<span class="sd">            this function.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        interp : {&#39;linear&#39;, &#39;nearest&#39;}, optional</span>
<span class="sd">            Interpolation type that should be used for the plot.</span>

<span class="sd">        kwargs : {&#39;figsize&#39;, &#39;saveto&#39;, &#39;clim&#39;, ...}, optional</span>
<span class="sd">            Extra keyword arguments passed on to the display method.</span>
<span class="sd">            See the Matplotlib functions for documentation of extra</span>
<span class="sd">            options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : `matplotlib.figure.Figure`</span>
<span class="sd">            The resulting figure. It is also shown to the user.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.util.graphics.show_discrete_data : Underlying implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">odl.util.graphics</span> <span class="kn">import</span> <span class="n">show_discrete_data</span>

        <span class="k">if</span> <span class="s1">&#39;interp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;interp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nothing to show for 0-dimensional vector&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot provide both coords and indices&#39;</span><span class="p">)</span>

            <span class="n">partition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">coords</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">coord_minp</span><span class="p">,</span> <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">coord</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">coord_minp</span> <span class="o">=</span> <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">coord</span>

                <span class="n">subpart</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>

                <span class="c1"># Validate input</span>
                <span class="k">if</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_minp</span> <span class="o">=</span> <span class="n">subpart</span><span class="o">.</span><span class="n">set</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coord_maxp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">coord_maxp</span> <span class="o">=</span> <span class="n">subpart</span><span class="o">.</span><span class="n">set</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">coord_maxp</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpart</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># trivial cases</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">coord_minp</span> <span class="o">==</span> <span class="n">coord_maxp</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">coord_minp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">min_ind</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">min_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_minp</span><span class="p">,</span>
                                                         <span class="n">floating</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">coord_maxp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">max_ind</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpart</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">max_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">subpart</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">coord_maxp</span><span class="p">,</span>
                                                        <span class="n">floating</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">min_ind</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_ind</span><span class="p">)))</span>

        <span class="c1"># Default to showing x-y slice &quot;in the middle&quot;</span>
        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">((</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>

        <span class="c1"># Normalize indices</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="p">(</span><span class="n">Integral</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">indices</span> <span class="o">==</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Single index or slice indexes the first axis, rest untouched</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span>

        <span class="c1"># Convert `Ellipsis` objects</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot use more than 1 `Ellipsis` (`...`)&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">Ellipsis</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="c1"># Replace Ellipsis with the correct number of `slice(None)`</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">Ellipsis</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">[:</span><span class="n">pos</span><span class="p">])</span> <span class="o">+</span>
                       <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span>
                       <span class="nb">tuple</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]))</span>

        <span class="c1"># Now indices should be exactly of length `ndim`</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too few axes (</span><span class="si">{}</span><span class="s1"> &lt; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;too many axes (</span><span class="si">{}</span><span class="s1"> &gt; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="c1"># Map `None` to `slice(None)` in indices for syntax like `coords`</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">idx</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

        <span class="n">squeezed_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
                         <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)]</span>
        <span class="n">axis_labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">axis_labels</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">squeezed_axes</span><span class="p">]</span>

        <span class="c1"># Squeeze grid and values according to the index expression</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asarray</span><span class="p">()[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">show_discrete_data</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                  <span class="n">force_show</span><span class="o">=</span><span class="n">force_show</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                  <span class="n">axis_labels</span><span class="o">=</span><span class="n">axis_labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="uniform_discr_frompartition"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.uniform_discr_frompartition.html#odl.discr.discr_space.uniform_discr_frompartition">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_frompartition</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a uniformly discretized L^p function space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    partition : `RectPartition`</span>
<span class="sd">        Uniform partition to be used for discretization.</span>
<span class="sd">        It defines the domain and the functions and the grid for</span>
<span class="sd">        discretization.</span>
<span class="sd">    dtype : optional</span>
<span class="sd">        Data type for the discretized space, must be understood by the</span>
<span class="sd">        `numpy.dtype` constructor. The default for ``None`` depends on the</span>
<span class="sd">        ``impl`` backend, usually it is ``&#39;float64&#39;`` or ``&#39;float32&#39;``.</span>
<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Additional keyword parameters, see `uniform_discr` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscretizedSpace`</span>
<span class="sd">        The uniformly discretized function space.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; part = odl.uniform_partition(0, 1, 10)</span>
<span class="sd">    &gt;&gt;&gt; uniform_discr_frompartition(part)</span>
<span class="sd">    uniform_discr(0.0, 1.0, 10)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    uniform_discr_fromspace : uniform Lp discretization from an existing</span>
<span class="sd">        function space</span>
<span class="sd">    odl.discr.partition.uniform_partition :</span>
<span class="sd">        partition of the function domain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">RectPartition</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`partition` </span><span class="si">{!r}</span><span class="s1"> is not a `RectPartition` instance&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">partition</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">partition</span><span class="o">.</span><span class="n">is_uniform</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`partition` is not uniform&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">tspace_type</span> <span class="o">=</span> <span class="n">tensor_space_impl</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tspace_type</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">()</span>

    <span class="n">weighting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">partition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">weighting</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weighting</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">cell_volume</span>

    <span class="n">tspace</span> <span class="o">=</span> <span class="n">tspace_type</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>
                         <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DiscretizedSpace</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">tspace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr_fromintv"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.uniform_discr_fromintv.html#odl.discr.discr_space.uniform_discr_fromintv">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_fromintv</span><span class="p">(</span><span class="n">intv_prod</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a uniformly discretized L^p function space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    intv_prod : `IntervalProd`</span>
<span class="sd">        Function domain of the uniformly discretized space.</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    dtype : optional</span>
<span class="sd">        Data type for the discretized space, must be understood by the</span>
<span class="sd">        `numpy.dtype` constructor. The default for ``None`` depends on the</span>
<span class="sd">        ``impl`` backend, usually it is ``&#39;float64&#39;`` or ``&#39;float32&#39;``.</span>
<span class="sd">    impl : str, optional</span>
<span class="sd">        Implementation of the data storage arrays.</span>
<span class="sd">    kwargs :</span>
<span class="sd">        Additional keyword parameters, see `uniform_discr` for details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscretizedSpace`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; intv = IntervalProd(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; uniform_discr_fromintv(intv, 10)</span>
<span class="sd">    uniform_discr(0.0, 1.0, 10)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    uniform_discr_frompartition : uniform Lp discretization using a given</span>
<span class="sd">        uniform partition of a function domain</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">tensor_space_impl</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">()</span>

    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">partition</span> <span class="o">=</span> <span class="n">uniform_partition_fromintv</span><span class="p">(</span><span class="n">intv_prod</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nodes_on_bdry</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniform_discr_frompartition</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.uniform_discr.html#odl.discr.discr_space.uniform_discr">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a uniformly discretized L^p function space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    min_pt, max_pt : float or sequence of floats</span>
<span class="sd">        Minimum/maximum corners of the desired function domain.</span>
<span class="sd">    shape : int or sequence of ints</span>
<span class="sd">        Number of samples per axis.</span>
<span class="sd">    dtype : optional</span>
<span class="sd">        Data type for the discretized space, must be understood by the</span>
<span class="sd">        `numpy.dtype` constructor. The default for ``None`` depends on the</span>
<span class="sd">        ``impl`` backend, usually it is ``&#39;float64&#39;`` or ``&#39;float32&#39;``.</span>
<span class="sd">    impl : string, optional</span>
<span class="sd">        Implementation of the data storage arrays.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    exponent : positive float, optional</span>
<span class="sd">        The parameter :math:`p` in :math:`L^p`. If the exponent is not</span>
<span class="sd">        equal to the default 2.0, the space has no inner product.</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single bool or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``len(shape)``.</span>
<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>
<span class="sd">        Default: ``False``.</span>
<span class="sd">    weighting : optional</span>
<span class="sd">        Use weighted inner product, norm, and dist. The following</span>
<span class="sd">        types are supported as ``weighting``:</span>

<span class="sd">        - ``None``: Use the cell volume as weighting constant (default).</span>
<span class="sd">        - ``float``: Weighting by a constant.</span>
<span class="sd">        - array-like: Point-wise weighting by an array.</span>
<span class="sd">        - `Weighting`: Use weighting class as-is. Compatibility</span>
<span class="sd">          with this space&#39;s elements is not checked during init.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    discr : `DiscretizedSpace`</span>
<span class="sd">        The uniformly discretized function space</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create real space:</span>

<span class="sd">    &gt;&gt;&gt; space = uniform_discr([0, 0], [1, 1], (10, 10))</span>
<span class="sd">    &gt;&gt;&gt; space</span>
<span class="sd">    uniform_discr([ 0.,  0.], [ 1.,  1.], (10, 10))</span>
<span class="sd">    &gt;&gt;&gt; space.cell_sides</span>
<span class="sd">    array([ 0.1,  0.1])</span>
<span class="sd">    &gt;&gt;&gt; space.dtype</span>
<span class="sd">    dtype(&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; space.is_real</span>
<span class="sd">    True</span>

<span class="sd">    Create complex space by giving a dtype:</span>

<span class="sd">    &gt;&gt;&gt; space = uniform_discr([0, 0], [1, 1], (10, 10), dtype=complex)</span>
<span class="sd">    &gt;&gt;&gt; space</span>
<span class="sd">    uniform_discr([ 0.,  0.], [ 1.,  1.], (10, 10), dtype=complex)</span>
<span class="sd">    &gt;&gt;&gt; space.is_complex</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; space.real_space  # Get real counterpart</span>
<span class="sd">    uniform_discr([ 0.,  0.], [ 1.,  1.], (10, 10))</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr_frompartition : uniform Lp discretization using a given</span>
<span class="sd">        uniform partition of a function domain</span>
<span class="sd">    uniform_discr_fromspace : uniform discretization from an existing</span>
<span class="sd">        function space</span>
<span class="sd">    uniform_discr_fromintv : uniform discretization from an existing</span>
<span class="sd">        interval product</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intv_prod</span> <span class="o">=</span> <span class="n">IntervalProd</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uniform_discr_fromintv</span><span class="p">(</span><span class="n">intv_prod</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_discr_fromdiscr"><a class="viewcode-back" href="../../../generated/odl.discr.discr_space.uniform_discr_fromdiscr.html#odl.discr.discr_space.uniform_discr_fromdiscr">[docs]</a><span class="k">def</span> <span class="nf">uniform_discr_fromdiscr</span><span class="p">(</span><span class="n">discr</span><span class="p">,</span> <span class="n">min_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell_sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a discretization based on an existing one.</span>

<span class="sd">    The parameters that are explicitly given are used to create the</span>
<span class="sd">    new discretization, and the missing information is taken from</span>
<span class="sd">    the template space. See Notes for the exact functionality.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    discr : `DiscretizedSpace`</span>
<span class="sd">        Uniformly discretized space used as a template.</span>
<span class="sd">    min_pt, max_pt: float or sequence of floats, optional</span>
<span class="sd">        Desired minimum/maximum corners of the new space domain.</span>
<span class="sd">    shape : int or sequence of ints, optional</span>
<span class="sd">        Desired number of samples per axis of the new space.</span>
<span class="sd">    cell_sides : float or sequence of floats, optional</span>
<span class="sd">        Desired cell side lenghts of the new space&#39;s partition.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    nodes_on_bdry : bool or sequence, optional</span>
<span class="sd">        If a sequence is provided, it determines per axis whether to</span>
<span class="sd">        place the last grid point on the boundary (``True``) or shift it</span>
<span class="sd">        by half a cell size into the interior (``False``). In each axis,</span>
<span class="sd">        an entry may consist in a single bool or a 2-tuple of</span>
<span class="sd">        bool. In the latter case, the first tuple entry decides for</span>
<span class="sd">        the left, the second for the right boundary. The length of the</span>
<span class="sd">        sequence must be ``discr.ndim``.</span>

<span class="sd">        A single boolean is interpreted as a global choice for all</span>
<span class="sd">        boundaries.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    kwargs :</span>
<span class="sd">        Additional keyword parameters passed to the `DiscretizedSpace`</span>
<span class="sd">        initializer.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters ``min_pt``, ``max_pt``, ``shape`` and</span>
<span class="sd">    ``cell_sides`` can be combined in the following ways (applies in</span>
<span class="sd">    each axis individually):</span>

<span class="sd">    **0 arguments:**</span>
<span class="sd">        Return a copy of ``discr``</span>

<span class="sd">    **1 argument:**</span>
<span class="sd">        [min,max]_pt -&gt; keep sampling but translate domain so it</span>
<span class="sd">        starts/ends at ``[min,max]_pt``</span>

<span class="sd">        shape/cell_sides -&gt; keep domain but change sampling.</span>
<span class="sd">        See `uniform_partition` for restrictions.</span>

<span class="sd">    **2 arguments:**</span>
<span class="sd">        min_pt + max_pt -&gt; translate and resample with the same</span>
<span class="sd">        number of samples</span>

<span class="sd">        [min,max]_pt + shape/cell_sides -&gt; translate and resample</span>

<span class="sd">        shape + cell_sides -&gt; error due to ambiguity (keep</span>
<span class="sd">        ``min_pt`` or ``max_pt``?)</span>

<span class="sd">    **3+ arguments:**</span>
<span class="sd">        The underlying partition is uniquely determined by the new</span>
<span class="sd">        parameters. See `uniform_partition`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    uniform_discr : implicit uniform Lp discretization</span>
<span class="sd">    odl.discr.partition.uniform_partition :</span>
<span class="sd">        underlying domain partitioning scheme</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; discr = odl.uniform_discr([0, 0], [1, 2], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; discr.cell_sides</span>
<span class="sd">    array([ 0.1,  0.4])</span>

<span class="sd">    If no additional argument is given, a copy of ``discr`` is</span>
<span class="sd">    returned:</span>

<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr) == discr</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr) is discr</span>
<span class="sd">    False</span>

<span class="sd">    Giving ``min_pt`` or ``max_pt`` results in a</span>
<span class="sd">    translation, while for the other two options, the domain</span>
<span class="sd">    is kept but re-partitioned:</span>

<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, min_pt=[1, 1])</span>
<span class="sd">    uniform_discr([ 1.,  1.], [ 2.,  3.], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, max_pt=[0, 0])</span>
<span class="sd">    uniform_discr([-1., -2.], [ 0.,  0.], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, cell_sides=[1, 1])</span>
<span class="sd">    uniform_discr([ 0.,  0.], [ 1.,  2.], (1, 2))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, shape=[5, 5])</span>
<span class="sd">    uniform_discr([ 0.,  0.], [ 1.,  2.], (5, 5))</span>
<span class="sd">    &gt;&gt;&gt; odl.uniform_discr_fromdiscr(discr, shape=[5, 5]).cell_sides</span>
<span class="sd">    array([ 0.2,  0.4])</span>

<span class="sd">    The cases with 2 or more additional arguments and the syntax</span>
<span class="sd">    for specifying quantities per axis is illustrated in the following:</span>

<span class="sd">    # axis 0: translate to match max_pt = 3</span>
<span class="sd">    # axis 1: recompute max_pt using the original shape with the</span>
<span class="sd">    # new min_pt and cell_sides</span>
<span class="sd">    &gt;&gt;&gt; new_discr = odl.uniform_discr_fromdiscr(discr, min_pt=[None, 1],</span>
<span class="sd">    ...                                         max_pt=[3, None],</span>
<span class="sd">    ...                                         cell_sides=[None, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; new_discr</span>
<span class="sd">    uniform_discr([ 2.,  1.], [ 3.  ,  2.25], (10, 5))</span>
<span class="sd">    &gt;&gt;&gt; new_discr.cell_sides</span>
<span class="sd">    array([ 0.1 ,  0.25])</span>

<span class="sd">    # axis 0: recompute min_pt from old cell_sides and new</span>
<span class="sd">    # max_pt and shape</span>
<span class="sd">    # axis 1: use new min_pt, shape and cell_sides only</span>
<span class="sd">    &gt;&gt;&gt; new_discr = odl.uniform_discr_fromdiscr(discr, min_pt=[None, 1],</span>
<span class="sd">    ...                                         max_pt=[3, None],</span>
<span class="sd">    ...                                         shape=[5, 5],</span>
<span class="sd">    ...                                         cell_sides=[None, 0.25])</span>
<span class="sd">    &gt;&gt;&gt; new_discr</span>
<span class="sd">    uniform_discr([ 2.5,  1. ], [ 3.  ,  2.25], (5, 5))</span>
<span class="sd">    &gt;&gt;&gt; new_discr.cell_sides</span>
<span class="sd">    array([ 0.1 ,  0.25])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">discr</span><span class="p">,</span> <span class="n">DiscretizedSpace</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`discr` </span><span class="si">{!r}</span><span class="s1"> is not a DiscretizedSpace instance&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">discr</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">discr</span><span class="o">.</span><span class="n">is_uniform</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`discr` </span><span class="si">{}</span><span class="s1"> is not uniformly discretized&#39;</span>
                         <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">discr</span><span class="p">))</span>

    <span class="c1"># Normalize partition parameters</span>
    <span class="n">min_pt</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                          <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_pt</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">max_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                          <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                         <span class="n">param_conv</span><span class="o">=</span><span class="n">safe_int_conv</span><span class="p">,</span>
                                         <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cell_sides</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">cell_sides</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                                              <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">keep_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nodes_on_bdry&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">nodes_on_bdry</span> <span class="o">=</span> <span class="n">normalized_nodes_on_bdry</span><span class="p">(</span><span class="n">nodes_on_bdry</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">new_min_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_max_pt</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_shape</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_csides</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">cell_sides</span><span class="p">,</span>
                <span class="n">discr</span><span class="o">.</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">max_pt</span><span class="p">,</span> <span class="n">discr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">discr</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">)):</span>
        <span class="n">num_params</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">old_xmax</span> <span class="o">+</span> <span class="p">(</span><span class="n">xmin</span> <span class="o">-</span> <span class="n">old_xmin</span><span class="p">),</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span> <span class="o">+</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">old_xmax</span><span class="p">),</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_xmin</span><span class="p">,</span> <span class="n">old_xmax</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">num_params</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">old_s</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">xmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">old_n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;in axis </span><span class="si">{}</span><span class="s1">: cannot use `shape` and &#39;</span>
                                 <span class="s1">&#39;`cell_size` only due to ambiguous values &#39;</span>
                                 <span class="s1">&#39;for `min_pt` and `max_pt`.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="n">new_min_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">new_max_pt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">new_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">new_csides</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_params</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">new_part</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="n">min_pt</span><span class="o">=</span><span class="n">new_min_pt</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">=</span><span class="n">new_max_pt</span><span class="p">,</span>
                                 <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">,</span>
                                 <span class="n">cell_sides</span><span class="o">=</span><span class="n">new_csides</span><span class="p">,</span>
                                 <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="n">nodes_on_bdry</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">uniform_discr_frompartition</span><span class="p">(</span>
        <span class="n">new_part</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">discr</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">discr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_scaling_func_list</span><span class="p">(</span><span class="n">bdry_fracs</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of lists of scaling functions for the boundary.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">scaling</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">scaling_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="k">return</span> <span class="n">scaling_func</span>

    <span class="n">func_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">frac_l</span><span class="p">,</span> <span class="n">frac_r</span> <span class="ow">in</span> <span class="n">bdry_fracs</span><span class="p">:</span>
        <span class="n">func_list_entry</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">frac_l</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaling</span><span class="p">(</span><span class="n">frac_l</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">exponent</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">frac_r</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">):</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_list_entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scaling</span><span class="p">(</span><span class="n">frac_r</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">exponent</span><span class="p">)))</span>

        <span class="n">func_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func_list_entry</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func_list</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>