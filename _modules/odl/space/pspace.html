

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.space.pspace &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.space.pspace</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.space.pspace</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Cartesian products of `LinearSpace` instances.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.set</span> <span class="kn">import</span> <span class="n">LinearSpace</span>
<span class="kn">from</span> <span class="nn">odl.set.space</span> <span class="kn">import</span> <span class="n">LinearSpaceElement</span>
<span class="kn">from</span> <span class="nn">odl.space.weighting</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayWeighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">,</span> <span class="n">CustomDist</span><span class="p">,</span> <span class="n">CustomInner</span><span class="p">,</span> <span class="n">CustomNorm</span><span class="p">,</span>
    <span class="n">Weighting</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">indent</span><span class="p">,</span> <span class="n">is_real_dtype</span><span class="p">,</span> <span class="n">signature_string</span>
<span class="kn">from</span> <span class="nn">odl.util.ufuncs</span> <span class="kn">import</span> <span class="n">ProductSpaceUfuncs</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ProductSpace&#39;</span><span class="p">,)</span>


<div class="viewcode-block" id="ProductSpace"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.html#odl.space.pspace.ProductSpace">[docs]</a><span class="k">class</span> <span class="nc">ProductSpace</span><span class="p">(</span><span class="n">LinearSpace</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Cartesian product of `LinearSpace`&#39;s.</span>

<span class="sd">    A product space is the Cartesian product ``X_1 x ... x X_n`` of</span>
<span class="sd">    linear spaces ``X_i``. It is itself a linear space, where the linear</span>
<span class="sd">    combination is defined component-wise. Inner product, norm and</span>
<span class="sd">    distance can also be defined in natural ways from the corresponding</span>
<span class="sd">    functions in the individual components.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpace.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.html#odl.space.pspace.ProductSpace.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">spaces</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space1,...,spaceN : `LinearSpace` or int</span>
<span class="sd">            The individual spaces (&quot;factors / parts&quot;) in the product</span>
<span class="sd">            space. Can also be given as ``space, n`` with ``n`` integer,</span>
<span class="sd">            in which case the power space ``space ** n`` is created.</span>
<span class="sd">        exponent : non-zero float or ``float(&#39;inf&#39;)``, optional</span>
<span class="sd">            Order of the product distance/norm, i.e.</span>

<span class="sd">            ``dist(x, y) = np.linalg.norm(x-y, ord=exponent)``</span>

<span class="sd">            ``norm(x) = np.linalg.norm(x, ord=exponent)``</span>

<span class="sd">            Values ``0 &lt;= exponent &lt; 1`` are currently unsupported</span>
<span class="sd">            due to numerical instability. See ``Notes`` for further</span>
<span class="sd">            information about the interpretation of the values.</span>

<span class="sd">            Default: 2.0</span>

<span class="sd">        field : `Field`, optional</span>
<span class="sd">            Scalar field of the resulting space.</span>
<span class="sd">            Default: ``spaces[0].field``</span>

<span class="sd">        weighting : optional</span>
<span class="sd">            Use weighted inner product, norm, and dist. The following</span>
<span class="sd">            types are supported as ``weighting``:</span>

<span class="sd">            ``None`` : no weighting (default)</span>

<span class="sd">            `Weighting` : weighting class, used directly. Such a</span>
<span class="sd">            class instance can be retrieved from the space by the</span>
<span class="sd">            `ProductSpace.weighting` property.</span>

<span class="sd">            `array-like` : weigh each component with one entry from the</span>
<span class="sd">            array. The array must be one-dimensional and have the same</span>
<span class="sd">            length as the number of spaces.</span>

<span class="sd">            float : same weighting factor in each component</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        dist : callable, optional</span>
<span class="sd">            The distance function defining a metric on the space.</span>
<span class="sd">            It must accept two `ProductSpaceElement` arguments and</span>
<span class="sd">            fulfill the following mathematical conditions for any</span>
<span class="sd">            three space elements ``x, y, z``:</span>

<span class="sd">            - ``dist(x, y) &gt;= 0``</span>
<span class="sd">            - ``dist(x, y) = 0``  if and only if  ``x = y``</span>
<span class="sd">            - ``dist(x, y) = dist(y, x)``</span>
<span class="sd">            - ``dist(x, y) &lt;= dist(x, z) + dist(z, y)``</span>

<span class="sd">            By default, ``dist(x, y)`` is calculated as ``norm(x - y)``.</span>

<span class="sd">            Cannot be combined with: ``weighting, norm, inner``</span>

<span class="sd">        norm : callable, optional</span>
<span class="sd">            The norm implementation. It must accept an</span>
<span class="sd">            `ProductSpaceElement` argument, return a float and satisfy the</span>
<span class="sd">            following conditions for all space elements ``x, y`` and scalars</span>
<span class="sd">            ``s``:</span>

<span class="sd">            - ``||x|| &gt;= 0``</span>
<span class="sd">            - ``||x|| = 0``  if and only if  ``x = 0``</span>
<span class="sd">            - ``||s * x|| = |s| * ||x||``</span>
<span class="sd">            - ``||x + y|| &lt;= ||x|| + ||y||``</span>

<span class="sd">            By default, ``norm(x)`` is calculated as ``inner(x, x)``.</span>

<span class="sd">            Cannot be combined with: ``weighting, dist, inner``</span>

<span class="sd">        inner : callable, optional</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `ProductSpaceElement` arguments, return a element from</span>
<span class="sd">            the field of the space (real or complex number) and</span>
<span class="sd">            satisfy the following conditions for all space elements</span>
<span class="sd">            ``x, y, z`` and scalars ``s``:</span>

<span class="sd">            - ``&lt;x, y&gt; = conj(&lt;y, x&gt;)``</span>
<span class="sd">            - ``&lt;s*x + y, z&gt; = s * &lt;x, z&gt; + &lt;y, z&gt;``</span>
<span class="sd">            - ``&lt;x, x&gt; = 0``  if and only if  ``x = 0``</span>

<span class="sd">            Cannot be combined with: ``weighting, dist, norm``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Product of two rn spaces</span>

<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(odl.rn(2), odl.rn(3))</span>

<span class="sd">        Powerspace of rn space</span>

<span class="sd">        &gt;&gt;&gt; r2x2x2 = ProductSpace(odl.rn(2), 3)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Inner product, norm and distance are evaluated by collecting</span>
<span class="sd">        the result of the corresponding operation in the individual</span>
<span class="sd">        components and reducing the resulting vector to a single number.</span>
<span class="sd">        The ``exponent`` parameter influences only this last part,</span>
<span class="sd">        not the computations in the individual components. We give the</span>
<span class="sd">        exact definitions in the following:</span>

<span class="sd">        Let :math:`\mathcal{X} = \mathcal{X}_1 \times \dots \times</span>
<span class="sd">        \mathcal{X}_d` be a product space, and</span>
<span class="sd">        :math:`\langle \cdot, \cdot\rangle_i`,</span>
<span class="sd">        :math:`\lVert \cdot \rVert_i`, :math:`d_i(\cdot, \cdot)` be</span>
<span class="sd">        inner products, norms and distances in the respective</span>
<span class="sd">        component spaces.</span>

<span class="sd">        **Inner product:**</span>

<span class="sd">        .. math::</span>
<span class="sd">            \langle x, y \rangle = \sum_{i=1}^d \langle x_i, y_i \rangle_i</span>

<span class="sd">        **Norm:**</span>

<span class="sd">        - :math:`p &lt; \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \lVert x\rVert =</span>
<span class="sd">            \left( \sum_{i=1}^d \lVert x_i \rVert_i^p \right)^{1/p}</span>

<span class="sd">        - :math:`p = \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \lVert x\rVert = \max_i \lVert x_i \rVert_i</span>

<span class="sd">        **Distance:**</span>

<span class="sd">        - :math:`p &lt; \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(x, y) = \left( \sum_{i=1}^d d_i(x_i, y_i)^p \right)^{1/p}</span>

<span class="sd">        - :math:`p = \infty`:</span>

<span class="sd">        .. math::</span>
<span class="sd">            d(x, y) = \max_i d_i(x_i, y_i)</span>

<span class="sd">        To implement own versions of these functions, you can use</span>
<span class="sd">        the following snippet to gather the vector of norms (analogously</span>
<span class="sd">        for inner products and distances)::</span>

<span class="sd">            norms = np.fromiter(</span>
<span class="sd">                (xi.norm() for xi in x),</span>
<span class="sd">                dtype=np.float64, count=len(x))</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpaceArrayWeighting</span>
<span class="sd">        ProductSpaceConstWeighting</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got unexpected keyword arguments: </span><span class="si">{}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Check validity of option combination (3 or 4 out of 4 must be None)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">weighting</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid combination of options weighting, &#39;</span>
                             <span class="s1">&#39;dist, norm and inner&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">))</span> <span class="ow">and</span> <span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`exponent` cannot be used together with &#39;</span>
                             <span class="s1">&#39;inner, norm or dist&#39;</span><span class="p">)</span>

        <span class="c1"># Make a power space if the second argument is an integer.</span>
        <span class="c1"># For the case that the integer is 0, we already set the field here.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">field</span>
            <span class="n">spaces</span> <span class="o">=</span> <span class="p">[</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Validate the space arguments</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">spc</span><span class="p">,</span> <span class="n">LinearSpace</span><span class="p">)</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;all arguments must be `LinearSpace` instances, or the &#39;</span>
                <span class="s1">&#39;first argument must be `LinearSpace` and the second &#39;</span>
                <span class="s1">&#39;integer; got </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spaces</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">field</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all spaces must have the same field&#39;</span><span class="p">)</span>

        <span class="c1"># Assign spaces and field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__spaces</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span>

        <span class="c1"># Cache for efficiency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_power_space</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Assing or infer field</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no spaces provided, cannot deduce field&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">field</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>

        <span class="c1"># Assign weighting</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">Weighting</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">weighting</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weighting</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceConstWeighting</span><span class="p">(</span>
                    <span class="n">weighting</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Need to wait until dist, norm and inner are handled</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># last possibility: make a product space element</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weighting</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid weighting argument </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceArrayWeighting</span><span class="p">(</span>
                        <span class="n">arr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weighting array has </span><span class="si">{}</span><span class="s1"> dimensions, &#39;</span>
                                     <span class="s1">&#39;expected 1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomDist</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomNorm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceCustomInner</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># all None -&gt; no weighing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">ProductSpaceConstWeighting</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``len(self)``.</span>

<span class="sd">        This length is the number of spaces at the top level only,</span>
<span class="sd">        and is equal to ``self.shape[0]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of bytes in memory used by an element of this space.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">spc</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total spaces per axis, computed recursively.</span>

<span class="sd">        The recursion ends at the fist level that does not have a shape.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; pspace.shape</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; pspace2 = odl.ProductSpace(pspace, 3)</span>
<span class="sd">        &gt;&gt;&gt; pspace2.shape</span>
<span class="sd">        (3, 2)</span>

<span class="sd">        If the space is a &quot;pure&quot; product space, shape recurses all the way</span>
<span class="sd">        into the components:</span>

<span class="sd">        &gt;&gt;&gt; r2_2 = odl.ProductSpace(r2, 3)</span>
<span class="sd">        &gt;&gt;&gt; r2_2.shape</span>
<span class="sd">        (3, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">sub_shape</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub_shape</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span> <span class="o">+</span> <span class="n">sub_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of involved spaces, computed recursively.</span>

<span class="sd">        The recursion ends at the fist level that does not comprise</span>
<span class="sd">        a *power* space, i.e., which is not made of equal spaces.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; pspace.size</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; pspace2 = odl.ProductSpace(pspace, 3)</span>
<span class="sd">        &gt;&gt;&gt; pspace2.size</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="k">else</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A tuple containing all spaces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__spaces</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_power_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if all member spaces are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_power_space</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent of the product space norm/dist, ``None`` for custom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This space&#39;s weighting scheme.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the space is not weighted by constant 1.0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ProductSpaceConstWeighting</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The data type of this space.</span>

<span class="sd">        This is only well defined if all subspaces have the same dtype.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If any of the subspaces does not implement `dtype` or if the dtype</span>
<span class="sd">            of the subspaces does not match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;`dtype`&#39;s of subspaces not equal&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this is a space of real valued vectors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span><span class="o">.</span><span class="n">is_real</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this is a space of complex valued vectors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">spc</span><span class="o">.</span><span class="n">is_complex</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Variant of this space with real dtype.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">complex_space</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Variant of this space with complex dtype.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">complex_space</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span>

<div class="viewcode-block" id="ProductSpace.astype"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.astype.html#odl.space.pspace.ProductSpace.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this space with new ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype :</span>
<span class="sd">            Scalar data type of the returned space. Can be provided</span>
<span class="sd">            in any way the `numpy.dtype` constructor understands, e.g.</span>
<span class="sd">            as built-in type or as a string. Data types with non-trivial</span>
<span class="sd">            shapes are not allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newspace : `ProductSpace`</span>
<span class="sd">            Version of this space with given data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Need to filter this out since Numpy iterprets it as &#39;float&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`None` is not a valid data type&#39;</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">current_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">current_dtype</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span></div>

<div class="viewcode-block" id="ProductSpace.element"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.element.html#odl.space.pspace.ProductSpace.element">[docs]</a>    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an element in the product space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : optional</span>
<span class="sd">            If ``inp`` is ``None``, a new element is created from</span>
<span class="sd">            scratch by allocation in the spaces. If ``inp`` is</span>
<span class="sd">            already an element of this space, it is re-wrapped.</span>
<span class="sd">            Otherwise, a new element is created from the</span>
<span class="sd">            components by calling the ``element()`` methods</span>
<span class="sd">            in the component spaces.</span>
<span class="sd">        cast : bool, optional</span>
<span class="sd">            If ``True``, casting is allowed. Otherwise, a ``TypeError``</span>
<span class="sd">            is raised for input that is not a sequence of elements of</span>
<span class="sd">            the spaces that make up this product space.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element : `ProductSpaceElement`</span>
<span class="sd">            The new element</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; vec_2, vec_3 = r2.element(), r3.element()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; vec_2x3 = r2x3.element()</span>
<span class="sd">        &gt;&gt;&gt; vec_2.space == vec_2x3[0].space</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; vec_3.space == vec_2x3[1].space</span>
<span class="sd">        True</span>

<span class="sd">        Create an element of the product space</span>

<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; prod = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; x2 = r2.element([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; x3 = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x = prod.element([x2, x3])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(rn(2), rn(3)).element([</span>
<span class="sd">            [ 1.,  2.],</span>
<span class="sd">            [ 1.,  2.,  3.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If data is given as keyword arg, prefer it over arg list</span>
        <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inp</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;length of `inp` </span><span class="si">{}</span><span class="s1"> does not match length of &#39;</span>
                             <span class="s1">&#39;space </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">space</span> <span class="o">==</span> <span class="n">space</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">space</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">))):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cast</span><span class="p">:</span>
            <span class="c1"># Delegate constructors</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">space</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;input </span><span class="si">{!r}</span><span class="s1"> not a sequence of elements of the &#39;</span>
                            <span class="s1">&#39;component spaces&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inp</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">examples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return examples from all sub-spaces.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">examples</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">spc</span><span class="o">.</span><span class="n">examples</span> <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">]):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">)</span>
            <span class="n">element</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">elem</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">])</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpace.zero"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.zero.html#odl.space.pspace.ProductSpace.zero">[docs]</a>    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the zero element of the product space.</span>

<span class="sd">        The i-th component of the product space zero element is the</span>
<span class="sd">        zero element of the i-th space in the product.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        zero : ProductSpaceElement</span>
<span class="sd">            The zero element in the product space.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; zero_2, zero_3 = r2.zero(), r3.zero()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; zero_2x3 = r2x3.zero()</span>
<span class="sd">        &gt;&gt;&gt; zero_2 == zero_2x3[0]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; zero_3 == zero_2x3[1]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span></div>

<div class="viewcode-block" id="ProductSpace.one"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.one.html#odl.space.pspace.ProductSpace.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create the one element of the product space.</span>

<span class="sd">        The i-th component of the product space one element is the</span>
<span class="sd">        one element of the i-th space in the product.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        one : ProductSpaceElement</span>
<span class="sd">            The one element in the product space.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; one_2, one_3 = r2.one(), r3.one()</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; one_2x3 = r2x3.one()</span>
<span class="sd">        &gt;&gt;&gt; one_2 == one_2x3[0]</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; one_3 == one_2x3[1]</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">space</span><span class="o">.</span><span class="n">one</span><span class="p">()</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">])</span></div>

<div class="viewcode-block" id="ProductSpace._lincomb"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._lincomb.html#odl.space.pspace.ProductSpace._lincomb">[docs]</a>    <span class="k">def</span> <span class="nf">_lincomb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Linear combination ``out = a*x + b*y``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">space</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                       <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">space</span><span class="o">.</span><span class="n">_lincomb</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._dist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._dist.html#odl.space.pspace.ProductSpace._dist">[docs]</a>    <span class="k">def</span> <span class="nf">_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Distance between two elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._norm.html#odl.space.pspace.ProductSpace._norm">[docs]</a>    <span class="k">def</span> <span class="nf">_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Norm of an element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._inner.html#odl.space.pspace.ProductSpace._inner">[docs]</a>    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inner product of two elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._multiply"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._multiply.html#odl.space.pspace.ProductSpace._multiply">[docs]</a>    <span class="k">def</span> <span class="nf">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Product ``out = x1 * x2``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                     <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">_multiply</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace._divide"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace._divide.html#odl.space.pspace.ProductSpace._divide">[docs]</a>    <span class="k">def</span> <span class="nf">_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Quotient ``out = x1 / x2``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">spc</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span>
                                     <span class="n">out</span><span class="o">.</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">spc</span><span class="o">.</span><span class="n">_divide</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">outp</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpace.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.__eq__.html#odl.space.pspace.ProductSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            ``True`` if ``other`` is a `ProductSpace` instance, has</span>
<span class="sd">            the same length and the same factors. ``False`` otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; rn, rm = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; r2x3, rnxm = ProductSpace(r2, r3), ProductSpace(rn, rm)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == rnxm</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; r3x2 = ProductSpace(r3, r2)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r3x2</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; r5 = ProductSpace(*[odl.rn(1)]*5)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r5</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; r5 = odl.rn(5)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 == r5</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weighting</span> <span class="ow">and</span>
                    <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span>
                                               <span class="n">other</span><span class="o">.</span><span class="n">spaces</span><span class="p">)))</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``hash(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>

<div class="viewcode-block" id="ProductSpace.__getitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpace.__getitem__.html#odl.space.pspace.ProductSpace.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Integers are used to pick components, slices to pick ranges:</span>

<span class="sd">        &gt;&gt;&gt; r2, r3, r4 = odl.rn(2), odl.rn(3), odl.rn(4)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r2, r3, r4)</span>
<span class="sd">        &gt;&gt;&gt; pspace[1]</span>
<span class="sd">        rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace[1:]</span>
<span class="sd">        ProductSpace(rn(3), rn(4))</span>

<span class="sd">        With lists, arbitrary components can be stacked together:</span>

<span class="sd">        &gt;&gt;&gt; pspace[[0, 2, 1, 2]]</span>
<span class="sd">        ProductSpace(rn(2), rn(4), rn(3), rn(4))</span>

<span class="sd">        Tuples, i.e. multi-indices, will recursively index higher-order</span>
<span class="sd">        product spaces. However, remaining indices cannot be passed</span>
<span class="sd">        down to component spaces that are not product spaces:</span>

<span class="sd">        &gt;&gt;&gt; pspace2 = odl.ProductSpace(pspace, 3)  # 2nd order product space</span>
<span class="sd">        &gt;&gt;&gt; pspace2</span>
<span class="sd">        ProductSpace(ProductSpace(rn(2), rn(3), rn(4)), 3)</span>
<span class="sd">        &gt;&gt;&gt; pspace2[0]</span>
<span class="sd">        ProductSpace(rn(2), rn(3), rn(4))</span>
<span class="sd">        &gt;&gt;&gt; pspace2[1, 0]</span>
<span class="sd">        rn(2)</span>
<span class="sd">        &gt;&gt;&gt; pspace2[:-1, 0]</span>
<span class="sd">        ProductSpace(rn(2), 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Use tuple indexing for recursive product spaces, i.e.,</span>
            <span class="c1"># pspace[0, 0] == pspace[0][0]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="c1"># Single integer in tuple, picking that space and passing</span>
                <span class="c1"># through the rest of the tuple. If the picked space</span>
                <span class="c1"># is not a product space and there are still indices left,</span>
                <span class="c1"># raise an error.</span>
                <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">rest_indcs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rest_indcs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">space</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">space</span><span class="p">[</span><span class="n">rest_indcs</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices for recursive &#39;</span>
                                     <span class="s1">&#39;product space: remaining indices &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rest_indcs</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="c1"># Doing the same as with single integer with all spaces</span>
                <span class="c1"># in the slice, but wrapping the result into a ProductSpace.</span>
                <span class="n">spaces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">rest_indcs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spaces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">rest_indcs</span><span class="p">:</span>
                    <span class="c1"># Need to catch this situation since the code further</span>
                    <span class="c1"># down doesn&#39;t trigger an error</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices for recursive &#39;</span>
                                     <span class="s1">&#39;product space: remaining indices &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rest_indcs</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rest_indcs</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="n">spaces</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span>
                        <span class="o">*</span><span class="p">(</span><span class="n">space</span><span class="p">[</span><span class="n">rest_indcs</span><span class="p">]</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="n">spaces</span><span class="p">),</span>
                        <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices for recursive &#39;</span>
                                     <span class="s1">&#39;product space: remaining indices &#39;</span>
                                     <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rest_indcs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;index tuple can only contain&#39;</span>
                                <span class="s1">&#39;integers or slices&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span>
                                <span class="n">field</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`indices` must be integer, slice, tuple or &#39;</span>
                            <span class="s1">&#39;list, got </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">) ** </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="k">for</span> <span class="n">space</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">weight_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">repr_part</span>
        <span class="n">edgeitems</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;edgeitems&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">posmod</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;field&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
            <span class="n">posmod</span> <span class="o">=</span> <span class="s1">&#39;!r&#39;</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edgeitems</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span>
            <span class="n">posmod</span> <span class="o">=</span> <span class="s1">&#39;!r&#39;</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">argstr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">)</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">argstr</span> <span class="o">+</span> <span class="n">weight_str</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">40</span> <span class="ow">and</span>
                       <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">argstr</span> <span class="o">+</span> <span class="n">weight_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[:</span><span class="n">edgeitems</span><span class="p">]</span> <span class="o">+</span>
                       <span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">,)</span> <span class="o">+</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">spaces</span><span class="p">[</span><span class="o">-</span><span class="n">edgeitems</span><span class="p">:])</span>
            <span class="n">posmod</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;!r&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">edgeitems</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;!s&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;!r&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">edgeitems</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">oneline</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">oneline</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="p">,</span>
                                         <span class="n">mod</span><span class="o">=</span><span class="p">[</span><span class="n">posmod</span><span class="p">,</span> <span class="s1">&#39;!r&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">weight_str</span><span class="p">:</span>
                <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">inner_str</span><span class="p">,</span> <span class="n">weight_str</span><span class="p">])</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                                         <span class="n">mod</span><span class="o">=</span><span class="p">[</span><span class="n">posmod</span><span class="p">,</span> <span class="s1">&#39;!r&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">weight_str</span><span class="p">:</span>
                <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">inner_str</span><span class="p">,</span> <span class="n">weight_str</span><span class="p">])</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="n">indent</span><span class="p">(</span><span class="n">inner_str</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`ProductSpaceElement`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpaceElement</span></div>


<div class="viewcode-block" id="ProductSpaceElement"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.html#odl.space.pspace.ProductSpaceElement">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceElement</span><span class="p">(</span><span class="n">LinearSpaceElement</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Elements of a `ProductSpace`.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceElement.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.html#odl.space.pspace.ProductSpaceElement.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">parts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parts of this product space element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of values per axis in ``self``, computed recursively.</span>

<span class="sd">        The recursion ends at the fist level that does not have a shape.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a `ProductSpace` is encountered that is not a power space.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpace.shape</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r4_3 = odl.ProductSpace(odl.rn(4), 3)</span>
<span class="sd">        &gt;&gt;&gt; x = r4_3.element()</span>
<span class="sd">        &gt;&gt;&gt; x.shape</span>
<span class="sd">        (3, 4)</span>
<span class="sd">        &gt;&gt;&gt; r4_2_3 = odl.ProductSpace(r4_3, 2)</span>
<span class="sd">        &gt;&gt;&gt; y = r4_2_3.element()</span>
<span class="sd">        &gt;&gt;&gt; y.shape</span>
<span class="sd">        (2, 3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number axes in ``self``, computed recursively.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a `ProductSpace` is encountered that is not a power space.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        shape</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r4_3 = odl.ProductSpace(odl.rn(4), 3)</span>
<span class="sd">        &gt;&gt;&gt; x = r4_3.element()</span>
<span class="sd">        &gt;&gt;&gt; x.ndim</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; r4_2_3 = odl.ProductSpace(r4_3, 2)</span>
<span class="sd">        &gt;&gt;&gt; y = r4_2_3.element()</span>
<span class="sd">        &gt;&gt;&gt; y.ndim</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of involved spaces, computed recursively.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpace.size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The data type of the space of this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Total number of bytes in memory used by this element.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">nbytes</span>

<div class="viewcode-block" id="ProductSpaceElement.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__eq__.html#odl.space.pspace.ProductSpaceElement.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Overrides the default `LinearSpace` method since it is implemented with</span>
<span class="sd">        the distance function, which is prone to numerical errors. This</span>
<span class="sd">        function checks equality per component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">sp</span> <span class="o">==</span> <span class="n">op</span> <span class="k">for</span> <span class="n">sp</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">parts</span><span class="p">))</span></div>

<div class="viewcode-block" id="ProductSpaceElement.__getitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__getitem__.html#odl.space.pspace.ProductSpaceElement.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">out_parts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">out_parts</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ProductSpace</span><span class="p">()</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Tuple with a single entry - we just unpack and delegate</span>
                <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Tuple with multiple entries</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
                    <span class="c1"># In case the first entry is an integer, we drop the</span>
                    <span class="c1"># axis and return directly from `parts`</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># indices[0] is a slice or list. We first retrieve the</span>
                    <span class="c1"># parts indexed in this axis.</span>
                    <span class="c1"># In any case we know that we want to keep this axis.</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                            <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ProductSpaceElement</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="p">)):</span>
                        <span class="c1"># This case means we have &quot;hit the bottom&quot;, i.e.,</span>
                        <span class="c1"># there are non-ProductSpaces involved. In order</span>
                        <span class="c1"># not to retrieve scalar values from these</span>
                        <span class="c1"># elements, we use a slice of size 1.</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">indexed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Here we&#39;re still in the &quot;product space chain&quot;,</span>
                        <span class="c1"># so we can use recursion to go on.</span>
                        <span class="n">indexed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="p">]</span>

                    <span class="c1"># Finally make a wrapping space for the indexed elements</span>
                    <span class="n">new_space</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">space</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indexed</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">new_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">indexed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bad index type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ProductSpaceElement.__setitem__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.__setitem__.html#odl.space.pspace.ProductSpaceElement.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self[indices] = values``.&quot;&quot;&quot;</span>
        <span class="c1"># Get the parts to which we assign values</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">],)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">(</span><span class="n">values</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">indexed_parts</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We need to explicitly use __setitem__ here, otherwise</span>
                <span class="c1"># __getitem__ is used and assigned to, which fails if</span>
                <span class="c1"># a space like rn(3) is indexed at the very end.</span>
                <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">):</span>
                    <span class="n">part</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">values</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># part is a tuple</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
                        <span class="n">p</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">values</span><span class="p">)</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;bad index type </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>

        <span class="c1"># Do the assignment, with broadcasting if desired</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># `values` is not iterable, assume it can be assigned to</span>
            <span class="c1"># all indexed parts</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indexed_parts</span><span class="p">:</span>
                <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># `values` is iterable; it could still represent a single</span>
            <span class="c1"># element of a power space.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">and</span> <span class="n">values</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Broadcast a single element across a power space</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indexed_parts</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Now we really have one assigned value per part</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;length of iterable `values` not equal to number of &#39;</span>
                        <span class="s1">&#39;indexed parts (</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">)&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indexed_parts</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                    <span class="n">p</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">v</span></div>

<div class="viewcode-block" id="ProductSpaceElement.asarray"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.asarray.html#odl.space.pspace.ProductSpaceElement.asarray">[docs]</a>    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the data of this vector as a numpy array.</span>

<span class="sd">        Only available if `is_power_space` is True.</span>

<span class="sd">        The ordering is such that it commutes with indexing::</span>

<span class="sd">            self[ind].asarray() == self.asarray()[ind]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            Array in which the result should be written in-place.</span>
<span class="sd">            Has to be contiguous and of the correct dtype and</span>
<span class="sd">            shape.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `is_power_space` is false.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; spc = odl.ProductSpace(odl.rn(3), 2)</span>
<span class="sd">        &gt;&gt;&gt; x = spc.element([[ 1.,  2.,  3.],</span>
<span class="sd">        ...                  [ 4.,  5.,  6.]])</span>
<span class="sd">        &gt;&gt;&gt; x.asarray()</span>
<span class="sd">        array([[ 1.,  2.,  3.],</span>
<span class="sd">               [ 4.,  5.,  6.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot use `asarray` if `space.is_power_space` &#39;</span>
                             <span class="s1">&#39;is `False`&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An array representation of ``self``.</span>

<span class="sd">        Only available if `is_power_space` is True.</span>

<span class="sd">        The ordering is such that it commutes with indexing::</span>

<span class="sd">            np.array(self[ind]) == np.array(self)[ind]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `is_power_space` is false.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; spc = odl.ProductSpace(odl.rn(3), 2)</span>
<span class="sd">        &gt;&gt;&gt; x = spc.element([[ 1.,  2.,  3.],</span>
<span class="sd">        ...                  [ 4.,  5.,  6.]])</span>
<span class="sd">        &gt;&gt;&gt; np.asarray(x)</span>
<span class="sd">        array([[ 1.,  2.,  3.],</span>
<span class="sd">               [ 4.,  5.,  6.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new product space element wrapping the ``array``.</span>

<span class="sd">        Only available if `is_power_space` is ``True``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : `numpy.ndarray`</span>
<span class="sd">            Array to be wrapped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        wrapper : `ProductSpaceElement`</span>
<span class="sd">            Product space element wrapping ``array``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># HACK(kohr-h): This is to support (full) reductions like</span>
        <span class="c1"># `np.sum(x)` for numpy&gt;=1.16, where many such reductions</span>
        <span class="c1"># moved from plain functions to `ufunc.reduce.*`, thus</span>
        <span class="c1"># invoking the `__array__` and `__array_wrap__` machinery.</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ufuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;`ProductSpaceUfuncs`, access to Numpy style ufuncs.</span>

<span class="sd">        These are always available if the underlying spaces are</span>
<span class="sd">        `TensorSpace`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r22 = odl.ProductSpace(odl.rn(2), 2)</span>
<span class="sd">        &gt;&gt;&gt; x = r22.element([[1, -2], [-3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; x.ufuncs.absolute()</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [ 1.,  2.],</span>
<span class="sd">            [ 3.,  4.]</span>
<span class="sd">        ])</span>

<span class="sd">        These functions can also be used with non-vector arguments and</span>
<span class="sd">        support broadcasting, per component and even recursively:</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.add([1, 2])</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [ 2.,  0.],</span>
<span class="sd">            [-2.,  6.]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; x.ufuncs.subtract(1)</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [ 0., -3.],</span>
<span class="sd">            [-4.,  3.]</span>
<span class="sd">        ])</span>

<span class="sd">        There is also support for various reductions (sum, prod, min, max):</span>

<span class="sd">        &gt;&gt;&gt; x.ufuncs.sum()</span>
<span class="sd">        0.0</span>

<span class="sd">        Writing to ``out`` is also supported:</span>

<span class="sd">        &gt;&gt;&gt; y = r22.element()</span>
<span class="sd">        &gt;&gt;&gt; result = x.ufuncs.absolute(out=y)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        ProductSpace(rn(2), 2).element([</span>
<span class="sd">            [ 1.,  2.],</span>
<span class="sd">            [ 3.,  4.]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; result is y</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.util.ufuncs.TensorSpaceUfuncs</span>
<span class="sd">            Base class for ufuncs in `TensorSpace` spaces, subspaces may</span>
<span class="sd">            override this for greater efficiency.</span>
<span class="sd">        odl.util.ufuncs.ProductSpaceUfuncs</span>
<span class="sd">            For a list of available ufuncs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ProductSpaceUfuncs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Real part of the element.</span>

<span class="sd">        The real part can also be set using ``x.real = other``, where ``other``</span>
<span class="sd">        is array-like or scalar.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(odl.cn(3), odl.cn(2))</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([[1 + 1j, 2, 3 - 3j],</span>
<span class="sd">        ...                    [-1 + 2j, -2 - 3j]])</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        ProductSpace(rn(3), rn(2)).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [-1., -2.]</span>
<span class="sd">        ])</span>

<span class="sd">        The real part can also be set using different array-like types:</span>

<span class="sd">        &gt;&gt;&gt; x.real = space.real_space.zero()</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 0.+1.j,  0.+0.j,  0.-3.j],</span>
<span class="sd">            [ 0.+2.j,  0.-3.j]</span>
<span class="sd">        ])</span>

<span class="sd">        &gt;&gt;&gt; x.real = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 1.+1.j,  1.+0.j,  1.-3.j],</span>
<span class="sd">            [ 1.+2.j,  1.-3.j]</span>
<span class="sd">        ])</span>

<span class="sd">        &gt;&gt;&gt; x.real = [[2, 3, 4], [5, 6]]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 2.+1.j,  3.+0.j,  4.-3.j],</span>
<span class="sd">            [ 5.+2.j,  6.-3.j]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">real_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">part</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">real_part</span><span class="p">)</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for the real part.</span>

<span class="sd">        This method is invoked by ``x.real = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newreal : array-like or scalar</span>
<span class="sd">            Values to be assigned to the real part of this element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">newreal</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># `newreal` is not iterable, assume it can be assigned to</span>
            <span class="c1"># all indexed parts</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="n">part</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">newreal</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Set same value in all parts</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">newreal</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="c1"># Iterate over all parts and set them separately</span>
                <span class="k">for</span> <span class="n">part</span><span class="p">,</span> <span class="n">new_re</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">new_re</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">newreal</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">part</span><span class="p">,</span> <span class="n">new_re</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
                <span class="n">part</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">new_re</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;dimensions of the new real part does not match the space, &#39;</span>
                <span class="s1">&#39;got element </span><span class="si">{}</span><span class="s1"> to set real part of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">newreal</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Imaginary part of the element.</span>

<span class="sd">        The imaginary part can also be set using ``x.imag = other``, where</span>
<span class="sd">        ``other`` is array-like or scalar.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(odl.cn(3), odl.cn(2))</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([[1 + 1j, 2, 3 - 3j],</span>
<span class="sd">        ...                    [-1 + 2j, -2 - 3j]])</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        ProductSpace(rn(3), rn(2)).element([</span>
<span class="sd">            [ 1.,  0., -3.],</span>
<span class="sd">            [ 2., -3.]</span>
<span class="sd">        ])</span>

<span class="sd">        The imaginary part can also be set using different array-like types:</span>

<span class="sd">        &gt;&gt;&gt; x.imag = space.real_space.zero()</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 1.+0.j,  2.+0.j,  3.+0.j],</span>
<span class="sd">            [-1.+0.j, -2.+0.j]</span>
<span class="sd">        ])</span>

<span class="sd">        &gt;&gt;&gt; x.imag = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 1.+1.j,  2.+1.j,  3.+1.j],</span>
<span class="sd">            [-1.+1.j, -2.+1.j]</span>
<span class="sd">        ])</span>

<span class="sd">        &gt;&gt;&gt; x.imag = [[2, 3, 4], [5, 6]]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(cn(3), cn(2)).element([</span>
<span class="sd">            [ 1.+2.j,  2.+3.j,  3.+4.j],</span>
<span class="sd">            [-1.+5.j, -2.+6.j]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">imag_part</span> <span class="o">=</span> <span class="p">[</span><span class="n">part</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">imag_part</span><span class="p">)</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for the imaginary part.</span>

<span class="sd">        This method is invoked by ``x.imag = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newimag : array-like or scalar</span>
<span class="sd">            Values to be assigned to the imaginary part of this element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">newimag</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="c1"># `newimag` is not iterable, assume it can be assigned to</span>
            <span class="c1"># all indexed parts</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="n">part</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">newimag</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Set same value in all parts</span>
                <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">:</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">newimag</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="c1"># Iterate over all parts and set them separately</span>
                <span class="k">for</span> <span class="n">part</span><span class="p">,</span> <span class="n">new_im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
                    <span class="n">part</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">new_im</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">newimag</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">part</span><span class="p">,</span> <span class="n">new_im</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
                <span class="n">part</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">new_im</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;dimensions of the new imaginary part does not match the &#39;</span>
                <span class="s1">&#39;space, got element </span><span class="si">{}</span><span class="s1"> to set real part of </span><span class="si">{}</span><span class="s1">}&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">newimag</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="ProductSpaceElement.conj"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.conj.html#odl.space.pspace.ProductSpaceElement.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Complex conjugate of the element.&quot;&quot;&quot;</span>
        <span class="n">complex_conj</span> <span class="o">=</span> <span class="p">[</span><span class="n">part</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">complex_conj</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from odl import rn  # need to import rn into namespace</span>
<span class="sd">        &gt;&gt;&gt; r2, r3 = odl.rn(2), odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; r2x3 = ProductSpace(r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; x = r2x3.element([[1, 2], [3, 4, 5]])</span>
<span class="sd">        &gt;&gt;&gt; eval(repr(x)) == x</span>
<span class="sd">        True</span>

<span class="sd">        The result is readable:</span>

<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(rn(2), rn(3)).element([</span>
<span class="sd">            [ 1.,  2.],</span>
<span class="sd">            [ 3.,  4.,  5.]</span>
<span class="sd">        ])</span>

<span class="sd">        Nestled spaces work as well:</span>

<span class="sd">        &gt;&gt;&gt; X = ProductSpace(r2x3, r2x3)</span>
<span class="sd">        &gt;&gt;&gt; x = X.element([[[1, 2], [3, 4, 5]],[[1, 2], [3, 4, 5]]])</span>
<span class="sd">        &gt;&gt;&gt; eval(repr(x)) == x</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        ProductSpace(ProductSpace(rn(2), rn(3)), 2).element([</span>
<span class="sd">            [</span>
<span class="sd">                [ 1.,  2.],</span>
<span class="sd">                [ 3.,  4.,  5.]</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                [ 1.,  2.],</span>
<span class="sd">                [ 3.,  4.,  5.]</span>
<span class="sd">            ]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inner_str</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    ...</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">_indent</span><span class="p">(</span><span class="n">_strip_space</span><span class="p">(</span><span class="n">part</span><span class="p">)))</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">]&#39;</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">.element(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceElement.show"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceElement.show.html#odl.space.pspace.ProductSpaceElement.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Display the parts of this product space element graphically.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title of the figures</span>

<span class="sd">        indices : int, slice, tuple or list, optional</span>
<span class="sd">            Display parts of ``self`` in the way described in the following.</span>

<span class="sd">            A single list of integers selects the corresponding parts</span>
<span class="sd">            of this vector.</span>

<span class="sd">            For other tuples or lists, the first entry indexes the parts of</span>
<span class="sd">            this vector, and the remaining entries (if any) are used to</span>
<span class="sd">            slice into the parts. Handling those remaining indices is</span>
<span class="sd">            up to the ``show`` methods of the parts to be displayed.</span>

<span class="sd">            The types of the first entry trigger the following behaviors:</span>

<span class="sd">                - ``int``: take the part corresponding to this index</span>
<span class="sd">                - ``slice``: take a subset of the parts</span>
<span class="sd">                - ``None``: equivalent to ``slice(None)``, i.e., everything</span>

<span class="sd">            Typical use cases are displaying of selected parts, which can</span>
<span class="sd">            be achieved with a list, e.g., ``indices=[0, 2]`` for parts</span>
<span class="sd">            0 and 2, and plotting of all parts sliced in a certain way,</span>
<span class="sd">            e.g., ``indices=[None, 20, None]`` for showing all parts</span>
<span class="sd">            sliced with indices ``[20, None]``.</span>

<span class="sd">            A single ``int``, ``slice``, ``list`` or ``None`` object</span>
<span class="sd">            indexes the parts only, i.e., is treated roughly as</span>
<span class="sd">            ``(indices, Ellipsis)``. In particular, for ``None``, all</span>
<span class="sd">            parts are shown with default slicing.</span>

<span class="sd">        in_figs : sequence of `matplotlib.figure.Figure`, optional</span>
<span class="sd">            Update these figures instead of creating new ones. Typically</span>
<span class="sd">            the return value of an earlier call to ``show`` is used</span>
<span class="sd">            for this parameter.</span>

<span class="sd">        kwargs</span>
<span class="sd">            Additional arguments passed on to the ``show`` methods of</span>
<span class="sd">            the parts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        figs : tuple of `matplotlib.figure.Figure`</span>
<span class="sd">            The resulting figures. In an interactive shell, they are</span>
<span class="sd">            automatically displayed.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.discr.discr_space.DiscretizedSpaceElement.show :</span>
<span class="sd">            Display of a discretized function</span>
<span class="sd">        odl.space.base_tensors.Tensor.show :</span>
<span class="sd">            Display of sequence type data</span>
<span class="sd">        odl.util.graphics.show_discrete_data :</span>
<span class="sd">            Underlying implementation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;ProductSpaceElement&#39;</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span>
                     <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">))):</span>
                <span class="c1"># Tuples or lists containing non-integers index by axis.</span>
                <span class="c1"># We use the first index for the current pspace and pass</span>
                <span class="c1"># on the rest.</span>
                <span class="n">indices</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># Support `indices=[None, 0, None]` like syntax (`indices` is</span>
            <span class="c1"># the first entry as of now in that case)</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">indices</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use `indices` as-is</span>
                <span class="k">pass</span>

        <span class="n">in_figs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fig&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">in_figs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_figs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">in_figs</span>

        <span class="n">figs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Don&#39;t extend the title if there is only one plot</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">in_figs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extend titles by indexed part to make them distinguishable</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">part</span><span class="p">,</span> <span class="n">fig</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">in_figs</span><span class="p">):</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">. Part </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">figs</span><span class="p">)</span></div></div>


<span class="c1"># --- Add arithmetic operators that broadcast --- #</span>


<span class="k">def</span> <span class="nf">_broadcast_arithmetic</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return ``op(self, other)`` with broadcasting.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : string</span>
<span class="sd">        Name of the operator, e.g. ``&#39;__add__&#39;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    broadcast_arithmetic_op : function</span>
<span class="sd">        Function intended to be used as a method for `ProductSpaceVector`</span>
<span class="sd">        which performs broadcasting if possible.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Broadcasting is the operation of &quot;applying an operator multiple times&quot; in</span>
<span class="sd">    some sense. For example:</span>

<span class="sd">    .. math::</span>
<span class="sd">        (1, 2) + 1 = (2, 3)</span>

<span class="sd">    is a form of broadcasting. In this implementation, we only allow &quot;single</span>
<span class="sd">    layer&quot; broadcasting, i.e., we do not support broadcasting over several</span>
<span class="sd">    product spaces at once.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">_broadcast_arithmetic_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">op</span><span class="p">)(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">LinearSpaceElement</span><span class="p">,</span> <span class="n">op</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># Set docstring</span>
    <span class="n">docstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Broadcasted </span><span class="si">{op}</span><span class="s2">.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">)</span>
    <span class="n">_broadcast_arithmetic_impl</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">docstring</span>

    <span class="k">return</span> <span class="n">_broadcast_arithmetic_impl</span>


<span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;sub&#39;</span><span class="p">,</span> <span class="s1">&#39;mul&#39;</span><span class="p">,</span> <span class="s1">&#39;div&#39;</span><span class="p">,</span> <span class="s1">&#39;truediv&#39;</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">modifier</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">]:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;__</span><span class="si">{}{}</span><span class="s1">__&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">modifier</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">ProductSpaceElement</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_broadcast_arithmetic</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>


<div class="viewcode-block" id="ProductSpaceArrayWeighting"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.html#odl.space.pspace.ProductSpaceArrayWeighting">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceArrayWeighting</span><span class="p">(</span><span class="n">ArrayWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Array weighting for `ProductSpace`.</span>

<span class="sd">    This class defines a weighting that has a different value for</span>
<span class="sd">    each index defined in a given space.</span>
<span class="sd">    See ``Notes`` for mathematical details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceArrayWeighting.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.html#odl.space.pspace.ProductSpaceArrayWeighting.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : 1-dim. `array-like`</span>
<span class="sd">            Weighting array of the inner product.</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no inner</span>
<span class="sd">            product is defined.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with array</span>
<span class="sd">          :math:`w` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">              \langle x, y \rangle_w = \langle w \odot x, y \rangle</span>

<span class="sd">          with component-wise multiplication :math:`w \odot x`. For other</span>
<span class="sd">          exponents, only ``norm`` and ``dist`` are defined. In the case</span>
<span class="sd">          of exponent ``inf``, the weighted norm is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,\infty} = \|w \odot x\|_\infty,</span>

<span class="sd">          otherwise it is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,p} = \|w^{1/p} \odot x\|_p.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit property</span>
<span class="sd">          in :math:`p`, i.e.,</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{w,p} \not\to \|x\|_{w,\infty}</span>
<span class="sd">              \quad\text{for } p \to \infty</span>

<span class="sd">          unless :math:`w = (1,...,1)`. The reason for this choice</span>
<span class="sd">          is that the alternative with the limit property consists in</span>
<span class="sd">          ignoring the weights altogether.</span>

<span class="sd">        - The array may only have positive entries, otherwise it does not</span>
<span class="sd">          define an inner product or norm, respectively. This is not checked</span>
<span class="sd">          during initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceArrayWeighting</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">array</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceArrayWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.inner.html#odl.space.pspace.ProductSpaceArrayWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the array-weighted inner product of two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="n">inners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceArrayWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceArrayWeighting.norm.html#odl.space.pspace.ProductSpaceArrayWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the array-weighted norm of an element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `ProductSpaceElement`</span>
<span class="sd">            Element whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the provided element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">norm_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># TODO: optimize?!</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_squared</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
                <span class="n">norms</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">norms</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ProductSpaceConstWeighting"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.html#odl.space.pspace.ProductSpaceConstWeighting">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceConstWeighting</span><span class="p">(</span><span class="n">ConstWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Constant weighting for `ProductSpace`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceConstWeighting.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.html#odl.space.pspace.ProductSpaceConstWeighting.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constant : positive float</span>
<span class="sd">            Weighting constant of the inner product</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no inner</span>
<span class="sd">            product is defined.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with constant</span>
<span class="sd">          :math:`c` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">            \langle x, y \rangle_c = c\, \langle x, y \rangle.</span>

<span class="sd">          For other exponents, only ``norm`` and ```dist`` are defined.</span>
<span class="sd">          In the case of exponent ``inf``, the weighted norm is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,\infty} = c\, \|x\|_\infty,</span>

<span class="sd">          otherwise it is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,p} = c^{1/p} \, \|x\|_p.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit property</span>
<span class="sd">          in :math:`p`, i.e.,</span>

<span class="sd">          .. math::</span>
<span class="sd">              \|x\|_{c,p} \not\to \|x\|_{c,\infty}</span>
<span class="sd">              \quad \text{for } p \to \infty</span>

<span class="sd">          unless :math:`c = 1`. The reason for this choice</span>
<span class="sd">          is that the alternative with the limit property consists in</span>
<span class="sd">          ignoring the weight altogether.</span>

<span class="sd">        - The constant must be positive, otherwise it does not define an</span>
<span class="sd">          inner product or norm, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceConstWeighting</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">constant</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceConstWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.inner.html#odl.space.pspace.ProductSpaceConstWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted inner product of two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="n">inners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x1i</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x2i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

        <span class="n">inner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inners</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="ProductSpaceConstWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.norm.html#odl.space.pspace.ProductSpaceConstWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted norm of an element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1 : `ProductSpaceElement`</span>
<span class="sd">            Element whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">norm_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># TODO: optimize?!</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_squared</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                        <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">norms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span></div>

<div class="viewcode-block" id="ProductSpaceConstWeighting.dist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceConstWeighting.dist.html#odl.space.pspace.ProductSpaceConstWeighting.dist">[docs]</a>    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate the constant-weighted distance between two elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `ProductSpaceElement`</span>
<span class="sd">            Elements whose mutual distance is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            The distance between the elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dnorms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
            <span class="p">((</span><span class="n">x1i</span> <span class="o">-</span> <span class="n">x2i</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="k">for</span> <span class="n">x1i</span><span class="p">,</span> <span class="n">x2i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dnorms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dnorms</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="ProductSpaceCustomInner"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomInner.html#odl.space.pspace.ProductSpaceCustomInner">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomInner</span><span class="p">(</span><span class="n">CustomInner</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified inner products.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceCustomInner.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomInner.html#odl.space.pspace.ProductSpaceCustomInner.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inner : callable</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `ProductSpaceElement` arguments, return a element from</span>
<span class="sd">            the field of the space (real or complex number) and</span>
<span class="sd">            satisfy the following conditions for all space elements</span>
<span class="sd">            ``x, y, z`` and scalars ``s``:</span>

<span class="sd">            - ``&lt;x, y&gt; = conj(&lt;y, x&gt;)``</span>
<span class="sd">            - ``&lt;s*x + y, z&gt; = s * &lt;x, z&gt; + &lt;y, z&gt;``</span>
<span class="sd">            - ``&lt;x, x&gt; = 0``  if and only if  ``x = 0``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceCustomInner</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">inner</span><span class="o">=</span><span class="n">inner</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ProductSpaceCustomNorm"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomNorm.html#odl.space.pspace.ProductSpaceCustomNorm">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomNorm</span><span class="p">(</span><span class="n">CustomNorm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified norm on `ProductSpace`.</span>

<span class="sd">    Note that this removes ``inner``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceCustomNorm.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomNorm.html#odl.space.pspace.ProductSpaceCustomNorm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : callable</span>
<span class="sd">            The norm implementation. It must accept a</span>
<span class="sd">            `ProductSpaceElement` argument, return a float and satisfy</span>
<span class="sd">            the following conditions for all space elements</span>
<span class="sd">            ``x, y`` and scalars ``s``:</span>

<span class="sd">            - ``||x|| &gt;= 0``</span>
<span class="sd">            - ``||x|| = 0``  if and only if  ``x = 0``</span>
<span class="sd">            - ``||s * x|| = |s| * ||x||``</span>
<span class="sd">            - ``||x + y|| &lt;= ||x|| + ||y||``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceCustomNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ProductSpaceCustomDist"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomDist.html#odl.space.pspace.ProductSpaceCustomDist">[docs]</a><span class="k">class</span> <span class="nc">ProductSpaceCustomDist</span><span class="p">(</span><span class="n">CustomDist</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified distance on `ProductSpace`.</span>

<span class="sd">    Note that this removes ``inner`` and ``norm``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceCustomDist.__init__"><a class="viewcode-back" href="../../../generated/odl.space.pspace.ProductSpaceCustomDist.html#odl.space.pspace.ProductSpaceCustomDist.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist : callable</span>
<span class="sd">            The distance function defining a metric on</span>
<span class="sd">            `ProductSpace`. It must accept two `ProductSpaceElement`</span>
<span class="sd">            arguments and fulfill the following mathematical conditions</span>
<span class="sd">            for any three space elements ``x, y, z``:</span>

<span class="sd">            - ``dist(x, y) &gt;= 0``</span>
<span class="sd">            - ``dist(x, y) = 0``  if and only if  ``x = y``</span>
<span class="sd">            - ``dist(x, y) = dist(y, x)``</span>
<span class="sd">            - ``dist(x, y) &lt;= dist(x, z) + dist(z, y)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceCustomDist</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_strip_space</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Strip the SPACE.element( ... ) part from a repr.&quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">space_repr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">.element(&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">space</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">space_repr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">space_repr</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_indent</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Indent a string by 4 characters.&quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;    &#39;</span> <span class="o">+</span> <span class="n">line</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>