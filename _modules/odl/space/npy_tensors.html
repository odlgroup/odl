

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.space.npy_tensors &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.space.npy_tensors</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.space.npy_tensors</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;NumPy implementation of tensor spaces.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="kn">import</span> <span class="n">native</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">object</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.set.sets</span> <span class="kn">import</span> <span class="n">ComplexNumbers</span><span class="p">,</span> <span class="n">RealNumbers</span>
<span class="kn">from</span> <span class="nn">odl.set.space</span> <span class="kn">import</span> <span class="n">LinearSpaceTypeError</span>
<span class="kn">from</span> <span class="nn">odl.space.base_tensors</span> <span class="kn">import</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">TensorSpace</span>
<span class="kn">from</span> <span class="nn">odl.space.weighting</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayWeighting</span><span class="p">,</span> <span class="n">ConstWeighting</span><span class="p">,</span> <span class="n">CustomDist</span><span class="p">,</span> <span class="n">CustomInner</span><span class="p">,</span> <span class="n">CustomNorm</span><span class="p">,</span>
    <span class="n">Weighting</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dtype_str</span><span class="p">,</span> <span class="n">is_floating_dtype</span><span class="p">,</span> <span class="n">is_numeric_dtype</span><span class="p">,</span> <span class="n">is_real_dtype</span><span class="p">,</span> <span class="n">nullcontext</span><span class="p">,</span>
    <span class="n">signature_string</span><span class="p">,</span> <span class="n">writable_array</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;NumpyTensorSpace&#39;</span><span class="p">,)</span>


<span class="n">_BLAS_DTYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex64&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">))</span>

<span class="c1"># Define size thresholds to switch implementations</span>
<span class="n">THRESHOLD_SMALL</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">THRESHOLD_MEDIUM</span> <span class="o">=</span> <span class="mi">50000</span>


<div class="viewcode-block" id="NumpyTensorSpace"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.html#odl.space.npy_tensors.NumpyTensorSpace">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpace</span><span class="p">(</span><span class="n">TensorSpace</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Set of tensors of arbitrary data type, implemented with NumPy.</span>

<span class="sd">    A tensor is, in the most general sense, a multi-dimensional array</span>
<span class="sd">    that allows operations per entry (keep the rank constant),</span>
<span class="sd">    reductions / contractions (reduce the rank) and broadcasting</span>
<span class="sd">    (raises the rank).</span>
<span class="sd">    For non-numeric data type like ``object``, the range of valid</span>
<span class="sd">    operations is rather limited since such a set of tensors does not</span>
<span class="sd">    define a vector space.</span>
<span class="sd">    Any numeric data type, on the other hand, is considered valid for</span>
<span class="sd">    a tensor space, although certain operations - like division with</span>
<span class="sd">    integer dtype - are not guaranteed to yield reasonable results.</span>

<span class="sd">    Under these restrictions, all basic vector space operations are</span>
<span class="sd">    supported by this class, along with reductions based on arithmetic</span>
<span class="sd">    or comparison, and element-wise mathematical functions (&quot;ufuncs&quot;).</span>

<span class="sd">    This class is implemented using `numpy.ndarray`&#39;s as back-end.</span>

<span class="sd">    See the `Wikipedia article on tensors`_ for further details.</span>
<span class="sd">    See also [Hac2012] &quot;Part I Algebraic Tensors&quot; for a rigorous</span>
<span class="sd">    treatment of tensors with a definition close to this one.</span>

<span class="sd">    Note also that this notion of tensors is the same as in popular</span>
<span class="sd">    Deep Learning frameworks.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Hac2012] Hackbusch, W. *Tensor Spaces and Numerical Tensor Calculus*.</span>
<span class="sd">    Springer, 2012.</span>

<span class="sd">    .. _Wikipedia article on tensors: https://en.wikipedia.org/wiki/Tensor</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpace.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.html#odl.space.npy_tensors.NumpyTensorSpace.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : positive int or sequence of positive ints</span>
<span class="sd">            Number of entries per axis for elements in this space. A</span>
<span class="sd">            single integer results in a space with rank 1, i.e., 1 axis.</span>
<span class="sd">        dtype :</span>
<span class="sd">            Data type of each element. Can be provided in any</span>
<span class="sd">            way the `numpy.dtype` function understands, e.g.</span>
<span class="sd">            as built-in type or as a string. For ``None``,</span>
<span class="sd">            the `default_dtype` of this space (``float64``) is used.</span>
<span class="sd">        exponent : positive float, optional</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no</span>
<span class="sd">            inner product is defined.</span>

<span class="sd">            This option has no impact if either ``dist``, ``norm`` or</span>
<span class="sd">            ``inner`` is given, or if ``dtype`` is non-numeric.</span>

<span class="sd">            Default: 2.0</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        weighting : optional</span>
<span class="sd">            Use weighted inner product, norm, and dist. The following</span>
<span class="sd">            types are supported as ``weighting``:</span>

<span class="sd">            ``None``: no weighting, i.e. weighting with ``1.0`` (default).</span>

<span class="sd">            `Weighting`: Use this weighting as-is. Compatibility</span>
<span class="sd">            with this space&#39;s elements is not checked during init.</span>

<span class="sd">            ``float``: Weighting by a constant.</span>

<span class="sd">            array-like: Pointwise weighting by an array.</span>

<span class="sd">            This option cannot be combined with ``dist``,</span>
<span class="sd">            ``norm`` or ``inner``. It also cannot be used in case of</span>
<span class="sd">            non-numeric ``dtype``.</span>

<span class="sd">        dist : callable, optional</span>
<span class="sd">            Distance function defining a metric on the space.</span>
<span class="sd">            It must accept two `NumpyTensor` arguments and return</span>
<span class="sd">            a non-negative real number. See ``Notes`` for</span>
<span class="sd">            mathematical requirements.</span>

<span class="sd">            By default, ``dist(x, y)`` is calculated as ``norm(x - y)``.</span>

<span class="sd">            This option cannot be combined with ``weight``,</span>
<span class="sd">            ``norm`` or ``inner``. It also cannot be used in case of</span>
<span class="sd">            non-numeric ``dtype``.</span>

<span class="sd">        norm : callable, optional</span>
<span class="sd">            The norm implementation. It must accept a</span>
<span class="sd">            `NumpyTensor` argument, return a non-negative real number.</span>
<span class="sd">            See ``Notes`` for mathematical requirements.</span>

<span class="sd">            By default, ``norm(x)`` is calculated as ``inner(x, x)``.</span>

<span class="sd">            This option cannot be combined with ``weight``,</span>
<span class="sd">            ``dist`` or ``inner``. It also cannot be used in case of</span>
<span class="sd">            non-numeric ``dtype``.</span>

<span class="sd">        inner : callable, optional</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `NumpyTensor` arguments and return an element of the field</span>
<span class="sd">            of the space (usually real or complex number).</span>
<span class="sd">            See ``Notes`` for mathematical requirements.</span>

<span class="sd">            This option cannot be combined with ``weight``,</span>
<span class="sd">            ``dist`` or ``norm``. It also cannot be used in case of</span>
<span class="sd">            non-numeric ``dtype``.</span>

<span class="sd">        kwargs :</span>
<span class="sd">            Further keyword arguments are passed to the weighting</span>
<span class="sd">            classes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.space.space_utils.rn : constructor for real tensor spaces</span>
<span class="sd">        odl.space.space_utils.cn : constructor for complex tensor spaces</span>
<span class="sd">        odl.space.space_utils.tensor_space :</span>
<span class="sd">            constructor for tensor spaces of arbitrary scalar data type</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - A distance function or metric on a space :math:`\mathcal{X}`</span>
<span class="sd">          is a mapping</span>
<span class="sd">          :math:`d:\mathcal{X} \times \mathcal{X} \to \mathbb{R}`</span>
<span class="sd">          satisfying the following conditions for all space elements</span>
<span class="sd">          :math:`x, y, z`:</span>

<span class="sd">          * :math:`d(x, y) \geq 0`,</span>
<span class="sd">          * :math:`d(x, y) = 0 \Leftrightarrow x = y`,</span>
<span class="sd">          * :math:`d(x, y) = d(y, x)`,</span>
<span class="sd">          * :math:`d(x, y) \leq d(x, z) + d(z, y)`.</span>

<span class="sd">        - A norm on a space :math:`\mathcal{X}` is a mapping</span>
<span class="sd">          :math:`\| \cdot \|:\mathcal{X} \to \mathbb{R}`</span>
<span class="sd">          satisfying the following conditions for all</span>
<span class="sd">          space elements :math:`x, y`: and scalars :math:`s`:</span>

<span class="sd">          * :math:`\| x\| \geq 0`,</span>
<span class="sd">          * :math:`\| x\| = 0 \Leftrightarrow x = 0`,</span>
<span class="sd">          * :math:`\| sx\| = |s| \cdot \| x \|`,</span>
<span class="sd">          * :math:`\| x+y\| \leq \| x\| +</span>
<span class="sd">            \| y\|`.</span>

<span class="sd">        - An inner product on a space :math:`\mathcal{X}` over a field</span>
<span class="sd">          :math:`\mathbb{F} = \mathbb{R}` or :math:`\mathbb{C}` is a</span>
<span class="sd">          mapping</span>
<span class="sd">          :math:`\langle\cdot, \cdot\rangle: \mathcal{X} \times</span>
<span class="sd">          \mathcal{X} \to \mathbb{F}`</span>
<span class="sd">          satisfying the following conditions for all</span>
<span class="sd">          space elements :math:`x, y, z`: and scalars :math:`s`:</span>

<span class="sd">          * :math:`\langle x, y\rangle =</span>
<span class="sd">            \overline{\langle y, x\rangle}`,</span>
<span class="sd">          * :math:`\langle sx + y, z\rangle = s \langle x, z\rangle +</span>
<span class="sd">            \langle y, z\rangle`,</span>
<span class="sd">          * :math:`\langle x, x\rangle = 0 \Leftrightarrow x = 0`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Explicit initialization with the class constructor:</span>

<span class="sd">        &gt;&gt;&gt; space = NumpyTensorSpace(3, float)</span>
<span class="sd">        &gt;&gt;&gt; space</span>
<span class="sd">        rn(3)</span>
<span class="sd">        &gt;&gt;&gt; space.shape</span>
<span class="sd">        (3,)</span>
<span class="sd">        &gt;&gt;&gt; space.dtype</span>
<span class="sd">        dtype(&#39;float64&#39;)</span>

<span class="sd">        A more convenient way is to use factory functions:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3, weighting=[1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; space</span>
<span class="sd">        rn(3, weighting=[1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; space = odl.tensor_space((2, 3), dtype=int)</span>
<span class="sd">        &gt;&gt;&gt; space</span>
<span class="sd">        tensor_space((2, 3), dtype=int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_dtypes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`dtype` </span><span class="si">{!r}</span><span class="s1"> not supported&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">(</span><span class="n">dtype</span><span class="p">)))</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;weighting&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">exponent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="s1">&#39;exponent&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">weighting</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot use any of `weighting`, `dist`, `norm` &#39;</span>
                             <span class="s1">&#39;or `inner` for non-numeric `dtype` </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot use any of `dist`, `norm` or `inner` &#39;</span>
                             <span class="s1">&#39;for exponent != 2&#39;</span><span class="p">)</span>
        <span class="c1"># Check validity of option combination (0 or 1 may be provided)</span>
        <span class="n">num_extra_args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                             <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">inner</span><span class="p">,</span> <span class="n">weighting</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">num_extra_args</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid combination of options `weighting`, &#39;</span>
                             <span class="s1">&#39;`dist`, `norm` and `inner`&#39;</span><span class="p">)</span>

        <span class="c1"># Set the weighting</span>
        <span class="k">if</span> <span class="n">weighting</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">Weighting</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">weighting</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`weighting.impl` must be &#39;numpy&#39;, &quot;</span>
                                     <span class="s1">&#39;`got </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="o">.</span><span class="n">impl</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="n">exponent</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`weighting.exponent` conflicts with &#39;</span>
                                     <span class="s1">&#39;`exponent`: </span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">exponent</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">weighting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">_weighting</span><span class="p">(</span><span class="n">weighting</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>

            <span class="c1"># Check (afterwards) that the weighting input was sane</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">NumpyTensorSpaceArrayWeighting</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid `weighting` argument: </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">weighting</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;cannot cast from `weighting` data type </span><span class="si">{}</span><span class="s1"> to &#39;</span>
                        <span class="s1">&#39;the space `dtype` </span><span class="si">{}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                                  <span class="n">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;array-like weights must have same &#39;</span>
                                     <span class="s1">&#39;shape </span><span class="si">{}</span><span class="s1"> as this space, got </span><span class="si">{}</span><span class="s1">&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceCustomDist</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceCustomNorm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inner</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceCustomInner</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># No weighting, i.e., weighting with constant 1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>

        <span class="c1"># Make sure there are no leftover kwargs</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got unknown keyword arguments </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Name of the implementation back-end: ``&#39;numpy&#39;``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;numpy&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">default_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Default storage order for new elements in this space: ``&#39;C&#39;``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;C&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighting</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This space&#39;s weighting scheme.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighting</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the space is not weighted by constant 1.0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">)</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">const</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent of the norm and the distance.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span>

<div class="viewcode-block" id="NumpyTensorSpace.element"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.element.html#odl.space.npy_tensors.NumpyTensorSpace.element">[docs]</a>    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data_ptr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inp : `array-like`, optional</span>
<span class="sd">            Input used to initialize the new element.</span>

<span class="sd">            If ``inp`` is `None`, an empty element is created with no</span>
<span class="sd">            guarantee of its state (memory allocation only).</span>
<span class="sd">            The new element will use ``order`` as storage order if</span>
<span class="sd">            provided, otherwise `default_order`.</span>

<span class="sd">            Otherwise, a copy is avoided whenever possible. This requires</span>
<span class="sd">            correct `shape` and `dtype`, and if ``order`` is provided,</span>
<span class="sd">            also contiguousness in that ordering. If any of these</span>
<span class="sd">            conditions is not met, a copy is made.</span>

<span class="sd">        data_ptr : int, optional</span>
<span class="sd">            Pointer to the start memory address of a contiguous Numpy array</span>
<span class="sd">            or an equivalent raw container with the same total number of</span>
<span class="sd">            bytes. For this option, ``order`` must be either ``&#39;C&#39;`` or</span>
<span class="sd">            ``&#39;F&#39;``.</span>
<span class="sd">            The option is also mutually exclusive with ``inp``.</span>
<span class="sd">        order : {None, &#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">            Storage order of the returned element. For ``&#39;C&#39;`` and ``&#39;F&#39;``,</span>
<span class="sd">            contiguous memory in the respective ordering is enforced.</span>
<span class="sd">            The default ``None`` enforces no contiguousness.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element : `NumpyTensor`</span>
<span class="sd">            The new element, created from ``inp`` or from scratch.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Without arguments, an uninitialized element is created. With an</span>
<span class="sd">        array-like input, the element can be initialized:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; empty = space.element()</span>
<span class="sd">        &gt;&gt;&gt; empty.shape</span>
<span class="sd">        (3,)</span>
<span class="sd">        &gt;&gt;&gt; empty.space</span>
<span class="sd">        rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn(3).element([ 1.,  2.,  3.])</span>

<span class="sd">        If the input already is a `numpy.ndarray` of correct `dtype`, it</span>
<span class="sd">        will merely be wrapped, i.e., both array and space element access</span>
<span class="sd">        the same memory, such that mutations will affect both:</span>

<span class="sd">        &gt;&gt;&gt; arr = np.array([1, 2, 3], dtype=float)</span>
<span class="sd">        &gt;&gt;&gt; elem = odl.rn(3).element(arr)</span>
<span class="sd">        &gt;&gt;&gt; elem[0] = 0</span>
<span class="sd">        &gt;&gt;&gt; elem</span>
<span class="sd">        rn(3).element([ 0.,  2.,  3.])</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        array([ 0.,  2.,  3.])</span>

<span class="sd">        Elements can also be constructed from a data pointer, resulting</span>
<span class="sd">        again in shared memory:</span>

<span class="sd">        &gt;&gt;&gt; int_space = odl.tensor_space((2, 3), dtype=int)</span>
<span class="sd">        &gt;&gt;&gt; arr = np.array([[1, 2, 3],</span>
<span class="sd">        ...                 [4, 5, 6]], dtype=int, order=&#39;F&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ptr = arr.ctypes.data</span>
<span class="sd">        &gt;&gt;&gt; y = int_space.element(data_ptr=ptr, order=&#39;F&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        tensor_space((2, 3), dtype=int).element(</span>
<span class="sd">            [[1, 2, 3],</span>
<span class="sd">             [4, 5, 6]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; y[0, 1] = -1</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        array([[ 1, -1,  3],</span>
<span class="sd">               [ 4,  5,  6]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`order` </span><span class="si">{!r}</span><span class="s2"> not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data_ptr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                               <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_order</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data_ptr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`order` cannot be None for element &#39;</span>
                                 <span class="s1">&#39;creation from pointer&#39;</span><span class="p">)</span>

            <span class="n">ctype_array_def</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_byte</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="n">as_ctype_array</span> <span class="o">=</span> <span class="n">ctype_array_def</span><span class="o">.</span><span class="n">from_address</span><span class="p">(</span><span class="n">data_ptr</span><span class="p">)</span>
            <span class="n">as_numpy_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">as_ctype_array</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">as_numpy_array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">inp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data_ptr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inp</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Short-circuit for space elements and no enforced ordering</span>
                <span class="k">return</span> <span class="n">inp</span>

            <span class="c1"># Try to not copy but require dtype and order if given</span>
            <span class="c1"># (`order=None` is ok as np.array argument)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                           <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="c1"># Make sure the result is writeable, if not make copy.</span>
            <span class="c1"># This happens for e.g. results of `np.broadcast_to()`.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writeable</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape of `inp` not equal to space shape: &#39;</span>
                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot provide both `inp` and `data_ptr`&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace.zero"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.zero.html#odl.space.npy_tensors.NumpyTensorSpace.zero">[docs]</a>    <span class="k">def</span> <span class="nf">zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tensor of all zeros.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.zero()</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn(3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                     <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_order</span><span class="p">))</span></div>

<div class="viewcode-block" id="NumpyTensorSpace.one"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.one.html#odl.space.npy_tensors.NumpyTensorSpace.one">[docs]</a>    <span class="k">def</span> <span class="nf">one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a tensor of all ones.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.one()</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn(3).element([ 1.,  1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                    <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">default_order</span><span class="p">))</span></div>

<div class="viewcode-block" id="NumpyTensorSpace.available_dtypes"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.available_dtypes.html#odl.space.npy_tensors.NumpyTensorSpace.available_dtypes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">available_dtypes</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Return the set of data types available in this implementation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is all dtypes available in Numpy. See ``numpy.sctypes``</span>
<span class="sd">        for more information.</span>

<span class="sd">        The available dtypes may depend on the specific system used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_dtypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">sctypes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                    <span class="n">all_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="c1"># Need to add these manually since np.sctypes[&#39;others&#39;] will only</span>
        <span class="c1"># contain one of them (depending on Python version)</span>
        <span class="n">all_dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)])</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_dtypes</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NumpyTensorSpace.default_dtype"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.default_dtype.html#odl.space.npy_tensors.NumpyTensorSpace.default_dtype">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_dtype</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the default data type of this class for a given field.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : `Field`, optional</span>
<span class="sd">            Set of numbers to be represented by a data type.</span>
<span class="sd">            Currently supported : `RealNumbers`, `ComplexNumbers`</span>
<span class="sd">            The default ``None`` means `RealNumbers`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dtype : `numpy.dtype`</span>
<span class="sd">            Numpy data type specifier. The returned defaults are:</span>

<span class="sd">                ``RealNumbers()`` : ``np.dtype(&#39;float64&#39;)``</span>

<span class="sd">                ``ComplexNumbers()`` : ``np.dtype(&#39;complex128&#39;)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;complex128&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no default data type defined for field </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="p">))</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._lincomb"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._lincomb.html#odl.space.npy_tensors.NumpyTensorSpace._lincomb">[docs]</a>    <span class="k">def</span> <span class="nf">_lincomb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement the linear combination of ``x1`` and ``x2``.</span>

<span class="sd">        Compute ``out = a*x1 + b*x2`` using optimized</span>
<span class="sd">        BLAS routines if possible.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a, b : `TensorSpace.field` element</span>
<span class="sd">            Scalars to multiply ``x1`` and ``x2`` with.</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Summands in the linear combination.</span>
<span class="sd">        out : `NumpyTensor`</span>
<span class="sd">            Tensor to which the result is written.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; out = space.element()</span>
<span class="sd">        &gt;&gt;&gt; result = space.lincomb(1, x, 2, y, out)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        rn(3).element([ 0.,  1.,  3.])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_lincomb_impl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._dist"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._dist.html#odl.space.npy_tensors.NumpyTensorSpace._dist">[docs]</a>    <span class="k">def</span> <span class="nf">_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the distance between ``x1`` and ``x2``.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Elements whose mutual distance is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : `float`</span>
<span class="sd">            Distance between the elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Different exponents result in difference metrics:</span>

<span class="sd">        &gt;&gt;&gt; space_2 = odl.rn(3, exponent=2)</span>
<span class="sd">        &gt;&gt;&gt; x = space_2.element([-1, -1, 2])</span>
<span class="sd">        &gt;&gt;&gt; y = space_2.one()</span>
<span class="sd">        &gt;&gt;&gt; space_2.dist(x, y)</span>
<span class="sd">        3.0</span>

<span class="sd">        &gt;&gt;&gt; space_1 = odl.rn(3, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; x = space_1.element([-1, -1, 2])</span>
<span class="sd">        &gt;&gt;&gt; y = space_1.one()</span>
<span class="sd">        &gt;&gt;&gt; space_1.dist(x, y)</span>
<span class="sd">        5.0</span>

<span class="sd">        Weighting is supported, too:</span>

<span class="sd">        &gt;&gt;&gt; space_1_w = odl.rn(3, exponent=1, weighting=[2, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x = space_1_w.element([-1, -1, 2])</span>
<span class="sd">        &gt;&gt;&gt; y = space_1_w.one()</span>
<span class="sd">        &gt;&gt;&gt; space_1_w.dist(x, y)</span>
<span class="sd">        7.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._norm"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._norm.html#odl.space.npy_tensors.NumpyTensorSpace._norm">[docs]</a>    <span class="k">def</span> <span class="nf">_norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the norm of ``x``.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `NumpyTensor`</span>
<span class="sd">            Element whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : `float`</span>
<span class="sd">            Norm of the element.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Different exponents result in difference norms:</span>

<span class="sd">        &gt;&gt;&gt; space_2 = odl.rn(3, exponent=2)</span>
<span class="sd">        &gt;&gt;&gt; x = space_2.element([3, 0, 4])</span>
<span class="sd">        &gt;&gt;&gt; space_2.norm(x)</span>
<span class="sd">        5.0</span>
<span class="sd">        &gt;&gt;&gt; space_1 = odl.rn(3, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; x = space_1.element([3, 0, 4])</span>
<span class="sd">        &gt;&gt;&gt; space_1.norm(x)</span>
<span class="sd">        7.0</span>

<span class="sd">        Weighting is supported, too:</span>

<span class="sd">        &gt;&gt;&gt; space_1_w = odl.rn(3, exponent=1, weighting=[2, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x = space_1_w.element([3, 0, 4])</span>
<span class="sd">        &gt;&gt;&gt; space_1_w.norm(x)</span>
<span class="sd">        10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._inner"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._inner.html#odl.space.npy_tensors.NumpyTensorSpace._inner">[docs]</a>    <span class="k">def</span> <span class="nf">_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the inner product of ``x1`` and ``x2``.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Elements whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : `field` `element`</span>
<span class="sd">            Inner product of the elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 0, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space.one()</span>
<span class="sd">        &gt;&gt;&gt; space.inner(x, y)</span>
<span class="sd">        4.0</span>

<span class="sd">        Weighting is supported, too:</span>

<span class="sd">        &gt;&gt;&gt; space_w = odl.rn(3, weighting=[2, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x = space_w.element([1, 0, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space_w.one()</span>
<span class="sd">        &gt;&gt;&gt; space_w.inner(x, y)</span>
<span class="sd">        5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._multiply"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._multiply.html#odl.space.npy_tensors.NumpyTensorSpace._multiply">[docs]</a>    <span class="k">def</span> <span class="nf">_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the entry-wise product ``out = x1 * x2``.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Factors in the product.</span>
<span class="sd">        out : `NumpyTensor`</span>
<span class="sd">            Element to which the result is written.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 0, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([-1, 1, -1])</span>
<span class="sd">        &gt;&gt;&gt; space.multiply(x, y)</span>
<span class="sd">        rn(3).element([-1.,  0., -3.])</span>
<span class="sd">        &gt;&gt;&gt; out = space.element()</span>
<span class="sd">        &gt;&gt;&gt; result = space.multiply(x, y, out=out)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        rn(3).element([-1.,  0., -3.])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace._divide"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace._divide.html#odl.space.npy_tensors.NumpyTensorSpace._divide">[docs]</a>    <span class="k">def</span> <span class="nf">_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the entry-wise quotient ``x1 / x2``.</span>

<span class="sd">        This function is part of the subclassing API. Do not</span>
<span class="sd">        call it directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Dividend and divisor in the quotient.</span>
<span class="sd">        out : `NumpyTensor`</span>
<span class="sd">            Element to which the result is written.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([2, 0, 4])</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([1, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; space.divide(x, y)</span>
<span class="sd">        rn(3).element([ 2.,  0.,  2.])</span>
<span class="sd">        &gt;&gt;&gt; out = space.element()</span>
<span class="sd">        &gt;&gt;&gt; result = space.divide(x, y, out=out)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        rn(3).element([ 2.,  0.,  2.])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpace.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpace.__eq__.html#odl.space.npy_tensors.NumpyTensorSpace.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            True if ``other`` is an instance of ``type(self)``</span>
<span class="sd">            with the same `NumpyTensorSpace.shape`, `NumpyTensorSpace.dtype`</span>
<span class="sd">            and `NumpyTensorSpace.weighting`, otherwise False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; same_space = odl.rn(3, exponent=2)</span>
<span class="sd">        &gt;&gt;&gt; same_space == space</span>
<span class="sd">        True</span>

<span class="sd">        Different `shape`, `exponent` or `dtype` all result in different</span>
<span class="sd">        spaces:</span>

<span class="sd">        &gt;&gt;&gt; diff_space = odl.rn((3, 4))</span>
<span class="sd">        &gt;&gt;&gt; diff_space == space</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; diff_space = odl.rn(3, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; diff_space == space</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; diff_space = odl.rn(3, dtype=&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; diff_space == space</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; space == object</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">weighting</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``hash(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpace</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(),</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">byaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the subspace defined along one or several dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Indexing with integers or slices:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn((2, 3, 4))</span>
<span class="sd">        &gt;&gt;&gt; space.byaxis[0]</span>
<span class="sd">        rn(2)</span>
<span class="sd">        &gt;&gt;&gt; space.byaxis[1:]</span>
<span class="sd">        rn((3, 4))</span>

<span class="sd">        Lists can be used to stack spaces arbitrarily:</span>

<span class="sd">        &gt;&gt;&gt; space.byaxis[[2, 1, 2]]</span>
<span class="sd">        rn((4, 3, 4))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">space</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">NpyTensorSpacebyaxis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;Helper class for indexing by axis.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.&quot;&quot;&quot;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="nb">iter</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">newshape</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="p">,</span> <span class="n">ArrayWeighting</span><span class="p">):</span>
                    <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
                    <span class="n">weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceArrayWeighting</span><span class="p">(</span>
                        <span class="n">new_array</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">weighting</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">weighting</span>

                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">space</span><span class="p">)(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">space</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.byaxis&#39;</span>

        <span class="k">return</span> <span class="n">NpyTensorSpacebyaxis</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="n">ctor_name</span> <span class="o">=</span> <span class="s1">&#39;rn&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="n">ctor_name</span> <span class="o">=</span> <span class="s1">&#39;cn&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ctor_name</span> <span class="o">=</span> <span class="s1">&#39;tensor_space&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ctor_name</span> <span class="o">==</span> <span class="s1">&#39;tensor_space&#39;</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">)):</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">dtype_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">optmod</span> <span class="o">=</span> <span class="s1">&#39;!s&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optmod</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">optargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">optmod</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">inner_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">optmod</span><span class="p">])</span>
        <span class="n">weight_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighting</span><span class="o">.</span><span class="n">repr_part</span>
        <span class="k">if</span> <span class="n">weight_str</span><span class="p">:</span>
            <span class="n">inner_str</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">weight_str</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ctor_name</span><span class="p">,</span> <span class="n">inner_str</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">element_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Type of elements in this space: `NumpyTensor`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NumpyTensor</span></div>


<div class="viewcode-block" id="NumpyTensor"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.html#odl.space.npy_tensors.NumpyTensor">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensor</span><span class="p">(</span><span class="n">Tensor</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Representation of a `NumpyTensorSpace` element.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensor.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.html#odl.space.npy_tensors.NumpyTensor.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
        <span class="n">Tensor</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__data</span> <span class="o">=</span> <span class="n">data</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The `numpy.ndarray` representing the data of ``self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__data</span>

<div class="viewcode-block" id="NumpyTensor.asarray"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.asarray.html#odl.space.npy_tensors.NumpyTensor.asarray">[docs]</a>    <span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the data of this array as a ``numpy.ndarray``.</span>

<span class="sd">        This method is invoked when calling `numpy.asarray` on this</span>
<span class="sd">        tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `numpy.ndarray`, optional</span>
<span class="sd">            Array in which the result should be written in-place.</span>
<span class="sd">            Has to be contiguous and of the correct dtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        asarray : `numpy.ndarray`</span>
<span class="sd">            Numpy array with the same data type as ``self``. If</span>
<span class="sd">            ``out`` was given, the returned object is a reference</span>
<span class="sd">            to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3, dtype=&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.asarray()</span>
<span class="sd">        array([ 1.,  2.,  3.], dtype=float32)</span>
<span class="sd">        &gt;&gt;&gt; np.asarray(x) is x.asarray()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; out = np.empty(3, dtype=&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; result = x.asarray(out=out)</span>
<span class="sd">        &gt;&gt;&gt; out</span>
<span class="sd">        array([ 1.,  2.,  3.], dtype=float32)</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; space.one().asarray()</span>
<span class="sd">        array([[ 1.,  1.,  1.],</span>
<span class="sd">               [ 1.,  1.,  1.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="NumpyTensor.astype"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.astype.html#odl.space.npy_tensors.NumpyTensor.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this element with new ``dtype``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype :</span>
<span class="sd">            Scalar data type of the returned space. Can be provided</span>
<span class="sd">            in any way the `numpy.dtype` constructor understands, e.g.</span>
<span class="sd">            as built-in type or as a string. Data types with non-trivial</span>
<span class="sd">            shapes are not allowed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        newelem : `NumpyTensor`</span>
<span class="sd">            Version of this element with given data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_ptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A raw pointer to the data container of ``self``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import ctypes</span>
<span class="sd">        &gt;&gt;&gt; space = odl.tensor_space(3, dtype=&#39;uint16&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; arr_type = ctypes.c_uint16 * 3  # C type &quot;array of 3 uint16&quot;</span>
<span class="sd">        &gt;&gt;&gt; buffer = arr_type.from_address(x.data_ptr)</span>
<span class="sd">        &gt;&gt;&gt; arr = np.frombuffer(buffer, dtype=&#39;uint16&#39;)</span>
<span class="sd">        &gt;&gt;&gt; arr</span>
<span class="sd">        array([1, 2, 3], dtype=uint16)</span>

<span class="sd">        In-place modification via pointer:</span>

<span class="sd">        &gt;&gt;&gt; arr[0] = 42</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        tensor_space(3, dtype=&#39;uint16&#39;).element([42,  2,  3])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span>

<div class="viewcode-block" id="NumpyTensor.__eq__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.__eq__.html#odl.space.npy_tensors.NumpyTensor.__eq__">[docs]</a>    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self == other``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        equals : bool</span>
<span class="sd">            True if all entries of ``other`` are equal to this</span>
<span class="sd">            the entries of ``self``, False otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x == y</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; y = space.element([-1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x == y</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x == object</span>
<span class="sd">        False</span>

<span class="sd">        Space membership matters:</span>

<span class="sd">        &gt;&gt;&gt; space2 = odl.tensor_space(3, dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = space2.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x == y or y == x</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensor.copy"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.copy.html#odl.space.npy_tensors.NumpyTensor.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an identical (deep) copy of this tensor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        copy : `NumpyTensor`</span>
<span class="sd">            The deep copy</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = x.copy()</span>
<span class="sd">        &gt;&gt;&gt; y == x</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y is x</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``copy(self)``.</span>

<span class="sd">        This implements the (shallow) copy interface of the ``copy``</span>
<span class="sd">        module of the Python standard library.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        copy</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from copy import copy</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = copy(x)</span>
<span class="sd">        &gt;&gt;&gt; y == x</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y is x</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="NumpyTensor.__getitem__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.__getitem__.html#odl.space.npy_tensors.NumpyTensor.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[indices]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : index expression</span>
<span class="sd">            Integer, slice or sequence of these, defining the positions</span>
<span class="sd">            of the data array which should be accessed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : `NumpyTensorSpace.dtype` or `NumpyTensor`</span>
<span class="sd">            The value(s) at the given indices. Note that the returned</span>
<span class="sd">            object is a writable view into the original tensor, except</span>
<span class="sd">            for the case when ``indices`` is a list.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For one-dimensional spaces, indexing is as in linear arrays:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x[0]</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; x[1:]</span>
<span class="sd">        rn(2).element([ 2.,  3.])</span>

<span class="sd">        In higher dimensions, the i-th index expression accesses the</span>
<span class="sd">        i-th axis:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([[1, 2, 3],</span>
<span class="sd">        ...                    [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; x[0, 1]</span>
<span class="sd">        2.0</span>
<span class="sd">        &gt;&gt;&gt; x[:, 1:]</span>
<span class="sd">        rn((2, 2)).element(</span>
<span class="sd">            [[ 2.,  3.],</span>
<span class="sd">             [ 5.,  6.]]</span>
<span class="sd">        )</span>

<span class="sd">        Slices can be assigned to, except if lists are used for indexing:</span>

<span class="sd">        &gt;&gt;&gt; y = x[:, ::2]  # view into x</span>
<span class="sd">        &gt;&gt;&gt; y[:] = -9</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[-9.,  2., -9.],</span>
<span class="sd">             [-9.,  5., -9.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; y = x[[0, 1], [1, 2]]  # not a view, won&#39;t modify x</span>
<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        rn(2).element([ 2., -9.])</span>
<span class="sd">        &gt;&gt;&gt; y[:] = 0</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[-9.,  2., -9.],</span>
<span class="sd">             [-9.,  5., -9.]]</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy implementation: index the array and deal with it</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">NumpyTensor</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">data</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weighting</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span>
                <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                <span class="n">weighting</span><span class="o">=</span><span class="n">weighting</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensor.__setitem__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.__setitem__.html#odl.space.npy_tensors.NumpyTensor.__setitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self[indices] = values``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : index expression</span>
<span class="sd">            Integer, slice or sequence of these, defining the positions</span>
<span class="sd">            of the data array which should be written to.</span>
<span class="sd">        values : scalar, array-like or `NumpyTensor`</span>
<span class="sd">            The value(s) that are to be assigned.</span>

<span class="sd">            If ``index`` is an integer, ``value`` must be a scalar.</span>

<span class="sd">            If ``index`` is a slice or a sequence of slices, ``value``</span>
<span class="sd">            must be broadcastable to the shape of the slice.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For 1d spaces, entries can be set with scalars or sequences of</span>
<span class="sd">        correct shape:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x[0] = -1</span>
<span class="sd">        &gt;&gt;&gt; x[1:] = (0, 1)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn(3).element([-1.,  0.,  1.])</span>

<span class="sd">        It is also possible to use tensors of other spaces for</span>
<span class="sd">        casting and assignment:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([[1, 2, 3],</span>
<span class="sd">        ...                    [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; x[0, 1] = -1</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 1., -1.,  3.],</span>
<span class="sd">             [ 4.,  5.,  6.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; short_space = odl.tensor_space((2, 2), dtype=&#39;short&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = short_space.element([[-1, 2],</span>
<span class="sd">        ...                          [0, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x[:, :2] = y</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[-1.,  2.,  3.],</span>
<span class="sd">             [ 0.,  0.,  6.]]</span>
<span class="sd">        )</span>

<span class="sd">        The Numpy assignment and broadcasting rules apply:</span>

<span class="sd">        &gt;&gt;&gt; x[:] = np.array([[0, 0, 0],</span>
<span class="sd">        ...                  [1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 0.,  0.,  0.],</span>
<span class="sd">             [ 1.,  1.,  1.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; x[:, 1:] = [7, 8]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 0.,  7.,  8.],</span>
<span class="sd">             [ 1.,  7.,  8.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; x[:, ::2] = -2.</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[-2.,  7., -2.],</span>
<span class="sd">             [-2.,  7., -2.]]</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Real part of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        real : `NumpyTensor`</span>
<span class="sd">            Real part of this element as a member of a</span>
<span class="sd">            `NumpyTensorSpace` with corresponding real data type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get the real part:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.cn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        rn(3).element([ 1.,  2.,  3.])</span>

<span class="sd">        Set the real part:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.cn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; zero = odl.rn(3).zero()</span>
<span class="sd">        &gt;&gt;&gt; x.real = zero</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 0.+1.j,  0.+0.j,  0.-3.j])</span>

<span class="sd">        Other array-like types and broadcasting:</span>

<span class="sd">        &gt;&gt;&gt; x.real = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 1.+1.j,  1.+0.j,  1.-3.j])</span>
<span class="sd">        &gt;&gt;&gt; x.real = [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 2.+1.j,  3.+0.j,  4.-3.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="n">real_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`real` not defined for non-numeric &#39;</span>
                                      <span class="s1">&#39;dtype </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newreal</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for the real part.</span>

<span class="sd">        This method is invoked by ``x.real = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newreal : array-like or scalar</span>
<span class="sd">            Values to be assigned to the real part of this element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">newreal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Imaginary part of ``self``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        imag : `NumpyTensor`</span>
<span class="sd">            Imaginary part this element as an element of a</span>
<span class="sd">            `NumpyTensorSpace` with real data type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get the imaginary part:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.cn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        rn(3).element([ 1.,  0., -3.])</span>

<span class="sd">        Set the imaginary part:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.cn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; zero = odl.rn(3).zero()</span>
<span class="sd">        &gt;&gt;&gt; x.imag = zero</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 1.+0.j,  2.+0.j,  3.+0.j])</span>

<span class="sd">        Other array-like types and broadcasting:</span>

<span class="sd">        &gt;&gt;&gt; x.imag = 1.0</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 1.+1.j,  2.+1.j,  3.+1.j])</span>
<span class="sd">        &gt;&gt;&gt; x.imag = [2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 1.+2.j,  2.+3.j,  3.+4.j])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_complex</span><span class="p">:</span>
            <span class="n">real_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">real_dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">real_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`imag` not defined for non-numeric &#39;</span>
                                      <span class="s1">&#39;dtype </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newimag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Setter for the imaginary part.</span>

<span class="sd">        This method is invoked by ``x.imag = other``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newimag : array-like or scalar</span>
<span class="sd">            Values to be assigned to the imaginary part of this element.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the space is real, i.e., no imagninary part can be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot set imaginary part in real spaces&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">newimag</span>

<div class="viewcode-block" id="NumpyTensor.conj"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensor.conj.html#odl.space.npy_tensors.NumpyTensor.conj">[docs]</a>    <span class="k">def</span> <span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the complex conjugate of ``self``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : `NumpyTensor`, optional</span>
<span class="sd">            Element to which the complex conjugate is written.</span>
<span class="sd">            Must be an element of ``self.space``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `NumpyTensor`</span>
<span class="sd">            The complex conjugate element. If ``out`` was provided,</span>
<span class="sd">            the returned object is a reference to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.cn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = space.element([1 + 1j, 2, 3 - 3j])</span>
<span class="sd">        &gt;&gt;&gt; x.conj()</span>
<span class="sd">        cn(3).element([ 1.-1.j,  2.-0.j,  3.+3.j])</span>
<span class="sd">        &gt;&gt;&gt; out = space.element()</span>
<span class="sd">        &gt;&gt;&gt; result = x.conj(out=out)</span>
<span class="sd">        &gt;&gt;&gt; result</span>
<span class="sd">        cn(3).element([ 1.-1.j,  2.-0.j,  3.+3.j])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>

<span class="sd">        In-place conjugation:</span>

<span class="sd">        &gt;&gt;&gt; result = x.conj(out=x)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        cn(3).element([ 1.-1.j,  2.-0.j,  3.+3.j])</span>
<span class="sd">        &gt;&gt;&gt; result is x</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">return</span> <span class="n">out</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`conj` not defined for non-numeric &#39;</span>
                                      <span class="s1">&#39;dtype </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">LinearSpaceTypeError</span><span class="p">(</span><span class="s1">&#39;`out` </span><span class="si">{!r}</span><span class="s1"> not in space </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                           <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self **= other``.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__ipow__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``int(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__long__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``long(self)``.</span>

<span class="sd">        This method is only useful in Python 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">long</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``float(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``complex(self)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;only size-1 tensors can be converted to &#39;</span>
                            <span class="s1">&#39;Python scalars&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Interface to Numpy&#39;s ufunc machinery.</span>

<span class="sd">        This method is called by Numpy version 1.13 and higher as a single</span>
<span class="sd">        point for the ufunc dispatch logic. An object implementing</span>
<span class="sd">        ``__array_ufunc__`` takes over control when a `numpy.ufunc` is</span>
<span class="sd">        called on it, allowing it to use custom implementations and</span>
<span class="sd">        output types.</span>

<span class="sd">        This includes handling of in-place arithmetic like</span>
<span class="sd">        ``npy_array += custom_obj``. In this case, the custom object&#39;s</span>
<span class="sd">        ``__array_ufunc__`` takes precedence over the baseline</span>
<span class="sd">        `numpy.ndarray` implementation. It will be called with</span>
<span class="sd">        ``npy_array`` as ``out`` argument, which ensures that the</span>
<span class="sd">        returned object is a Numpy array. For this to work properly,</span>
<span class="sd">        ``__array_ufunc__`` has to accept Numpy arrays as ``out`` arguments.</span>

<span class="sd">        See the `corresponding NEP`_ and the `interface documentation`_</span>
<span class="sd">        for further details. See also the `general documentation on</span>
<span class="sd">        Numpy ufuncs`_.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This basic implementation casts inputs and</span>
<span class="sd">            outputs to Numpy arrays and evaluates ``ufunc`` on those.</span>
<span class="sd">            For `numpy.ndarray` based data storage, this incurs no</span>
<span class="sd">            significant overhead compared to direct usage of Numpy arrays.</span>

<span class="sd">            For other (in particular non-local) implementations, e.g.,</span>
<span class="sd">            GPU arrays or distributed memory, overhead is significant due</span>
<span class="sd">            to copies to CPU main memory. In those classes, the</span>
<span class="sd">            ``__array_ufunc__`` mechanism should be overridden to use</span>
<span class="sd">            native implementations if possible.</span>

<span class="sd">        .. note::</span>
<span class="sd">            When using operations that alter the shape (like ``reduce``),</span>
<span class="sd">            or the data type (can be any of the methods),</span>
<span class="sd">            the resulting array is wrapped in a space of the same</span>
<span class="sd">            type as ``self.space``, propagating space properties like</span>
<span class="sd">            `exponent` or `weighting` as closely as possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ufunc : `numpy.ufunc`</span>
<span class="sd">            Ufunc that should be called on ``self``.</span>
<span class="sd">        method : str</span>
<span class="sd">            Method on ``ufunc`` that should be called on ``self``.</span>
<span class="sd">            Possible values:</span>

<span class="sd">            ``&#39;__call__&#39;``, ``&#39;accumulate&#39;``, ``&#39;at&#39;``, ``&#39;outer&#39;``,</span>
<span class="sd">            ``&#39;reduce&#39;``, ``&#39;reduceat&#39;``</span>

<span class="sd">        input1, ..., inputN :</span>
<span class="sd">            Positional arguments to ``ufunc.method``.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Keyword arguments to ``ufunc.method``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ufunc_result : `Tensor`, `numpy.ndarray` or tuple</span>
<span class="sd">            Result of the ufunc evaluation. If no ``out`` keyword argument</span>
<span class="sd">            was given, the result is a `Tensor` or a tuple</span>
<span class="sd">            of such, depending on the number of outputs of ``ufunc``.</span>
<span class="sd">            If ``out`` was provided, the returned object or tuple entries</span>
<span class="sd">            refer(s) to ``out``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        We apply `numpy.add` to ODL tensors:</span>

<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = r3.element([-1, -2, -3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y)</span>
<span class="sd">        rn(3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; np.add(x, y)  # same mechanism for Numpy &gt;= 1.13</span>
<span class="sd">        rn(3).element([ 0.,  0.,  0.])</span>

<span class="sd">        As ``out``, a Numpy array or an ODL tensor can be given (wrapped</span>
<span class="sd">        in a sequence):</span>

<span class="sd">        &gt;&gt;&gt; out = r3.element()</span>
<span class="sd">        &gt;&gt;&gt; res = x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y, out=(out,))</span>
<span class="sd">        &gt;&gt;&gt; out</span>
<span class="sd">        rn(3).element([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; res is out</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; out_arr = np.empty(3)</span>
<span class="sd">        &gt;&gt;&gt; res = x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y, out=(out_arr,))</span>
<span class="sd">        &gt;&gt;&gt; out_arr</span>
<span class="sd">        array([ 0.,  0.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; res is out_arr</span>
<span class="sd">        True</span>

<span class="sd">        With multiple dimensions:</span>

<span class="sd">        &gt;&gt;&gt; r23 = odl.rn((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; x = y = r23.one()</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;__call__&#39;, x, y)</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 2.,  2.,  2.],</span>
<span class="sd">             [ 2.,  2.,  2.]]</span>
<span class="sd">        )</span>

<span class="sd">        The ``ufunc.accumulate`` method retains the original `shape` and</span>
<span class="sd">        `dtype`. The latter can be changed with the ``dtype`` parameter:</span>

<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;accumulate&#39;, x)</span>
<span class="sd">        rn(3).element([ 1.,  3.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; np.add.accumulate(x)  # same mechanism for Numpy &gt;= 1.13</span>
<span class="sd">        rn(3).element([ 1.,  3.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;accumulate&#39;, x, dtype=complex)</span>
<span class="sd">        cn(3).element([ 1.+0.j,  3.+0.j,  6.+0.j])</span>

<span class="sd">        For multi-dimensional tensors, an optional ``axis`` parameter</span>
<span class="sd">        can be provided:</span>

<span class="sd">        &gt;&gt;&gt; z = r23.one()</span>
<span class="sd">        &gt;&gt;&gt; z.__array_ufunc__(np.add, &#39;accumulate&#39;, z, axis=1)</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 1.,  2.,  3.],</span>
<span class="sd">             [ 1.,  2.,  3.]]</span>
<span class="sd">        )</span>

<span class="sd">        The ``ufunc.at`` method operates in-place. Here we add the second</span>
<span class="sd">        operand ``[5, 10]`` to ``x`` at indices ``[0, 2]``:</span>

<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;at&#39;, x, [0, 2], [5, 10])</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        rn(3).element([  6.,   2.,  13.])</span>

<span class="sd">        For outer-product-type operations, i.e., operations where the result</span>
<span class="sd">        shape is the sum of the individual shapes, the ``ufunc.outer``</span>
<span class="sd">        method can be used:</span>

<span class="sd">        &gt;&gt;&gt; x = odl.rn(2).element([0, 3])</span>
<span class="sd">        &gt;&gt;&gt; y = odl.rn(3).element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;outer&#39;, x, y)</span>
<span class="sd">        rn((2, 3)).element(</span>
<span class="sd">            [[ 1.,  2.,  3.],</span>
<span class="sd">             [ 4.,  5.,  6.]]</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; y.__array_ufunc__(np.add, &#39;outer&#39;, y, x)</span>
<span class="sd">        rn((3, 2)).element(</span>
<span class="sd">            [[ 1.,  4.],</span>
<span class="sd">             [ 2.,  5.],</span>
<span class="sd">             [ 3.,  6.]]</span>
<span class="sd">        )</span>

<span class="sd">        Using ``ufunc.reduce`` produces a scalar, which can be avoided with</span>
<span class="sd">        ``keepdims=True``:</span>

<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;reduce&#39;, x)</span>
<span class="sd">        6.0</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;reduce&#39;, x, keepdims=True)</span>
<span class="sd">        rn(1).element([ 6.])</span>

<span class="sd">        In multiple dimensions, ``axis`` can be provided for reduction over</span>
<span class="sd">        selected axes:</span>

<span class="sd">        &gt;&gt;&gt; z = r23.element([[1, 2, 3],</span>
<span class="sd">        ...                  [4, 5, 6]])</span>
<span class="sd">        &gt;&gt;&gt; z.__array_ufunc__(np.add, &#39;reduce&#39;, z, axis=1)</span>
<span class="sd">        rn(2).element([  6.,  15.])</span>

<span class="sd">        Finally, ``add.reduceat`` is a combination of ``reduce`` and</span>
<span class="sd">        ``at`` with rather flexible and complex semantics (see the</span>
<span class="sd">        `reduceat documentation`_ for details):</span>

<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.__array_ufunc__(np.add, &#39;reduceat&#39;, x, [0, 1])</span>
<span class="sd">        rn(2).element([ 1.,  5.])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. _corresponding NEP:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/neps/ufunc-overrides.html</span>

<span class="sd">        .. _interface documentation:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/arrays.classes.html\</span>
<span class="sd">#numpy.class.__array_ufunc__</span>

<span class="sd">        .. _general documentation on Numpy ufuncs:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/ufuncs.html</span>

<span class="sd">        .. _reduceat documentation:</span>
<span class="sd">           https://docs.scipy.org/doc/numpy/reference/generated/\</span>
<span class="sd">numpy.ufunc.reduceat.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remark: this method differs from the parent implementation only</span>
        <span class="c1"># in the propagation of additional space properties.</span>

        <span class="c1"># --- Process `out` --- #</span>

        <span class="c1"># Unwrap out if provided. The output parameters are all wrapped</span>
        <span class="c1"># in one tuple, even if there is only one.</span>
        <span class="n">out_tuple</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="p">())</span>

        <span class="c1"># Check number of `out` args, depending on `method`</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;ufunc </span><span class="si">{}</span><span class="s2">: need 0 or </span><span class="si">{}</span><span class="s2"> `out` arguments for &quot;</span>
                <span class="s2">&quot;`method=&#39;__call__&#39;`, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;__call__&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;ufunc </span><span class="si">{}</span><span class="s1">: need 0 or 1 `out` arguments for `method=</span><span class="si">{!r}</span><span class="s1">`, &#39;</span>
                <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)))</span>

        <span class="c1"># We allow our own tensors, the data container type and</span>
        <span class="c1"># `numpy.ndarray` objects as `out` (see docs for reason for the</span>
        <span class="c1"># latter)</span>
        <span class="n">valid_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">valid_types</span><span class="p">)</span> <span class="ow">or</span> <span class="n">o</span> <span class="ow">is</span> <span class="kc">None</span>
                   <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="c1"># Assign to `out` or `out1` and `out2`, respectively</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out1</span> <span class="o">=</span> <span class="n">out2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">out1</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out2</span> <span class="o">=</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># --- Process `inputs` --- #</span>

        <span class="c1"># Convert inputs that are ODL tensors to Numpy arrays so that the</span>
        <span class="c1"># native Numpy ufunc is called later</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">else</span> <span class="n">inp</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># --- Get some parameters for later --- #</span>

        <span class="c1"># Arguments for `writable_array` and/or space constructors</span>
        <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">array_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">out_dtype</span><span class="p">}</span>

        <span class="n">exponent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">exponent</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">weighting</span>

        <span class="c1"># --- Evaluate ufunc --- #</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;__call__&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Make context for output (trivial one returns `None`)</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out_ctx</span> <span class="o">=</span> <span class="n">nullcontext</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out_ctx</span> <span class="o">=</span> <span class="n">writable_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">array_kwargs</span><span class="p">)</span>

                <span class="c1"># Evaluate ufunc</span>
                <span class="k">with</span> <span class="n">out_ctx</span> <span class="k">as</span> <span class="n">out_arr</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_arr</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># Wrap result if necessary (lazily)</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_floating_dtype</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="c1"># Weighting contains exponent</span>
                        <span class="n">spc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weighting&#39;</span><span class="p">:</span> <span class="n">weighting</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># No `exponent` or `weighting` applicable</span>
                        <span class="n">spc_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">out_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">spc_kwargs</span><span class="p">)</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">out_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">out</span>

            <span class="k">elif</span> <span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># Make contexts for outputs (trivial ones return `None`)</span>
                <span class="k">if</span> <span class="n">out1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out1_ctx</span> <span class="o">=</span> <span class="n">writable_array</span><span class="p">(</span><span class="n">out1</span><span class="p">,</span> <span class="o">**</span><span class="n">array_kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out1_ctx</span> <span class="o">=</span> <span class="n">nullcontext</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">out2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out2_ctx</span> <span class="o">=</span> <span class="n">writable_array</span><span class="p">(</span><span class="n">out2</span><span class="p">,</span> <span class="o">**</span><span class="n">array_kwargs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out2_ctx</span> <span class="o">=</span> <span class="n">nullcontext</span><span class="p">()</span>

                <span class="c1"># Evaluate ufunc</span>
                <span class="k">with</span> <span class="n">out1_ctx</span> <span class="k">as</span> <span class="n">out1_arr</span><span class="p">,</span> <span class="n">out2_ctx</span> <span class="k">as</span> <span class="n">out2_arr</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out1_arr</span><span class="p">,</span> <span class="n">out2_arr</span><span class="p">)</span>
                    <span class="n">res1</span><span class="p">,</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># Wrap results if necessary (lazily)</span>
                <span class="c1"># We don&#39;t use exponents or weightings since we don&#39;t know</span>
                <span class="c1"># how to map them to the spaces</span>
                <span class="k">if</span> <span class="n">out1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out1_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">res1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">out1</span> <span class="o">=</span> <span class="n">out1_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">out2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">out2_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">res2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">out2</span> <span class="o">=</span> <span class="n">out2_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res2</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;nout = </span><span class="si">{}</span><span class="s1"> not supported&#39;</span>
                                          <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ufunc</span><span class="o">.</span><span class="n">nout</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># method != &#39;__call__&#39;</span>
            <span class="c1"># Make context for output (trivial one returns `None`)</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out_ctx</span> <span class="o">=</span> <span class="n">nullcontext</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out_ctx</span> <span class="o">=</span> <span class="n">writable_array</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">array_kwargs</span><span class="p">)</span>

            <span class="c1"># Evaluate ufunc method</span>
            <span class="k">with</span> <span class="n">out_ctx</span> <span class="k">as</span> <span class="n">out_arr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">!=</span> <span class="s1">&#39;at&#39;</span><span class="p">:</span>
                    <span class="c1"># No kwargs allowed for &#39;at&#39;</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_arr</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Shortcut for scalar or no return value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="ow">or</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># The first occurs for `reduce` with all axes,</span>
                <span class="c1"># the second for in-place stuff (`at` currently)</span>
                <span class="k">return</span> <span class="n">res</span>

            <span class="c1"># Wrap result if necessary (lazily)</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_floating_dtype</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t propagate weighting if shape changes</span>
                        <span class="n">weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span>
                                                                   <span class="n">exponent</span><span class="p">)</span>
                    <span class="n">spc_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;weighting&#39;</span><span class="p">:</span> <span class="n">weighting</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">spc_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="n">out_space</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">space</span><span class="p">)(</span><span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">spc_kwargs</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out_space</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">_blas_is_applicable</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Whether BLAS routines can be applied or not.</span>

<span class="sd">    BLAS routines are available for single and double precision</span>
<span class="sd">    float or complex data only. If the arrays are non-contiguous,</span>
<span class="sd">    BLAS methods are usually slower, and array-writing routines do</span>
<span class="sd">    not work at all. Hence, only contiguous arrays are allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1,...,xN : `NumpyTensor`</span>
<span class="sd">        The tensors to be tested for BLAS conformity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    blas_is_applicable : bool</span>
<span class="sd">        ``True`` if all mentioned requirements are met, ``False`` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_BLAS_DTYPES</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span> <span class="ow">or</span>
              <span class="nb">all</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># Temporary fix for 32 bit int overflow in BLAS</span>
        <span class="c1"># TODO: use chunking instead</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_lincomb_impl</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimized implementation of ``out[:] = a * x1 + b * x2``.&quot;&quot;&quot;</span>
    <span class="c1"># Lazy import to improve `import odl` time</span>
    <span class="kn">import</span> <span class="nn">scipy.linalg</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">native</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">THRESHOLD_SMALL</span><span class="p">:</span>
        <span class="c1"># Faster for small arrays</span>
        <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x1</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span>
        <span class="k">return</span>

    <span class="k">elif</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">THRESHOLD_MEDIUM</span> <span class="ow">or</span>
          <span class="ow">not</span> <span class="n">_blas_is_applicable</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>

        <span class="k">def</span> <span class="nf">fallback_axpy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Fallback axpy implementation avoiding copy.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x2</span> <span class="o">/=</span> <span class="n">a</span>
                <span class="n">x2</span> <span class="o">+=</span> <span class="n">x1</span>
                <span class="n">x2</span> <span class="o">*=</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">x2</span>

        <span class="k">def</span> <span class="nf">fallback_scal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Fallback scal implementation.&quot;&quot;&quot;</span>
            <span class="n">x</span> <span class="o">*=</span> <span class="n">a</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">def</span> <span class="nf">fallback_copy</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Fallback copy implementation.&quot;&quot;&quot;</span>
            <span class="n">x2</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="o">...</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">x2</span>

        <span class="n">axpy</span><span class="p">,</span> <span class="n">scal</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">fallback_axpy</span><span class="p">,</span> <span class="n">fallback_scal</span><span class="p">,</span> <span class="n">fallback_copy</span><span class="p">)</span>
        <span class="n">x1_arr</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">data</span>
        <span class="n">x2_arr</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Need flat data for BLAS, otherwise in-place does not work.</span>
        <span class="c1"># Raveling must happen in fixed order for non-contiguous out,</span>
        <span class="c1"># otherwise &#39;A&#39; is applied to arrays, which makes the outcome</span>
        <span class="c1"># dependent on their respective contiguousness.</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
            <span class="n">ravel_order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ravel_order</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span>

        <span class="n">x1_arr</span> <span class="o">=</span> <span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">ravel_order</span><span class="p">)</span>
        <span class="n">x2_arr</span> <span class="o">=</span> <span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">ravel_order</span><span class="p">)</span>
        <span class="n">out_arr</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">ravel_order</span><span class="p">)</span>
        <span class="n">axpy</span><span class="p">,</span> <span class="n">scal</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">blas</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span>
            <span class="p">[</span><span class="s1">&#39;axpy&#39;</span><span class="p">,</span> <span class="s1">&#39;scal&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">],</span> <span class="n">arrays</span><span class="o">=</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="n">x2_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="n">x2</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># x1 is aligned with x2 -&gt; out = (a+b)*x1</span>
        <span class="n">_lincomb_impl</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="n">x1</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="n">x2</span><span class="p">:</span>
        <span class="c1"># All the vectors are aligned -&gt; out = (a+b)*out</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">scal</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="n">x1</span><span class="p">:</span>
        <span class="c1"># out is aligned with x1 -&gt; out = a*out + b*x2</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axpy</span><span class="p">(</span><span class="n">x2_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="n">x2</span><span class="p">:</span>
        <span class="c1"># out is aligned with x2 -&gt; out = a*x1 + b*out</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axpy</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># We have exhausted all alignment options, so x1 is not x2 is not out</span>
        <span class="c1"># We now optimize for various values of a and b</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Zero assignment -&gt; out = 0</span>
                <span class="n">out_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Scaled copy -&gt; out = a*x1</span>
                <span class="n">copy</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">scal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># b != 0</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Scaled copy -&gt; out = b*x2</span>
                <span class="n">copy</span><span class="p">(</span><span class="n">x2_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">scal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># No scaling in x1 -&gt; out = x1 + b*x2</span>
                <span class="n">copy</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">axpy</span><span class="p">(</span><span class="n">x2_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Generic case -&gt; out = a*x1 + b*x2</span>
                <span class="n">copy</span><span class="p">(</span><span class="n">x2_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">scal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
                <span class="n">axpy</span><span class="p">(</span><span class="n">x1_arr</span><span class="p">,</span> <span class="n">out_arr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_weighting</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a weighting whose type is inferred from the arguments.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># last possibility: make an array</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">weighting</span> <span class="o">=</span> <span class="n">NumpyTensorSpaceArrayWeighting</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">weighting</span>


<div class="viewcode-block" id="npy_weighted_inner"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.npy_weighted_inner.html#odl.space.npy_tensors.npy_weighted_inner">[docs]</a><span class="k">def</span> <span class="nf">npy_weighted_inner</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Weighted inner product on `TensorSpace`&#39;s as free function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : scalar or `array-like`</span>
<span class="sd">        Weights of the inner product. A scalar is interpreted as a</span>
<span class="sd">        constant weight, a 1-dim. array as a weighting vector.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inner : `callable`</span>
<span class="sd">        Inner product function with given weight. Constant weightings</span>
<span class="sd">        are applicable to spaces of any size, for arrays the sizes</span>
<span class="sd">        of the weighting and the space must match.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    NumpyTensorSpaceConstWeighting</span>
<span class="sd">    NumpyTensorSpaceArrayWeighting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_weighting</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">inner</span></div>


<div class="viewcode-block" id="npy_weighted_norm"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.npy_weighted_norm.html#odl.space.npy_tensors.npy_weighted_norm">[docs]</a><span class="k">def</span> <span class="nf">npy_weighted_norm</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Weighted norm on `TensorSpace`&#39;s as free function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : scalar or `array-like`</span>
<span class="sd">        Weights of the norm. A scalar is interpreted as a</span>
<span class="sd">        constant weight, a 1-dim. array as a weighting vector.</span>
<span class="sd">    exponent : positive `float`</span>
<span class="sd">        Exponent of the norm.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    norm : `callable`</span>
<span class="sd">        Norm function with given weight. Constant weightings</span>
<span class="sd">        are applicable to spaces of any size, for arrays the sizes</span>
<span class="sd">        of the weighting and the space must match.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    NumpyTensorSpaceConstWeighting</span>
<span class="sd">    NumpyTensorSpaceArrayWeighting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_weighting</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">norm</span></div>


<div class="viewcode-block" id="npy_weighted_dist"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.npy_weighted_dist.html#odl.space.npy_tensors.npy_weighted_dist">[docs]</a><span class="k">def</span> <span class="nf">npy_weighted_dist</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Weighted distance on `TensorSpace`&#39;s as free function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weights : scalar or `array-like`</span>
<span class="sd">        Weights of the distance. A scalar is interpreted as a</span>
<span class="sd">        constant weight, a 1-dim. array as a weighting vector.</span>
<span class="sd">    exponent : positive `float`</span>
<span class="sd">        Exponent of the norm.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dist : `callable`</span>
<span class="sd">        Distance function with given weight. Constant weightings</span>
<span class="sd">        are applicable to spaces of any size, for arrays the sizes</span>
<span class="sd">        of the weighting and the space must match.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    NumpyTensorSpaceConstWeighting</span>
<span class="sd">    NumpyTensorSpaceArrayWeighting</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_weighting</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span><span class="o">.</span><span class="n">dist</span></div>


<span class="k">def</span> <span class="nf">_norm_default</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default Euclidean norm implementation.&quot;&quot;&quot;</span>
    <span class="c1"># Lazy import to improve `import odl` time</span>
    <span class="kn">import</span> <span class="nn">scipy.linalg</span>

    <span class="k">if</span> <span class="n">_blas_is_applicable</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
        <span class="n">nrm2</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">blas</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span><span class="s1">&#39;nrm2&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">nrm2</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">native</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span>
    <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_pnorm_default</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default p-norm implementation.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="nb">ord</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pnorm_diagweight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Diagonally weighted p-norm implementation.&quot;&quot;&quot;</span>
    <span class="c1"># Ravel both in the same order (w is a numpy array)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>

    <span class="c1"># This is faster than first applying the weights and then summing with</span>
    <span class="c1"># BLAS dot or nrm2</span>
    <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
        <span class="n">xp</span> <span class="o">*=</span> <span class="n">w</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">xp</span><span class="p">)</span>
        <span class="n">xp</span> <span class="o">*=</span> <span class="n">w</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_inner_default</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default Euclidean inner product implementation.&quot;&quot;&quot;</span>
    <span class="c1"># Ravel both in the same order</span>
    <span class="n">order</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span> <span class="k">else</span> <span class="s1">&#39;C&#39;</span>

    <span class="k">if</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">THRESHOLD_MEDIUM</span><span class="p">:</span>
            <span class="c1"># This is as fast as BLAS dotc</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Several times faster for small arrays</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">),</span>
                          <span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># x2 as first argument because we want linearity in x1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">(</span><span class="n">x2</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">),</span>
                       <span class="n">x1</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="p">))</span>


<span class="c1"># TODO: implement intermediate weighting schemes with arrays that are</span>
<span class="c1"># broadcast, i.e. between scalar and full-blown in dimensionality?</span>


<div class="viewcode-block" id="NumpyTensorSpaceArrayWeighting"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.html#odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpaceArrayWeighting</span><span class="p">(</span><span class="n">ArrayWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Weighting of a `NumpyTensorSpace` by an array.</span>

<span class="sd">    This class defines a weighting by an array that has the same shape</span>
<span class="sd">    as the tensor space. Since the space is not known to this class,</span>
<span class="sd">    no checks of shape or data type are performed.</span>
<span class="sd">    See ``Notes`` for mathematical details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpaceArrayWeighting.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.html#odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : `array-like`, one-dim.</span>
<span class="sd">            Weighting array of the inner product, norm and distance.</span>
<span class="sd">            All its entries must be positive, however this is not</span>
<span class="sd">            verified during initialization.</span>
<span class="sd">        exponent : positive `float`</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, no inner</span>
<span class="sd">            product is defined.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with array</span>
<span class="sd">          :math:`W` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">              \langle A, B\rangle_W :=</span>
<span class="sd">              \langle W \odot A, B\rangle =</span>
<span class="sd">              \langle w \odot a, b\rangle =</span>
<span class="sd">              b^{\mathrm{H}} (w \odot a),</span>

<span class="sd">          where :math:`a, b, w` are the &quot;flattened&quot; counterparts of</span>
<span class="sd">          tensors :math:`A, B, W`, respectively, :math:`b^{\mathrm{H}}`</span>
<span class="sd">          stands for transposed complex conjugate and :math:`w \odot a`</span>
<span class="sd">          for element-wise multiplication.</span>

<span class="sd">        - For other exponents, only norm and dist are defined. In the</span>
<span class="sd">          case of exponent :math:`\infty`, the weighted norm is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| A\|_{W, \infty} :=</span>
<span class="sd">              \| W \odot A\|_{\infty} =</span>
<span class="sd">              \| w \odot a\|_{\infty},</span>

<span class="sd">          otherwise it is (using point-wise exponentiation)</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| A\|_{W, p} :=</span>
<span class="sd">              \| W^{1/p} \odot A\|_{p} =</span>
<span class="sd">              \| w^{1/p} \odot a\|_{\infty}.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit</span>
<span class="sd">          property in :math:`p`, i.e.</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| A\|_{W, p} \not\to</span>
<span class="sd">              \| A\|_{W, \infty} \quad (p \to \infty)</span>

<span class="sd">          unless all weights are equal to 1.</span>

<span class="sd">        - The array :math:`W` may only have positive entries, otherwise</span>
<span class="sd">          it does not define an inner product or norm, respectively. This</span>
<span class="sd">          is not checked during initialization.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">NumpyTensor</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">data</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpaceArrayWeighting</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">array</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``hash(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

<div class="viewcode-block" id="NumpyTensorSpaceArrayWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.inner.html#odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted inner product of ``x1`` and ``x2``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Tensors whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided vectors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">_inner_default</span><span class="p">(</span><span class="n">x1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">x1</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpaceArrayWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.norm.html#odl.space.npy_tensors.NumpyTensorSpaceArrayWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted norm of ``x``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `NumpyTensor`</span>
<span class="sd">            Tensor whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the provided tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">norm_squared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># TODO: optimize?!</span>
            <span class="k">if</span> <span class="n">norm_squared</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">norm_squared</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># Compensate for numerical error</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_squared</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">_pnorm_diagweight</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="NumpyTensorSpaceConstWeighting"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.html#odl.space.npy_tensors.NumpyTensorSpaceConstWeighting">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpaceConstWeighting</span><span class="p">(</span><span class="n">ConstWeighting</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Weighting of a `NumpyTensorSpace` by a constant.</span>

<span class="sd">    See ``Notes`` for mathematical details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpaceConstWeighting.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.html#odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">const</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        const : positive float</span>
<span class="sd">            Weighting constant of the inner product, norm and distance.</span>
<span class="sd">        exponent : positive float</span>
<span class="sd">            Exponent of the norm. For values other than 2.0, the inner</span>
<span class="sd">            product is not defined.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - For exponent 2.0, a new weighted inner product with constant</span>
<span class="sd">          :math:`c` is defined as</span>

<span class="sd">          .. math::</span>
<span class="sd">              \langle a, b\rangle_c :=</span>
<span class="sd">              c \, \langle a, b\rangle_c =</span>
<span class="sd">              c \, b^{\mathrm{H}} a,</span>

<span class="sd">          where :math:`b^{\mathrm{H}}` standing for transposed complex</span>
<span class="sd">          conjugate.</span>

<span class="sd">        - For other exponents, only norm and dist are defined. In the</span>
<span class="sd">          case of exponent :math:`\infty`, the weighted norm is defined</span>
<span class="sd">          as</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| a \|_{c, \infty} :=</span>
<span class="sd">              c\, \| a \|_{\infty},</span>

<span class="sd">          otherwise it is</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| a \|_{c, p} :=</span>
<span class="sd">              c^{1/p}\, \| a \|_{p}.</span>

<span class="sd">        - Note that this definition does **not** fulfill the limit</span>
<span class="sd">          property in :math:`p`, i.e.</span>

<span class="sd">          .. math::</span>
<span class="sd">              \| a\|_{c, p} \not\to</span>
<span class="sd">              \| a \|_{c, \infty} \quad (p \to \infty)</span>

<span class="sd">          unless :math:`c = 1`.</span>

<span class="sd">        - The constant must be positive, otherwise it does not define an</span>
<span class="sd">          inner product or norm, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpaceConstWeighting</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">const</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpaceConstWeighting.inner"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.inner.html#odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.inner">[docs]</a>    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted inner product of ``x1`` and ``x2``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Tensors whose inner product is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inner : float or complex</span>
<span class="sd">            The inner product of the two provided tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;no inner product defined for &#39;</span>
                                      <span class="s1">&#39;exponent != 2 (got </span><span class="si">{}</span><span class="s1">)&#39;</span>
                                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">_inner_default</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">inner</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x1</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span></div>

<div class="viewcode-block" id="NumpyTensorSpaceConstWeighting.norm"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.norm.html#odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted norm of ``x``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1 : `NumpyTensor`</span>
<span class="sd">            Tensor whose norm is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>
<span class="sd">            The norm of the tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">)</span> <span class="o">*</span> <span class="n">_norm_default</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">_pnorm_default</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                          <span class="n">_pnorm_default</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span></div>

<div class="viewcode-block" id="NumpyTensorSpaceConstWeighting.dist"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.dist.html#odl.space.npy_tensors.NumpyTensorSpaceConstWeighting.dist">[docs]</a>    <span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weighted distance between ``x1`` and ``x2``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x1, x2 : `NumpyTensor`</span>
<span class="sd">            Tensors whose mutual distance is calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dist : float</span>
<span class="sd">            The distance between the tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span><span class="p">)</span> <span class="o">*</span> <span class="n">_norm_default</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">_pnorm_default</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span> <span class="o">*</span>
                          <span class="n">_pnorm_default</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)))</span></div></div>


<div class="viewcode-block" id="NumpyTensorSpaceCustomInner"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomInner.html#odl.space.npy_tensors.NumpyTensorSpaceCustomInner">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpaceCustomInner</span><span class="p">(</span><span class="n">CustomInner</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified inner product.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpaceCustomInner.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomInner.html#odl.space.npy_tensors.NumpyTensorSpaceCustomInner.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inner : `callable`</span>
<span class="sd">            The inner product implementation. It must accept two</span>
<span class="sd">            `Tensor` arguments, return an element from their space&#39;s</span>
<span class="sd">            field (real or complex number) and satisfy the following</span>
<span class="sd">            conditions for all vectors ``x, y, z`` and scalars ``s``:</span>

<span class="sd">            - ``&lt;x, y&gt; = conj(&lt;y, x&gt;)``</span>
<span class="sd">            - ``&lt;s*x + y, z&gt; = s * &lt;x, z&gt; + &lt;y, z&gt;``</span>
<span class="sd">            - ``&lt;x, x&gt; = 0``  if and only if  ``x = 0``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpaceCustomInner</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inner</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NumpyTensorSpaceCustomNorm"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomNorm.html#odl.space.npy_tensors.NumpyTensorSpaceCustomNorm">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpaceCustomNorm</span><span class="p">(</span><span class="n">CustomNorm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified norm.</span>

<span class="sd">    Note that this removes ``inner``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpaceCustomNorm.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomNorm.html#odl.space.npy_tensors.NumpyTensorSpaceCustomNorm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : `callable`</span>
<span class="sd">            The norm implementation. It must accept a `Tensor`</span>
<span class="sd">            argument, return a `float` and satisfy the following</span>
<span class="sd">            conditions for all any two elements ``x, y`` and scalars</span>
<span class="sd">            ``s``:</span>

<span class="sd">            - ``||x|| &gt;= 0``</span>
<span class="sd">            - ``||x|| = 0``  if and only if  ``x = 0``</span>
<span class="sd">            - ``||s * x|| = |s| * ||x||``</span>
<span class="sd">            - ``||x + y|| &lt;= ||x|| + ||y||``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpaceCustomNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NumpyTensorSpaceCustomDist"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomDist.html#odl.space.npy_tensors.NumpyTensorSpaceCustomDist">[docs]</a><span class="k">class</span> <span class="nc">NumpyTensorSpaceCustomDist</span><span class="p">(</span><span class="n">CustomDist</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Class for handling a user-specified distance in `TensorSpace`.</span>

<span class="sd">    Note that this removes ``inner`` and ``norm``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NumpyTensorSpaceCustomDist.__init__"><a class="viewcode-back" href="../../../generated/odl.space.npy_tensors.NumpyTensorSpaceCustomDist.html#odl.space.npy_tensors.NumpyTensorSpaceCustomDist.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dist : `callable`</span>
<span class="sd">            The distance function defining a metric on `TensorSpace`. It</span>
<span class="sd">            must accept two `Tensor` arguments, return a `float` and</span>
<span class="sd">            fulfill the following mathematical conditions for any three</span>
<span class="sd">            elements ``x, y, z``:</span>

<span class="sd">            - ``dist(x, y) &gt;= 0``</span>
<span class="sd">            - ``dist(x, y) = 0``  if and only if  ``x = y``</span>
<span class="sd">            - ``dist(x, y) = dist(y, x)``</span>
<span class="sd">            - ``dist(x, y) &lt;= dist(x, z) + dist(z, y)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NumpyTensorSpaceCustomDist</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span></div></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>