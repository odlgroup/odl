<!DOCTYPE html>
<html class="writer-html5" lang="english" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>odl.tomo.geometry.conebeam &mdash; odl 1.0.0.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/custom.css?v=d6003e95" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/documentation_options.js?v=293a974f"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            odl
          </a>
              <div class="version">
                1.0.0.dev0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/guide.html">User's guide -- selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../refs.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../odl.html">odl</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">odl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">odl.tomo.geometry.conebeam</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for odl.tomo.geometry.conebeam</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Cone beam geometries in 2 and 3 dimensions.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.discr</span> <span class="kn">import</span> <span class="n">uniform_partition</span>
<span class="kn">from</span> <span class="nn">odl.tomo.geometry.detector</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CircularDetector</span><span class="p">,</span> <span class="n">CylindricalDetector</span><span class="p">,</span> <span class="n">Flat1dDetector</span><span class="p">,</span> <span class="n">Flat2dDetector</span><span class="p">,</span>
    <span class="n">SphericalDetector</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.tomo.geometry.geometry</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AxisOrientedGeometry</span><span class="p">,</span> <span class="n">DivergentBeamGeometry</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.tomo.util.utility</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">euler_matrix</span><span class="p">,</span> <span class="n">is_inside_bounds</span><span class="p">,</span> <span class="n">transform_system</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">array_str</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">signature_string</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;FanBeamGeometry&#39;</span><span class="p">,</span> <span class="s1">&#39;ConeBeamGeometry&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cone_beam_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;helical_geometry&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="FanBeamGeometry">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.html#odl.tomo.geometry.conebeam.FanBeamGeometry">[docs]</a>
<span class="k">class</span> <span class="nc">FanBeamGeometry</span><span class="p">(</span><span class="n">DivergentBeamGeometry</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fan beam (2d cone beam) geometry.</span>

<span class="sd">    The source moves on a circle with radius ``src_radius``, and the</span>
<span class="sd">    detector reference point is opposite to the source, i.e. at maximum</span>
<span class="sd">    distance, on a circle with radius ``det_radius``. One of the two</span>
<span class="sd">    radii can be chosen as 0, which corresponds to a stationary source</span>
<span class="sd">    or detector, respectively.</span>

<span class="sd">    The motion parameter is the 1d rotation angle parameterizing source</span>
<span class="sd">    and detector positions simultaneously.</span>

<span class="sd">    In the standard configuration, the detector is perpendicular to the</span>
<span class="sd">    ray direction, its reference point is initially at ``(0, 1)``, and</span>
<span class="sd">    the initial detector axis is ``(1, 0)``.</span>

<span class="sd">    For details, check `the online docs</span>
<span class="sd">    &lt;https://odlgroup.github.io/odl/guide/geometry_guide.html&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_default_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">det_axis_init</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<div class="viewcode-block" id="FanBeamGeometry.__init__">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.html#odl.tomo.geometry.conebeam.FanBeamGeometry.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span>
                 <span class="n">det_curvature_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">src_to_det_init</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">src_shift_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">det_shift_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        apart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the angle interval.</span>
<span class="sd">        dpart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the detector parameter interval.</span>
<span class="sd">        src_radius : nonnegative float</span>
<span class="sd">            Radius of the source circle.</span>
<span class="sd">        det_radius : nonnegative float</span>
<span class="sd">            Radius of the detector circle. Must be nonzero if ``src_radius``</span>
<span class="sd">            is zero.</span>
<span class="sd">        det_curvature_radius : nonnegative float, optional</span>
<span class="sd">            Radius of the detector curvature.</span>
<span class="sd">            If ``None``, a flat detector is used, otherwise must be positive.</span>
<span class="sd">        src_to_det_init : `array-like` (shape ``(2,)``), optional</span>
<span class="sd">            Initial state of the vector pointing from source to detector</span>
<span class="sd">            reference point. The zero vector is not allowed.</span>
<span class="sd">        src_shift_func : callable, optional</span>
<span class="sd">            Function with signature ``src_shift_func(angle) -&gt; shift``</span>
<span class="sd">            returning a source shift for a given angle.</span>
<span class="sd">            Each shift is interpreted as a vector ``[shift_d, shift_t]``, where</span>
<span class="sd">            &quot;d&quot; and &quot;t&quot; denote shifts in the detector-to-source and</span>
<span class="sd">            tangent directions, respectively.</span>
<span class="sd">        det_shift_func : callable, optional</span>
<span class="sd">            Function with signature ``det_shift_func(angle) -&gt; shift``</span>
<span class="sd">            returning a detector shift for a given angle.</span>
<span class="sd">            Each shift is interpreted as a vector ``[shift_d, shift_t]``, where</span>
<span class="sd">            &quot;d&quot; and &quot;t&quot; denote shifts in the source-to-detector and</span>
<span class="sd">            tangent directions, respectively.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        det_axis_init : `array-like` (shape ``(2,)``), optional</span>
<span class="sd">            Initial axis defining the detector orientation. The default</span>
<span class="sd">            depends on ``src_to_det_init``, see Notes.</span>
<span class="sd">        translation : `array-like`, shape ``(2,)``, optional</span>
<span class="sd">            Global translation of the geometry. This is added last in any</span>
<span class="sd">            method that computes an absolute vector, e.g., `det_refpoint`,</span>
<span class="sd">            and also shifts the center of rotation.</span>
<span class="sd">        check_bounds : bool, optional</span>
<span class="sd">            If ``True``, methods computing vectors check input arguments.</span>
<span class="sd">            Checks are vectorized and add only a small overhead.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the default configuration, the initial source-to-detector vector</span>
<span class="sd">        is ``(0, 1)``, and the initial detector axis is ``(1, 0)``. If a</span>
<span class="sd">        different ``src_to_det_init`` is chosen, the new default axis is</span>
<span class="sd">        given as a rotation of the original one by a matrix that transforms</span>
<span class="sd">        ``(0, 1)`` to the new (normalized) ``src_to_det_init``. This matrix</span>
<span class="sd">        is calculated with the `rotation_matrix_from_to` function.</span>
<span class="sd">        Expressed in code, we have ::</span>

<span class="sd">            init_rot = rotation_matrix_from_to((0, 1), src_to_det_init)</span>
<span class="sd">            det_axis_init = init_rot.dot((1, 0))</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialization with default parameters and some radii:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-1, 1, 20)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=1, det_radius=5)</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(0)</span>
<span class="sd">        array([ 0., -1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([ 0.,  5.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_point_position(0, 1)  # (0, 5) + 1 * (1, 0)</span>
<span class="sd">        array([ 1.,  5.])</span>

<span class="sd">        Checking the default orientation:</span>

<span class="sd">        &gt;&gt;&gt; geom.src_to_det_init</span>
<span class="sd">        array([ 0.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_axis_init</span>
<span class="sd">        array([ 1.,  0.])</span>

<span class="sd">        Specifying curvature of the detector:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-np.pi / 2, np.pi / 2, 10)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=1, det_radius=5,</span>
<span class="sd">        ...                        det_curvature_radius=10)</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(0)</span>
<span class="sd">        array([ 0., -1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([ 0.,  5.])</span>
<span class="sd">        &gt;&gt;&gt; # (0, 5) + 10 * (sin(pi/6), cos(pi/6) - 1)</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.det_point_position(0, np.pi / 6), 2)</span>
<span class="sd">        array([ 5.  ,  3.66])</span>

<span class="sd">        Specifying an initial detector position by default rotates the</span>
<span class="sd">        standard configuration to this position:</span>

<span class="sd">        &gt;&gt;&gt; e_x, e_y = np.eye(2)  # standard unit vectors</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=1, det_radius=5,</span>
<span class="sd">        ...                        src_to_det_init=(1, 0))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, e_x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axis_init, -e_y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=1, det_radius=5,</span>
<span class="sd">        ...                        src_to_det_init=(0, -1))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, -e_y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axis_init, -e_x)</span>
<span class="sd">        True</span>

<span class="sd">        The initial detector axis can also be set explicitly:</span>

<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=1, det_radius=5,</span>
<span class="sd">        ...     src_to_det_init=(1, 0), det_axis_init=(0, 1))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, e_x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axis_init, e_y)</span>
<span class="sd">        True</span>

<span class="sd">        Specifying a flying focal spot and detector offset:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=5,</span>
<span class="sd">        ...     src_shift_func=lambda angle: odl.tomo.flying_focal_spot(</span>
<span class="sd">        ...             angle, apart=apart, shifts=[(0.1, 0), (0, 0.1)]),</span>
<span class="sd">        ...     det_shift_func=lambda angle: [0.0, 0.05])</span>
<span class="sd">        &gt;&gt;&gt; geom.src_shift_func(geom.angles)</span>
<span class="sd">        array([[ 0.1, 0. ],</span>
<span class="sd">               [ 0. , 0.1],</span>
<span class="sd">               [ 0.1, 0. ],</span>
<span class="sd">               [ 0. , 0.1]])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_shift_func(geom.angles)</span>
<span class="sd">        [0.0, 0.05]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_src_to_det_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">]</span>
        <span class="n">default_det_axis_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;det_axis_init&#39;</span><span class="p">]</span>

        <span class="c1"># Handle the initial coordinate system. We need to assign `None` to</span>
        <span class="c1"># the vectors first in order to signalize to the `transform_system`</span>
        <span class="c1"># utility that they should be transformed from default since they</span>
        <span class="c1"># were not explicitly given.</span>
        <span class="n">det_axis_init</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;det_axis_init&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">src_to_det_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">det_axis_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_axis_init_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">det_axis_init</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_axis_init_arg</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Compute the transformed system and the transition matrix. We</span>
        <span class="c1"># transform only those vectors that were not explicitly given.</span>
        <span class="n">vecs_to_transform</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">det_axis_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vecs_to_transform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_det_axis_init</span><span class="p">)</span>

        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="n">transform_system</span><span class="p">(</span>
            <span class="n">src_to_det_init</span><span class="p">,</span> <span class="n">default_src_to_det_init</span><span class="p">,</span> <span class="n">vecs_to_transform</span><span class="p">)</span>
        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">transformed_vecs</span><span class="p">)</span>

        <span class="n">src_to_det_init</span> <span class="o">=</span> <span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">det_axis_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_axis_init</span> <span class="o">=</span> <span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">transformed_vecs</span> <span class="o">==</span> <span class="p">[]</span>

        <span class="c1"># Check and normalize `src_to_det_init`. Detector axes are</span>
        <span class="c1"># normalized in the detector class.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`src_to_det_init` cannot be the zero vector&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_to_det_init</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">)</span>

        <span class="c1"># Initialize stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__src_to_det_init</span> <span class="o">=</span> <span class="n">src_to_det_init</span>
        <span class="c1"># `check_bounds` is needed for both detector and geometry</span>
        <span class="n">check_bounds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_bounds&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">det_curvature_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">detector</span> <span class="o">=</span> <span class="n">Flat1dDetector</span><span class="p">(</span><span class="n">dpart</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">det_axis_init</span><span class="p">,</span>
                                      <span class="n">check_bounds</span><span class="o">=</span><span class="n">check_bounds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">detector</span> <span class="o">=</span> <span class="n">CircularDetector</span><span class="p">(</span><span class="n">dpart</span><span class="p">,</span>
                                        <span class="n">radius</span><span class="o">=</span><span class="n">det_curvature_radius</span><span class="p">,</span>
                                        <span class="n">axis</span><span class="o">=</span><span class="n">det_axis_init</span><span class="p">,</span>
                                        <span class="n">check_bounds</span><span class="o">=</span><span class="n">check_bounds</span><span class="p">)</span>

        <span class="n">translation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;translation&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FanBeamGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">motion_part</span><span class="o">=</span><span class="n">apart</span><span class="p">,</span> <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">,</span>
            <span class="n">translation</span><span class="o">=</span><span class="n">translation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__src_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">src_radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source circle radius </span><span class="si">{}</span><span class="s1"> is negative&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src_radius</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__det_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">det_radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;detector circle radius </span><span class="si">{}</span><span class="s1"> is negative&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det_radius</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source and detector circle radii cannot both be &#39;</span>
                             <span class="s1">&#39;0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`apart` has dimension </span><span class="si">{}</span><span class="s1">, expected 1&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">src_shift_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span> <span class="o">=</span> <span class="n">src_shift_func</span>

        <span class="k">if</span> <span class="n">det_shift_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span> <span class="o">=</span> <span class="n">det_shift_func</span></div>


<div class="viewcode-block" id="FanBeamGeometry.frommatrix">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.frommatrix.html#odl.tomo.geometry.conebeam.FanBeamGeometry.frommatrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">frommatrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span> <span class="n">init_matrix</span><span class="p">,</span>
                   <span class="n">det_curvature_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an instance of `FanBeamGeometry` using a matrix.</span>

<span class="sd">        This alternative constructor uses a matrix to rotate and</span>
<span class="sd">        translate the default configuration. It is most useful when</span>
<span class="sd">        the transformation to be applied is already given as a matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        apart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the angle interval.</span>
<span class="sd">        dpart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the detector parameter interval.</span>
<span class="sd">        src_radius : nonnegative float</span>
<span class="sd">            Radius of the source circle.</span>
<span class="sd">        det_radius : nonnegative float</span>
<span class="sd">            Radius of the detector circle. Must be nonzero if ``src_radius``</span>
<span class="sd">            is zero.</span>
<span class="sd">        init_matrix : `array_like`, shape ``(2, 2)`` or ``(2, 3)``, optional</span>
<span class="sd">            Transformation matrix whose left ``(2, 2)`` block is multiplied</span>
<span class="sd">            with the default ``det_pos_init`` and ``det_axis_init`` to</span>
<span class="sd">            determine the new vectors. If present, the third column acts</span>
<span class="sd">            as a translation after the initial transformation.</span>
<span class="sd">            The resulting ``det_axis_init`` will be normalized.</span>
<span class="sd">        det_curvature_radius : nonnegative float, optional</span>
<span class="sd">            Radius of the detector curvature.</span>
<span class="sd">            If ``None``, flat detector is used, otherwise must be positive.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Further keyword arguments passed to the class constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geometry : `FanBeamGeometry`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Mirror the second unit vector, creating a left-handed system:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-1, 1, 20)</span>
<span class="sd">        &gt;&gt;&gt; matrix = np.array([[1, 0],</span>
<span class="sd">        ...                    [0, -1]])</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry.frommatrix(</span>
<span class="sd">        ...     apart, dpart, src_radius=1, det_radius=5, init_matrix=matrix)</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([ 0., -5.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_axis_init</span>
<span class="sd">        array([ 1.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; geom.translation</span>
<span class="sd">        array([ 0.,  0.])</span>

<span class="sd">        Adding a translation with a third matrix column:</span>

<span class="sd">        &gt;&gt;&gt; matrix = np.array([[1, 0, 1],</span>
<span class="sd">        ...                    [0, -1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry.frommatrix(</span>
<span class="sd">        ...     apart, dpart, src_radius=1, det_radius=5, init_matrix=matrix)</span>
<span class="sd">        &gt;&gt;&gt; geom.translation</span>
<span class="sd">        array([ 1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)  # (0, -5) + (1, 1)</span>
<span class="sd">        array([ 1., -4.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get transformation and translation parts from `init_matrix`</span>
        <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`matrix` must have shape (2, 2) or (2, 3), &#39;</span>
                             <span class="s1">&#39;got array with shape </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">trafo_matrix</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Transform the default vectors</span>
        <span class="n">default_src_to_det_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">]</span>
        <span class="n">default_det_axis_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;det_axis_init&#39;</span><span class="p">]</span>
        <span class="n">vecs_to_transform</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_det_axis_init</span><span class="p">]</span>
        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="n">transform_system</span><span class="p">(</span>
            <span class="n">default_src_to_det_init</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vecs_to_transform</span><span class="p">,</span>
            <span class="n">matrix</span><span class="o">=</span><span class="n">trafo_matrix</span><span class="p">)</span>

        <span class="c1"># Use the standard constructor with these vectors</span>
        <span class="n">src_to_det</span><span class="p">,</span> <span class="n">det_axis</span> <span class="o">=</span> <span class="n">transformed_vecs</span>
        <span class="k">if</span> <span class="n">translation</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;translation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">translation</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span> <span class="n">det_curvature_radius</span><span class="p">,</span>
                   <span class="n">src_to_det</span><span class="p">,</span> <span class="n">det_axis_init</span><span class="o">=</span><span class="n">det_axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source circle radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector circle radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__det_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_curvature_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector curve radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detector</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_to_det_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial source-to-detector unit vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_to_det_init</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_axis_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector axis at angle 0.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">axis</span>

<div class="viewcode-block" id="FanBeamGeometry.det_axis">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.det_axis.html#odl.tomo.geometry.conebeam.FanBeamGeometry.det_axis">[docs]</a>
    <span class="k">def</span> <span class="nf">det_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the detector axis at ``angle``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_axis_init</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discrete angles given in this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_grid</span><span class="o">.</span><span class="n">coord_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_shift_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source shifts in the geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_shift_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector shifts in the geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span>

<div class="viewcode-block" id="FanBeamGeometry.src_position">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.src_position.html#odl.tomo.geometry.conebeam.FanBeamGeometry.src_position">[docs]</a>
    <span class="k">def</span> <span class="nf">src_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the source position at ``angle``.</span>

<span class="sd">        For an angle ``phi``, the source position is given by ::</span>

<span class="sd">            src(phi) = translation +</span>
<span class="sd">                       rot_matrix(phi) * (-src_rad * src_to_det_init) +</span>
<span class="sd">                       source_shift(phi)</span>

<span class="sd">        where ``src_to_det_init`` is the initial unit vector pointing</span>
<span class="sd">        from source to detector and ::</span>

<span class="sd">            source_shift(phi) = rot_matrix(phi) *</span>
<span class="sd">                                (shift[0] * (-src_to_det_init) +</span>
<span class="sd">                                shift[1] * tangent)</span>

<span class="sd">        where ``tangent`` is a vector tangent to the trajectory</span>

<span class="sd">        where ``src_to_det_init`` is the initial unit vector pointing</span>
<span class="sd">        from source to detector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise</span>
<span class="sd">            rotation of source and detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos : `numpy.ndarray`</span>
<span class="sd">            Vector(s) pointing from the origin to the source.</span>
<span class="sd">            If ``angle`` is a single parameter, the returned array has</span>
<span class="sd">            shape ``(2,)``, otherwise ``angle.shape + (2,)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        det_refpoint</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        With default arguments, the source starts at ``src_rad * (-e_y)``</span>
<span class="sd">        and rotates to ``src_rad * e_x`` at 90 degrees:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-1, 1, 20)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=2, det_radius=5)</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(0)</span>
<span class="sd">        array([ 0., -2.])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_position(np.pi / 2), [2, 0])</span>
<span class="sd">        True</span>

<span class="sd">        The method is vectorized, i.e., it can be called with multiple</span>
<span class="sd">        angles at once:</span>

<span class="sd">        &gt;&gt;&gt; points = geom.src_position([0, np.pi / 2])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[0], [0, -2])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[1], [2, 0])</span>
<span class="sd">        True</span>

<span class="sd">        Specifying flying focal spot:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=5,</span>
<span class="sd">        ...     src_shift_func=lambda angle: odl.tomo.flying_focal_spot(</span>
<span class="sd">        ...         angle,</span>
<span class="sd">        ...         apart=apart,</span>
<span class="sd">        ...         shifts=[(0.1, 0), (0, 0.1)]),</span>
<span class="sd">        ...     src_to_det_init=(-0.71, 0.71))</span>
<span class="sd">        &gt;&gt;&gt; geom.angles</span>
<span class="sd">        array([ 0.78539816,  2.35619449,  3.92699082,  5.49778714])</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.src_position(geom.angles), 2)</span>
<span class="sd">        array([[ 1.1, -0. ],</span>
<span class="sd">               [-0.1,  1. ],</span>
<span class="sd">               [-1.1,  0. ],</span>
<span class="sd">               [ 0.1, -1. ]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">squeeze_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="p">())</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">src_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_shift_func</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="c1"># Initial vector from the rotation center to the source. It can be</span>
        <span class="c1"># computed this way since source and detector are at maximum distance,</span>
        <span class="c1"># i.e. the connecting line passes the origin.</span>
        <span class="n">center_to_src_init</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span>
        <span class="c1"># shifting the source according to ffs</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">ffs_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">src_shifts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                       <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">)</span>
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">src_shifts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tangent</span><span class="p">))</span>
        <span class="n">center_to_src_init</span> <span class="o">=</span> <span class="n">center_to_src_init</span> <span class="o">+</span> <span class="n">ffs_shift</span>
        <span class="n">pos_vec</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,...j-&gt;...i&#39;</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                               <span class="n">center_to_src_init</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">squeeze_out</span><span class="p">:</span>
            <span class="n">pos_vec</span> <span class="o">=</span> <span class="n">pos_vec</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">pos_vec</span></div>


<div class="viewcode-block" id="FanBeamGeometry.det_refpoint">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.det_refpoint.html#odl.tomo.geometry.conebeam.FanBeamGeometry.det_refpoint">[docs]</a>
    <span class="k">def</span> <span class="nf">det_refpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the detector reference point position at ``angle``.</span>

<span class="sd">        For an angle ``phi``, the detector position is given by ::</span>

<span class="sd">            det_ref(phi) = translation +</span>
<span class="sd">                           rot_matrix(phi) * (det_rad * src_to_det_init) +</span>
<span class="sd">                           detector_shift(phi)</span>

<span class="sd">        where ``src_to_det_init`` is the initial unit vector pointing</span>
<span class="sd">        from source to detector and ::</span>

<span class="sd">            detector_shift(phi) = rot_matrix(phi) *</span>
<span class="sd">                                  (shift[0] * src_to_det_init +</span>
<span class="sd">                                  shift[1] * tangent)</span>

<span class="sd">        where ``tangent`` is a vector tangent to the trajectory</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise</span>
<span class="sd">            rotation of source and detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        point : `numpy.ndarray`</span>
<span class="sd">            Vector(s) pointing from the origin to the detector reference</span>
<span class="sd">            point. If ``angle`` is a single parameter, the returned array</span>
<span class="sd">            has shape ``(2,)``, otherwise ``angle.shape + (2,)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        src_position</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        With default arguments, the detector starts at ``det_rad * e_y``</span>
<span class="sd">        and rotates to ``det_rad * (-e_x)`` at 90 degrees:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-1, 1, 20)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(apart, dpart, src_radius=2, det_radius=5)</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([ 0.,  5.])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_refpoint(np.pi / 2), [-5, 0])</span>
<span class="sd">        True</span>

<span class="sd">        The method is vectorized, i.e., it can be called with multiple</span>
<span class="sd">        angles at once:</span>

<span class="sd">        &gt;&gt;&gt; points = geom.det_refpoint([0, np.pi / 2])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[0], [0, 5])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[1], [-5, 0])</span>
<span class="sd">        True</span>

<span class="sd">        Specifying detector offset:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = FanBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=1,</span>
<span class="sd">        ...     det_shift_func=lambda angle: [0.0, 0.1],</span>
<span class="sd">        ...     src_to_det_init=(0.71, -0.71))</span>
<span class="sd">        &gt;&gt;&gt; geom.angles</span>
<span class="sd">        array([ 0.78539816,  2.35619449,  3.92699082,  5.49778714])</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.det_refpoint(geom.angles), 2)</span>
<span class="sd">        array([[ 1. ,  0.1],</span>
<span class="sd">               [-0.1,  1. ],</span>
<span class="sd">               [-1. , -0.1],</span>
<span class="sd">               [ 0.1, -1. ]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">squeeze_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="p">())</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">det_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_shift_func</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Initial vector from the rotation center to the detector. It can be</span>
        <span class="c1"># computed this way since source and detector are at maximum distance,</span>
        <span class="c1"># i.e. the connecting line passes the origin.</span>
        <span class="n">center_to_det_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span>
        <span class="c1"># shifting the detector</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">det_shifts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">)</span>
                 <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">det_shifts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tangent</span><span class="p">))</span>
        <span class="n">center_to_det_init</span> <span class="o">=</span> <span class="n">center_to_det_init</span> <span class="o">+</span> <span class="n">shift</span>
        <span class="n">refpt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                 <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,...j-&gt;...i&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                             <span class="n">center_to_det_init</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">squeeze_out</span><span class="p">:</span>
            <span class="n">refpt</span> <span class="o">=</span> <span class="n">refpt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">refpt</span></div>


<div class="viewcode-block" id="FanBeamGeometry.rotation_matrix">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.rotation_matrix.html#odl.tomo.geometry.conebeam.FanBeamGeometry.rotation_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the rotation matrix for ``angle``.</span>

<span class="sd">        For an angle ``phi``, the matrix is given by ::</span>

<span class="sd">            rot(phi) = [[cos(phi), -sin(phi)],</span>
<span class="sd">                        [sin(phi), cos(phi)]]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise</span>
<span class="sd">            rotation of source and detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rot : `numpy.ndarray`</span>
<span class="sd">            The rotation matrix (or matrices) mapping vectors at the</span>
<span class="sd">            initial state to the ones in the state defined by ``angle``.</span>
<span class="sd">            The rotation is extrinsic, i.e., defined in the &quot;world&quot;</span>
<span class="sd">            coordinate system.</span>
<span class="sd">            If ``angle`` is a single parameter, the returned array has</span>
<span class="sd">            shape ``(2, 2)``, otherwise ``angle.shape + (2, 2)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">squeeze_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="p">())</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_bounds</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_inside_bounds</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_params</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`angle` </span><span class="si">{}</span><span class="s1"> not in the valid range </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_params</span><span class="p">))</span>

        <span class="n">matrix</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">squeeze_out</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">matrix</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_partition</span><span class="p">]</span>
        <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;src_radius&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;det_radius&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">]):</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">,</span> <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det_axis_init_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;det_axis_init&#39;</span><span class="p">,</span> <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_det_axis_init_arg</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;translation&#39;</span><span class="p">,</span> <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>

        <span class="n">sig_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">indent</span><span class="p">(</span><span class="n">sig_str</span><span class="p">))</span>

<div class="viewcode-block" id="FanBeamGeometry.__getitem__">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.FanBeamGeometry.__getitem__.html#odl.tomo.geometry.conebeam.FanBeamGeometry.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self[indices].</span>

<span class="sd">        This is defined by ::</span>

<span class="sd">            self[indices].partition == self.partition[indices]</span>

<span class="sd">        where all other parameters are the same.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(-1, 1, 20)</span>
<span class="sd">        &gt;&gt;&gt; geom = odl.tomo.FanBeamGeometry(apart, dpart, 50, 100)</span>

<span class="sd">        Extract sub-geometry with every second angle:</span>

<span class="sd">        &gt;&gt;&gt; geom[::2, :]</span>
<span class="sd">        FanBeamGeometry(</span>
<span class="sd">            nonuniform_partition(</span>
<span class="sd">                [ 0.5,  2.5],</span>
<span class="sd">                min_pt=0.0, max_pt=4.0</span>
<span class="sd">            ),</span>
<span class="sd">            uniform_partition(-1.0, 1.0, 20),</span>
<span class="sd">            src_radius=50.0,</span>
<span class="sd">            det_radius=100.0</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">apart</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dpart</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">FanBeamGeometry</span><span class="p">(</span><span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span>
                               <span class="n">src_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span><span class="p">,</span>
                               <span class="n">det_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span><span class="p">,</span>
                               <span class="n">det_curvature_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_curvature_radius</span><span class="p">,</span>
                               <span class="n">src_to_det_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">,</span>
                               <span class="n">det_axis_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_det_axis_init_arg</span><span class="p">,</span>
                               <span class="n">src_shift_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src_shift_func</span><span class="p">,</span>
                               <span class="n">det_shift_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_shift_func</span><span class="p">,</span>
                               <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ConeBeamGeometry">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.html#odl.tomo.geometry.conebeam.ConeBeamGeometry">[docs]</a>
<span class="k">class</span> <span class="nc">ConeBeamGeometry</span><span class="p">(</span><span class="n">DivergentBeamGeometry</span><span class="p">,</span> <span class="n">AxisOrientedGeometry</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cone beam geometry with circular/helical source curve.</span>

<span class="sd">    The source moves along a spiral oriented along a fixed ``axis``, with</span>
<span class="sd">    radius ``src_radius`` in the azimuthal plane and a given ``pitch``.</span>
<span class="sd">    The detector reference point is opposite to the source, i.e. in</span>
<span class="sd">    the point at distance ``src_rad + det_rad`` on the line in the</span>
<span class="sd">    azimuthal plane through the source point and ``axis``.</span>

<span class="sd">    The motion parameter is the 1d rotation angle parameterizing source</span>
<span class="sd">    and detector positions simultaneously.</span>

<span class="sd">    In the standard configuration, the rotation axis is ``(0, 0, 1)``,</span>
<span class="sd">    the initial source-to-detector vector is ``(0, 1, 0)``, and the</span>
<span class="sd">    initial detector axes are ``[(1, 0, 0), (0, 0, 1)]``.</span>

<span class="sd">    For details, check `the online docs</span>
<span class="sd">    &lt;https://odlgroup.github.io/odl/guide/geometry_guide.html&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_default_config</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                           <span class="n">src_to_det_init</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">det_axes_init</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<div class="viewcode-block" id="ConeBeamGeometry.__init__">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span>
                 <span class="n">det_curvature_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">src_shift_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">det_shift_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        apart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the angle interval.</span>
<span class="sd">        dpart : 2-dim. `RectPartition`</span>
<span class="sd">            Partition of the detector parameter rectangle.</span>
<span class="sd">        src_radius : nonnegative float</span>
<span class="sd">            Radius of the source circle.</span>
<span class="sd">        det_radius : nonnegative float</span>
<span class="sd">            Radius of the detector circle. Must be nonzero if ``src_radius``</span>
<span class="sd">            is zero.</span>
<span class="sd">        det_curvature_radius :  2-tuple of nonnegative floats, optional</span>
<span class="sd">            Radius or radii of the detector curvature.</span>
<span class="sd">            If ``None``, a flat detector is used.</span>
<span class="sd">            If ``(r, None)`` or ``(r, float(&#39;inf&#39;))``, a cylindrical</span>
<span class="sd">            detector is used.</span>
<span class="sd">            If ``(r1, r2)``, a spherical detector is used.</span>
<span class="sd">        pitch : float, optional</span>
<span class="sd">            Constant distance along ``axis`` that a point on the helix</span>
<span class="sd">            traverses when increasing the angle parameter by ``2 * pi``.</span>
<span class="sd">            The default case ``pitch=0`` results in a circular cone</span>
<span class="sd">            beam geometry.</span>
<span class="sd">        axis : `array-like`, shape ``(3,)``, optional</span>
<span class="sd">            Vector defining the fixed rotation axis of this geometry.</span>
<span class="sd">        src_shift_func : callable, optional</span>
<span class="sd">            Function with signature ``src_shift_func(angle) -&gt; shift``</span>
<span class="sd">            returning a source shift for a given angle. Each shift</span>
<span class="sd">            is interpreted as a vector ``[shift_d, shift_t, shift_r]``, where</span>
<span class="sd">            &quot;d&quot;, &quot;t&quot; and &quot;r&quot; denote shifts along the following directions:</span>
<span class="sd">            detector-to-source, tangent to the rotation</span>
<span class="sd">            (projected on plane perpendicular to rotation axis),</span>
<span class="sd">            rotation axis.</span>
<span class="sd">        det_shift_func : callable, optional</span>
<span class="sd">            Function with signature ``det_shift_func(angle) -&gt; shift``</span>
<span class="sd">            returning a detector shift for a given angle. Each shift</span>
<span class="sd">            is interpreted as a vector ``[shift_d, shift_t, shift_r]``, where</span>
<span class="sd">            &quot;d&quot;, &quot;t&quot; and &quot;r&quot; denote shifts along the following directions:</span>
<span class="sd">            source-to-detector, tangent to the rotation</span>
<span class="sd">            (projected on plane perpendicular to rotation axis),</span>
<span class="sd">            rotation axis.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        offset_along_axis : float, optional</span>
<span class="sd">            Scalar offset along the ``axis`` at ``angle=0``, i.e., the</span>
<span class="sd">            translation along the axis at angle 0 is</span>
<span class="sd">            ``offset_along_axis * axis``.</span>
<span class="sd">            Default: 0.</span>
<span class="sd">        src_to_det_init : `array-like`, shape ``(3,)``, optional</span>
<span class="sd">            Initial state of the vector pointing from source to detector</span>
<span class="sd">            reference point. The zero vector is not allowed.</span>
<span class="sd">            The default depends on ``axis``, see Notes.</span>
<span class="sd">        det_axes_init : length-2-sequence of `array-like`&#39;s, optional</span>
<span class="sd">            Initial axes defining the detector orientation, provided as</span>
<span class="sd">            arrays with shape ``(3,)``.</span>
<span class="sd">            Default: depends on ``axis``, see Notes.</span>
<span class="sd">        translation : `array-like`, shape ``(3,)``, optional</span>
<span class="sd">            Global translation of the geometry. This is added last in any</span>
<span class="sd">            method that computes an absolute vector, e.g., `det_refpoint`,</span>
<span class="sd">            and also shifts the axis of rotation.</span>
<span class="sd">            Default: ``(0, 0, 0)``</span>
<span class="sd">        check_bounds : bool, optional</span>
<span class="sd">            If ``True``, methods computing vectors check input arguments.</span>
<span class="sd">            Checks are vectorized and add only a small overhead.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        In the default configuration, the rotation axis is ``(0, 0, 1)``,</span>
<span class="sd">        the initial source-to-detector direction is ``(0, 1, 0)``,</span>
<span class="sd">        and the default detector axes are ``[(1, 0, 0), (0, 0, 1)]``.</span>
<span class="sd">        If a different ``axis`` is provided, the new default initial</span>
<span class="sd">        position and the new default axes are the computed by rotating</span>
<span class="sd">        the original ones by a matrix that transforms ``(0, 0, 1)`` to the</span>
<span class="sd">        new (normalized) ``axis``. This matrix is calculated with the</span>
<span class="sd">        `rotation_matrix_from_to` function. Expressed in code, we have ::</span>

<span class="sd">            init_rot = rotation_matrix_from_to((0, 0, 1), axis)</span>
<span class="sd">            src_to_det_init = init_rot.dot((0, 1, 0))</span>
<span class="sd">            det_axes_init[0] = init_rot.dot((1, 0, 0))</span>
<span class="sd">            det_axes_init[1] = init_rot.dot((0, 0, 1))</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialization with default parameters and some (arbitrary)</span>
<span class="sd">        choices for pitch and radii:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-1, -1], [1, 1], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2)</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(0)</span>
<span class="sd">        array([ 0., -5.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([ 0., 10.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_position(2 * np.pi),</span>
<span class="sd">        ...             geom.src_position(0) + (0, 0, 2))  # z shift by pitch</span>
<span class="sd">        True</span>

<span class="sd">        Checking the default orientation:</span>

<span class="sd">        &gt;&gt;&gt; geom.axis</span>
<span class="sd">        array([ 0.,  0.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.src_to_det_init</span>
<span class="sd">        array([ 0.,  1.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_axes_init</span>
<span class="sd">        array([[ 1.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  1.]])</span>

<span class="sd">        Specifying curvature of the cylindrical detector:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition(</span>
<span class="sd">        ...     [-np.pi / 2, -1], [np.pi / 2, 1], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(apart, dpart,</span>
<span class="sd">        ...     src_radius=5, det_radius=10, det_curvature_radius=(10, None))</span>
<span class="sd">        &gt;&gt;&gt; # (10*sin(pi/2), 10*cos(pi/2), 1)</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.det_point_position(0, [ np.pi / 2, 1] ), 2)</span>
<span class="sd">        array([ 10., 0., 1.])</span>

<span class="sd">        Specifying curvature of the spherical detector:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-np.pi / 2, -np.pi / 4],</span>
<span class="sd">        ...                               [ np.pi / 2,  np.pi / 4], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(apart, dpart,</span>
<span class="sd">        ...     src_radius=5, det_radius=10, det_curvature_radius=(10, 10))</span>
<span class="sd">        &gt;&gt;&gt; # 10*( cos(pi/4), 0, sin(pi/4))</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.det_point_position(0, [ np.pi / 2, np.pi / 4] ), 2)</span>
<span class="sd">        array([ 7.07, 0.  , 7.07])</span>

<span class="sd">        Specifying an axis by default rotates the standard configuration</span>
<span class="sd">        to this position:</span>

<span class="sd">        &gt;&gt;&gt; e_x, e_y, e_z = np.eye(3)  # standard unit vectors</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2,</span>
<span class="sd">        ...     axis=(0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.axis, e_y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, -e_z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axes_init, (e_x, e_y))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2,</span>
<span class="sd">        ...     axis=(1, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.axis, e_x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, e_y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axes_init, (-e_z, e_x))</span>
<span class="sd">        True</span>

<span class="sd">        The initial source-to-detector vector and the detector axes can</span>
<span class="sd">        also be set explicitly:</span>

<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2,</span>
<span class="sd">        ...     src_to_det_init=(-1, 0, 0),</span>
<span class="sd">        ...     det_axes_init=((0, 1, 0), (0, 0, 1)))</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.axis, e_z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_to_det_init, -e_x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_axes_init, (e_y, e_z))</span>
<span class="sd">        True</span>

<span class="sd">        Specifying a flying focal spot and detector offset:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=5,</span>
<span class="sd">        ...     src_shift_func=lambda angle: odl.tomo.flying_focal_spot(</span>
<span class="sd">        ...         angle, apart=apart, shifts=[(0, 0.1, 0), (0, 0, 0.1)]),</span>
<span class="sd">        ...     det_shift_func=lambda angle: [0.0, 0.05, 0.03])</span>
<span class="sd">        &gt;&gt;&gt; geom.src_shift_func(geom.angles)</span>
<span class="sd">        array([[ 0. , 0.1, 0. ],</span>
<span class="sd">               [ 0. , 0. , 0.1],</span>
<span class="sd">               [ 0. , 0.1, 0. ],</span>
<span class="sd">               [ 0. , 0. , 0.1]])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_shift_func(geom.angles)</span>
<span class="sd">        [0.0, 0.05, 0.03]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span>
        <span class="n">default_src_to_det_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">]</span>
        <span class="n">default_det_axes_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;det_axes_init&#39;</span><span class="p">]</span>

        <span class="c1"># Handle initial coordinate system. We need to assign `None` to</span>
        <span class="c1"># the vectors first since we want to check that `init_matrix`</span>
        <span class="c1"># is not used together with those other parameters.</span>
        <span class="n">src_to_det_init</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">det_axes_init</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;det_axes_init&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Store some stuff for repr</span>
        <span class="k">if</span> <span class="n">src_to_det_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">,</span>
                                                   <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">det_axes_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_axes_init_arg</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">det_axes_init</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_det_axes_init_arg</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Compute the transformed system and the transition matrix. We</span>
        <span class="c1"># transform only those vectors that were not explicitly given.</span>
        <span class="n">vecs_to_transform</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">src_to_det_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vecs_to_transform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_src_to_det_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">det_axes_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vecs_to_transform</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">default_det_axes_init</span><span class="p">)</span>

        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="n">transform_system</span><span class="p">(</span>
            <span class="n">axis</span><span class="p">,</span> <span class="n">default_axis</span><span class="p">,</span> <span class="n">vecs_to_transform</span><span class="p">)</span>
        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">transformed_vecs</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">src_to_det_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">src_to_det_init</span> <span class="o">=</span> <span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">det_axes_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_axes_init</span> <span class="o">=</span> <span class="p">(</span><span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">transformed_vecs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">transformed_vecs</span> <span class="o">==</span> <span class="p">[]</span>

        <span class="c1"># Check and normalize `src_to_det_init`. Detector axes are</span>
        <span class="c1"># normalized in the detector class.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`src_to_det_init` cannot be zero&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">src_to_det_init</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">src_to_det_init</span><span class="p">)</span>

        <span class="c1"># Get stuff out of kwargs, otherwise upstream code complains</span>
        <span class="c1"># about unknown parameters (rightly so)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__pitch</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__offset_along_axis</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;offset_along_axis&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__src_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">src_radius</span><span class="p">)</span>

        <span class="c1"># Initialize stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__src_to_det_init</span> <span class="o">=</span> <span class="n">src_to_det_init</span>
        <span class="n">AxisOrientedGeometry</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># `check_bounds` is needed for both detector and geometry</span>
        <span class="n">check_bounds</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;check_bounds&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">det_curvature_radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">detector</span> <span class="o">=</span> <span class="n">Flat2dDetector</span><span class="p">(</span><span class="n">dpart</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">det_axes_init</span><span class="p">,</span>
                                      <span class="n">check_bounds</span><span class="o">=</span><span class="n">check_bounds</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">det_curvature_radius</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">detector</span> <span class="o">=</span> <span class="n">SphericalDetector</span><span class="p">(</span><span class="n">dpart</span><span class="p">,</span>
                                             <span class="n">radius</span><span class="o">=</span><span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                             <span class="n">axes</span><span class="o">=</span><span class="n">det_axes_init</span><span class="p">,</span>
                                             <span class="n">check_bounds</span><span class="o">=</span><span class="n">check_bounds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
                  <span class="ow">or</span> <span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)):</span>
                <span class="n">detector</span> <span class="o">=</span> <span class="n">CylindricalDetector</span><span class="p">(</span><span class="n">dpart</span><span class="p">,</span>
                                               <span class="n">radius</span><span class="o">=</span><span class="n">det_curvature_radius</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="n">axes</span><span class="o">=</span><span class="n">det_axes_init</span><span class="p">,</span>
                                               <span class="n">check_bounds</span><span class="o">=</span><span class="n">check_bounds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Curved detector with different &#39;</span>
                                          <span class="s1">&#39;curvature radii&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;det_curvature_radius </span><span class="si">{}</span><span class="s1"> must be a 2-tuple&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det_curvature_radius</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ConeBeamGeometry</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">motion_part</span><span class="o">=</span><span class="n">apart</span><span class="p">,</span> <span class="n">detector</span><span class="o">=</span><span class="n">detector</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Check parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source circle radius </span><span class="si">{}</span><span class="s1"> is negative&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">src_radius</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__det_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">det_radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;detector circle radius </span><span class="si">{}</span><span class="s1"> is negative&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">det_radius</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source and detector circle radii cannot both be &#39;</span>
                             <span class="s1">&#39;0&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`apart` has dimension </span><span class="si">{}</span><span class="s1">, expected 1&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">src_shift_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span> <span class="o">=</span> <span class="n">src_shift_func</span>

        <span class="k">if</span> <span class="n">det_shift_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span> <span class="o">=</span> <span class="n">det_shift_func</span></div>


<div class="viewcode-block" id="ConeBeamGeometry.frommatrix">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.frommatrix.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.frommatrix">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">frommatrix</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span> <span class="n">init_matrix</span><span class="p">,</span>
                   <span class="n">det_curvature_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pitch</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an instance of `ConeBeamGeometry` using a matrix.</span>

<span class="sd">        This alternative constructor uses a matrix to rotate and</span>
<span class="sd">        translate the default configuration. It is most useful when</span>
<span class="sd">        the transformation to be applied is already given as a matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        apart : 1-dim. `RectPartition`</span>
<span class="sd">            Partition of the parameter interval.</span>
<span class="sd">        dpart : 2-dim. `RectPartition`</span>
<span class="sd">            Partition of the detector parameter set.</span>
<span class="sd">        src_radius : nonnegative float</span>
<span class="sd">            Radius of the source circle.</span>
<span class="sd">        det_radius : nonnegative float</span>
<span class="sd">            Radius of the detector circle. Must be nonzero if ``src_radius``</span>
<span class="sd">            is zero.</span>
<span class="sd">        init_matrix : `array_like`, shape ``(3, 3)`` or ``(3, 4)``, optional</span>
<span class="sd">            Transformation matrix whose left ``(3, 3)`` block is multiplied</span>
<span class="sd">            with the default ``det_pos_init`` and ``det_axes_init`` to</span>
<span class="sd">            determine the new vectors. If present, the fourth column acts</span>
<span class="sd">            as a translation after the initial transformation.</span>
<span class="sd">            The resulting ``det_axes_init`` will be normalized.</span>
<span class="sd">        det_curvature_radius :  2-tuple of nonnegative floats, optional</span>
<span class="sd">            Radius or radii of the detector curvature.</span>
<span class="sd">            If ``None``, a flat detector is used.</span>
<span class="sd">            If ``(r, None)`` or ``(r, float(&#39;inf&#39;))``, a cylindrical</span>
<span class="sd">            detector is used.</span>
<span class="sd">            If ``(r1, r2)``, a spherical detector is used.</span>
<span class="sd">        pitch : float, optional</span>
<span class="sd">            Constant distance along the rotation axis that a point on the</span>
<span class="sd">            helix traverses when increasing the angle parameter by</span>
<span class="sd">            ``2 * pi``. The default case ``pitch=0`` results in a circular</span>
<span class="sd">            cone beam geometry.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Further keyword arguments passed to the class constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geometry : `ConeBeamGeometry`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Map unit vectors ``e_y -&gt; e_z`` and ``e_z -&gt; -e_y``, keeping the</span>
<span class="sd">        right-handedness:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-1, -1], [1, 1], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; matrix = np.array([[1, 0, 0],</span>
<span class="sd">        ...                    [0, 0, -1],</span>
<span class="sd">        ...                    [0, 1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry.frommatrix(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2,</span>
<span class="sd">        ...     init_matrix=matrix)</span>
<span class="sd">        &gt;&gt;&gt; geom.axis</span>
<span class="sd">        array([ 0., -1.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; geom.src_to_det_init</span>
<span class="sd">        array([ 0.,  0.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_axes_init</span>
<span class="sd">        array([[ 1.,  0.,  0.],</span>
<span class="sd">               [ 0., -1.,  0.]])</span>

<span class="sd">        Adding a translation with a fourth matrix column:</span>

<span class="sd">        &gt;&gt;&gt; matrix = np.array([[0, 0, -1, 0],</span>
<span class="sd">        ...                    [0, 1, 0, 1],</span>
<span class="sd">        ...                    [1, 0, 0, 1]])</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry.frommatrix(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2,</span>
<span class="sd">        ...     init_matrix=matrix)</span>
<span class="sd">        &gt;&gt;&gt; geom.translation</span>
<span class="sd">        array([ 0.,  1.,  1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)  # (0, 10, 0) + (0, 1, 1)</span>
<span class="sd">        array([  0.,  11.,   1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;src_to_det_init&#39;</span><span class="p">,</span> <span class="s1">&#39;det_axes_init&#39;</span><span class="p">,</span> <span class="s1">&#39;translation&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got unknown keyword argument </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="c1"># Get transformation and translation parts from `init_matrix`</span>
        <span class="n">init_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">init_matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`matrix` must have shape (3, 3) or (3, 4), &#39;</span>
                             <span class="s1">&#39;got array with shape </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">init_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">trafo_matrix</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">init_matrix</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="c1"># Transform the default vectors</span>
        <span class="n">default_axis</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span>
        <span class="n">default_src_to_det_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">]</span>
        <span class="n">default_det_axes_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;det_axes_init&#39;</span><span class="p">]</span>
        <span class="n">vecs_to_transform</span> <span class="o">=</span> <span class="p">(</span><span class="n">default_src_to_det_init</span><span class="p">,)</span> <span class="o">+</span> <span class="n">default_det_axes_init</span>
        <span class="n">transformed_vecs</span> <span class="o">=</span> <span class="n">transform_system</span><span class="p">(</span>
            <span class="n">default_axis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">vecs_to_transform</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="n">trafo_matrix</span><span class="p">)</span>

        <span class="c1"># Use the standard constructor with these vectors</span>
        <span class="n">axis</span><span class="p">,</span> <span class="n">src_to_det</span><span class="p">,</span> <span class="n">det_axis_0</span><span class="p">,</span> <span class="n">det_axis_1</span> <span class="o">=</span> <span class="n">transformed_vecs</span>
        <span class="k">if</span> <span class="n">translation</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;translation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">translation</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span>
                   <span class="n">det_curvature_radius</span><span class="o">=</span><span class="n">det_curvature_radius</span><span class="p">,</span>
                   <span class="n">pitch</span><span class="o">=</span><span class="n">pitch</span><span class="p">,</span>
                   <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                   <span class="n">src_to_det_init</span><span class="o">=</span><span class="n">src_to_det</span><span class="p">,</span>
                   <span class="n">det_axes_init</span><span class="o">=</span><span class="p">[</span><span class="n">det_axis_0</span><span class="p">,</span> <span class="n">det_axis_1</span><span class="p">],</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source circle radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector circle radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__det_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_curvature_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector curve radius of this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">detector</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constant vertical distance traversed in a full rotation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pitch</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_to_det_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial state of the vector pointing from source to detector</span>
<span class="sd">        reference point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_to_det_init</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_axes_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial axes defining the detector orientation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">offset_along_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scalar offset along ``axis`` at ``angle=0``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__offset_along_axis</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discrete angles given in this geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">motion_grid</span><span class="o">.</span><span class="n">coord_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">src_shift_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Source shifts in the geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__src_shift_func</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">det_shift_func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detector shifts in the geometry.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__det_shift_func</span>

<div class="viewcode-block" id="ConeBeamGeometry.det_axes">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.det_axes.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.det_axes">[docs]</a>
    <span class="k">def</span> <span class="nf">det_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the detector axes tuple at ``angle``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angles : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise rotation</span>
<span class="sd">            of the detector around `axis`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axes : `numpy.ndarray`</span>
<span class="sd">            Unit vectors along which the detector is aligned.</span>
<span class="sd">            If ``angle`` is a single parameter, the returned array has</span>
<span class="sd">            shape ``(2, 3)``, otherwise</span>
<span class="sd">            ``broadcast(*angles).shape + (2, 3)``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To get an array that enumerates the detector axes in the first</span>
<span class="sd">        dimension, move the second-to-last axis to the first position:</span>

<span class="sd">            axes = det_axes(angle)</span>
<span class="sd">            axes_enumeration = np.moveaxis(deriv, -2, 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Transpose to take dot along axis 1</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_axes_init</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># `axes` has shape (a, 3, 2), need to roll the last dimensions</span>
        <span class="c1"># to the second-to-last place</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConeBeamGeometry.det_refpoint">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.det_refpoint.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.det_refpoint">[docs]</a>
    <span class="k">def</span> <span class="nf">det_refpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the detector reference point position at ``angle``.</span>

<span class="sd">        For an angle ``phi``, the detector position is given by ::</span>

<span class="sd">            det_ref(phi) = translation +</span>
<span class="sd">                           rot_matrix(phi) * (det_rad * src_to_det_init) +</span>
<span class="sd">                           (offset_along_axis + pitch * phi) * axis +</span>
<span class="sd">                           detector_shift(phi)</span>

<span class="sd">        where ``src_to_det_init`` is the initial unit vector pointing</span>
<span class="sd">        from source to detector and ::</span>

<span class="sd">            detector_shift(phi) = rot_matrix(phi) *</span>
<span class="sd">                                  (shift1 * src_to_det_init +</span>
<span class="sd">                                  shift2 * cross(-src_to_det_init, axis))</span>
<span class="sd">                                  shift3 * axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise</span>
<span class="sd">            rotation of the detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        refpt : `numpy.ndarray`</span>
<span class="sd">            Vector(s) pointing from the origin to the detector reference</span>
<span class="sd">            point. If ``angle`` is a single parameter, the returned array</span>
<span class="sd">            has shape ``(3,)``, otherwise ``angle.shape + (3,)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        src_position</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        With default arguments, the detector starts at ``det_rad * e_y``</span>
<span class="sd">        and rotates to ``det_rad * (-e_x) + pitch/4 * e_z`` at</span>
<span class="sd">        90 degrees:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-1, -1], [1, 1], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2)</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(0)</span>
<span class="sd">        array([  0.,  10.,   0.])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.det_refpoint(np.pi / 2), [-10, 0, 0.5])</span>
<span class="sd">        True</span>

<span class="sd">        The method is vectorized, i.e., it can be called with multiple</span>
<span class="sd">        angles at once (or an n-dimensional array of angles):</span>

<span class="sd">        &gt;&gt;&gt; points = geom.det_refpoint([0, np.pi / 2])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[0], [0, 10, 0])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[1], [-10, 0, 0.5])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geom.det_refpoint(np.zeros((4, 5))).shape</span>
<span class="sd">        (4, 5, 3)</span>

<span class="sd">        Specifying detector offset:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=1,</span>
<span class="sd">        ...     det_shift_func=lambda angle:[0, 0.1, -0.1],</span>
<span class="sd">        ...     src_to_det_init=(0.71, -0.71, 0))</span>
<span class="sd">        &gt;&gt;&gt; geom.angles</span>
<span class="sd">        array([ 0.78539816,  2.35619449,  3.92699082,  5.49778714])</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.det_refpoint(geom.angles), 2)</span>
<span class="sd">        array([[ 1. ,  0.1, -0.1],</span>
<span class="sd">               [-0.1,  1. , -0.1],</span>
<span class="sd">               [-1. , -0.1, -0.1],</span>
<span class="sd">               [ 0.1, -1. , -0.1]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">squeeze_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="p">())</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">extra_dims</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">det_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">det_shift_func</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Initial vector from center of rotation to detector.</span>
        <span class="c1"># It can be computed this way since source and detector are at</span>
        <span class="c1"># maximum distance, i.e. the connecting line passes the center.</span>
        <span class="n">center_to_det_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span>
        <span class="c1"># shifting the detector according to det_shift_func</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">tangent</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>
        <span class="n">det_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">det_shifts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">)</span>
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">det_shifts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tangent</span><span class="p">))</span>
        <span class="n">center_to_det_init</span> <span class="o">=</span> <span class="n">center_to_det_init</span> <span class="o">+</span> <span class="n">det_shift</span>
        <span class="c1"># `circle_component` has shape (a, ndim)</span>
        <span class="n">circle_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,...j-&gt;...i&#39;</span><span class="p">,</span>
                                     <span class="n">rot_matrix</span><span class="p">,</span> <span class="n">center_to_det_init</span><span class="p">)</span>

        <span class="c1"># Increment along the rotation axis according to pitch and</span>
        <span class="c1"># offset_along_axis</span>
        <span class="c1"># `shift_along_axis` has shape angles.shape</span>
        <span class="n">shift_along_axis</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_along_axis</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span> <span class="o">*</span> <span class="n">angle</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">det_shifts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># Create outer product of `shift_along_axis` and `axis`, resulting</span>
        <span class="c1"># in shape (a, ndim)</span>
        <span class="n">pitch_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">shift_along_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Broadcast translation along extra dimensions</span>
        <span class="n">transl_slc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">extra_dims</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>
        <span class="n">refpt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="n">transl_slc</span><span class="p">]</span>
                 <span class="o">+</span> <span class="n">circle_component</span>
                 <span class="o">+</span> <span class="n">pitch_component</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">squeeze_out</span><span class="p">:</span>
            <span class="n">refpt</span> <span class="o">=</span> <span class="n">refpt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">refpt</span></div>


<div class="viewcode-block" id="ConeBeamGeometry.src_position">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.src_position.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.src_position">[docs]</a>
    <span class="k">def</span> <span class="nf">src_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the source position at ``angle``.</span>

<span class="sd">        For an angle ``phi``, the source position is given by ::</span>

<span class="sd">            src(phi) = translation +</span>
<span class="sd">                       rot_matrix(phi) * (-src_rad * src_to_det_init) +</span>
<span class="sd">                       (offset_along_axis + pitch * phi) * axis +</span>
<span class="sd">                       source_shift(phi)</span>

<span class="sd">        where ``src_to_det_init`` is the initial unit vector pointing</span>
<span class="sd">        from source to detector and ::</span>

<span class="sd">            source_shift(phi) = rot_matrix(phi) *</span>
<span class="sd">                                (shift1 * (-src_to_det_init) +</span>
<span class="sd">                                shift2 * cross(src_to_det_init, axis))</span>
<span class="sd">                                shift3 * axis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float or `array-like`</span>
<span class="sd">            Angle(s) in radians describing the counter-clockwise</span>
<span class="sd">            rotation of the detector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos : `numpy.ndarray`, shape (3,) or (num_angles, 3)</span>
<span class="sd">            Vector(s) pointing from the origin to the source position.</span>
<span class="sd">            If ``angle`` is a single parameter, the returned array has</span>
<span class="sd">            shape ``(3,)``, otherwise ``angle.shape + (3,)``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        det_refpoint</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        With default arguments, the source starts at ``src_rad * (-e_y)``</span>
<span class="sd">        and rotates to ``src_rad * e_x + pitch/4 * e_z`` at</span>
<span class="sd">        90 degrees:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4 * np.pi, 10)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-1, -1], [1, 1], (20, 20))</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart, src_radius=5, det_radius=10, pitch=2)</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(0)</span>
<span class="sd">        array([ 0., -5.,  0.])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(geom.src_position(np.pi / 2), [5, 0, 0.5])</span>
<span class="sd">        True</span>

<span class="sd">        The method is vectorized, i.e., it can be called with multiple</span>
<span class="sd">        angles at once:</span>

<span class="sd">        &gt;&gt;&gt; points = geom.src_position([0, np.pi / 2])</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[0], [0, -5, 0])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(points[1], [5, 0, 0.5])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geom.src_position(np.zeros((4, 5))).shape</span>
<span class="sd">        (4, 5, 3)</span>

<span class="sd">        Specifying flying focal spot:</span>

<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 2 * np.pi, 4)</span>
<span class="sd">        &gt;&gt;&gt; geom = ConeBeamGeometry(</span>
<span class="sd">        ...     apart, dpart,</span>
<span class="sd">        ...     src_radius=1, det_radius=5,</span>
<span class="sd">        ...     src_shift_func=lambda angle: odl.tomo.flying_focal_spot(</span>
<span class="sd">        ...         angle, apart=apart, shifts=[(0, 0.1, 0), (0, 0, 0.1)]),</span>
<span class="sd">        ...     src_to_det_init=(-0.71, 0.71, 0))</span>
<span class="sd">        &gt;&gt;&gt; geom.angles</span>
<span class="sd">        array([ 0.78539816,  2.35619449,  3.92699082,  5.49778714])</span>
<span class="sd">        &gt;&gt;&gt; np.round(geom.src_position(geom.angles), 2)</span>
<span class="sd">        array([[ 1. ,  0.1,  0. ],</span>
<span class="sd">               [ 0. ,  1. ,  0.1],</span>
<span class="sd">               [-1. , -0.1,  0. ],</span>
<span class="sd">               [-0. , -1. ,  0.1]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">squeeze_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">==</span> <span class="p">())</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">extra_dims</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">src_shifts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_shift_func</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="c1"># Initial vector from center of rotation to source.</span>
        <span class="c1"># It can be computed this way since source and detector are at</span>
        <span class="c1"># maximum distance, i.e. the connecting line passes the center.</span>
        <span class="n">center_to_src_init</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span>
        <span class="c1"># shifting the source according to ffs</span>
        <span class="n">tangent</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">tangent</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>
        <span class="n">ffs_shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">src_shifts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                       <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">src_to_det_init</span><span class="p">)</span>
                     <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">src_shifts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tangent</span><span class="p">))</span>
        <span class="n">center_to_src_init</span> <span class="o">=</span> <span class="n">center_to_src_init</span> <span class="o">+</span> <span class="n">ffs_shift</span>
        <span class="n">circle_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,...j-&gt;...i&#39;</span><span class="p">,</span>
                                     <span class="n">rot_matrix</span><span class="p">,</span> <span class="n">center_to_src_init</span><span class="p">)</span>

        <span class="c1"># Increment along the rotation axis according to pitch and</span>
        <span class="c1"># offset_along_axis</span>
        <span class="c1"># `shift_along_axis` has shape angles.shape</span>
        <span class="n">shift_along_axis</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_along_axis</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span> <span class="o">*</span> <span class="n">angle</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">src_shifts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># Create outer product of `shift_along_axis` and `axis`, resulting</span>
        <span class="c1"># in shape (a, ndim)</span>
        <span class="n">pitch_component</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">shift_along_axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Broadcast translation along extra dimensions</span>
        <span class="n">transl_slc</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">extra_dims</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>
        <span class="n">refpt</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">[</span><span class="n">transl_slc</span><span class="p">]</span>
                 <span class="o">+</span> <span class="n">circle_component</span>
                 <span class="o">+</span> <span class="n">pitch_component</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">squeeze_out</span><span class="p">:</span>
            <span class="n">refpt</span> <span class="o">=</span> <span class="n">refpt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">refpt</span></div>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">motion_partition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_partition</span><span class="p">]</span>
        <span class="n">optargs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;src_radius&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;det_radius&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                   <span class="p">(</span><span class="s1">&#39;pitch&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_config</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]):</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>

        <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;offset_along_axis&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_along_axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;src_to_det_init&#39;</span><span class="p">,</span>
                            <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span><span class="p">),</span>
                            <span class="kc">None</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det_axes_init_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="s1">&#39;det_axes_init&#39;</span><span class="p">,</span>
                 <span class="nb">tuple</span><span class="p">(</span><span class="n">array_str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_det_axes_init_arg</span><span class="p">),</span>
                 <span class="kc">None</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">optargs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s1">&#39;translation&#39;</span><span class="p">,</span> <span class="n">array_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>

        <span class="n">sig_str</span> <span class="o">=</span> <span class="n">signature_string</span><span class="p">(</span><span class="n">posargs</span><span class="p">,</span> <span class="n">optargs</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">indent</span><span class="p">(</span><span class="n">sig_str</span><span class="p">))</span>

<div class="viewcode-block" id="ConeBeamGeometry.__getitem__">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.ConeBeamGeometry.__getitem__.html#odl.tomo.geometry.conebeam.ConeBeamGeometry.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return self[indices].</span>

<span class="sd">        This is defined by ::</span>

<span class="sd">            self[indices].partition == self.partition[indices]</span>

<span class="sd">        where all other parameters are the same.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; apart = odl.uniform_partition(0, 4, 4)</span>
<span class="sd">        &gt;&gt;&gt; dpart = odl.uniform_partition([-1, -1], [1, 1], [20, 20])</span>
<span class="sd">        &gt;&gt;&gt; geom = odl.tomo.ConeBeamGeometry(apart, dpart, 50, 100, pitch=2)</span>

<span class="sd">        Extract sub-geometry with every second angle:</span>

<span class="sd">        &gt;&gt;&gt; geom[::2]</span>
<span class="sd">        ConeBeamGeometry(</span>
<span class="sd">            nonuniform_partition(</span>
<span class="sd">                [ 0.5,  2.5],</span>
<span class="sd">                min_pt=0.0, max_pt=4.0</span>
<span class="sd">            ),</span>
<span class="sd">            uniform_partition([-1., -1.], [ 1.,  1.], (20, 20)),</span>
<span class="sd">            src_radius=50.0,</span>
<span class="sd">            det_radius=100.0,</span>
<span class="sd">            pitch=2.0</span>
<span class="sd">        )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">part</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">apart</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dpart</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">byaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">ConeBeamGeometry</span><span class="p">(</span><span class="n">apart</span><span class="p">,</span> <span class="n">dpart</span><span class="p">,</span>
                                <span class="n">src_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src_radius</span><span class="p">,</span>
                                <span class="n">det_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_radius</span><span class="p">,</span>
                                <span class="n">det_curvature_radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_curvature_radius</span><span class="p">,</span>
                                <span class="n">pitch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span>
                                <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">,</span>
                                <span class="n">offset_along_axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_along_axis</span><span class="p">,</span>
                                <span class="n">src_to_det_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_src_to_det_init_arg</span><span class="p">,</span>
                                <span class="n">det_axes_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_det_axes_init_arg</span><span class="p">,</span>
                                <span class="n">src_shift_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">src_shift_func</span><span class="p">,</span>
                                <span class="n">det_shift_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">det_shift_func</span><span class="p">,</span>
                                <span class="n">translation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">translation</span><span class="p">)</span></div>


    <span class="c1"># Manually override the abstract method in `Geometry` since it&#39;s found</span>
    <span class="c1"># first</span>
    <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">AxisOrientedGeometry</span><span class="o">.</span><span class="n">rotation_matrix</span></div>



<div class="viewcode-block" id="cone_beam_geometry">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.cone_beam_geometry.html#odl.tomo.geometry.conebeam.cone_beam_geometry">[docs]</a>
<span class="k">def</span> <span class="nf">cone_beam_geometry</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span> <span class="n">num_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">short_scan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">det_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a default fan or cone beam geometry from ``space``.</span>

<span class="sd">    This function is intended for simple test cases where users do not</span>
<span class="sd">    need the full flexibility of the geometries, but simply wants a</span>
<span class="sd">    geometry that works.</span>

<span class="sd">    The geometry returned by this function has equidistant angles</span>
<span class="sd">    that lie (strictly) between 0 and either ``2 * pi`` (full scan)</span>
<span class="sd">    or ``pi + fan_angle`` (short scan).</span>
<span class="sd">    The detector is centered around 0, and its size is chosen such that</span>
<span class="sd">    the whole ``space`` is covered with lines.</span>

<span class="sd">    The number of angles and detector elements is chosen such that</span>
<span class="sd">    the resulting sinogram is fully sampled according to the</span>
<span class="sd">    Nyquist criterion, which in general results in a very large number of</span>
<span class="sd">    samples. In particular, a ``space`` that is not centered at the origin</span>
<span class="sd">    can result in very large detectors since the latter is always</span>
<span class="sd">    origin-centered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `DiscretizedSpace`</span>
<span class="sd">        Reconstruction space, the space of the volumetric data to be</span>
<span class="sd">        projected. Must be 2- or 3-dimensional.</span>
<span class="sd">    src_radius : nonnegative float</span>
<span class="sd">        Radius of the source circle. Must be larger than the radius of</span>
<span class="sd">        the smallest vertical cylinder containing ``space.domain``,</span>
<span class="sd">        i.e., the source must be outside the volume for all rotations.</span>
<span class="sd">    det_radius : nonnegative float</span>
<span class="sd">        Radius of the detector circle.</span>
<span class="sd">    short_scan : bool, optional</span>
<span class="sd">        Use the minimum required angular range ``[0, pi + fan_angle]``.</span>
<span class="sd">        For ``True``, the `parker_weighting` should be used in FBP.</span>
<span class="sd">        By default, the range ``[0, 2 * pi]`` is used.</span>
<span class="sd">    num_angles : int, optional</span>
<span class="sd">        Number of angles.</span>
<span class="sd">        Default: Enough to fully sample the data, see Notes.</span>
<span class="sd">    det_shape : int or sequence of ints, optional</span>
<span class="sd">        Number of detector pixels.</span>
<span class="sd">        Default: Enough to fully sample the data, see Notes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    geometry : `DivergentBeamGeometry`</span>
<span class="sd">        Projection geometry with equidistant angles and zero-centered</span>
<span class="sd">        detector as determined by sampling criteria.</span>

<span class="sd">            - If ``space`` is 2D, the result is a `FanBeamGeometry`.</span>
<span class="sd">            - If ``space`` is 3D, the result is a `ConeBeamGeometry`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a fan beam geometry from a 2d space:</span>

<span class="sd">    &gt;&gt;&gt; space = odl.uniform_discr([-1, -1], [1, 1], (20, 20))</span>
<span class="sd">    &gt;&gt;&gt; geometry = cone_beam_geometry(space, src_radius=5, det_radius=5)</span>
<span class="sd">    &gt;&gt;&gt; geometry.angles.size</span>
<span class="sd">    78</span>
<span class="sd">    &gt;&gt;&gt; geometry.detector.size</span>
<span class="sd">    57</span>

<span class="sd">    For a short scan geometry (from 0 to ``pi + fan_angle``), the</span>
<span class="sd">    ``short_scan`` flag can be set, resulting in a smaller number of</span>
<span class="sd">    angles:</span>

<span class="sd">    &gt;&gt;&gt; geometry = cone_beam_geometry(space, src_radius=5, det_radius=5,</span>
<span class="sd">    ...                               short_scan=True)</span>
<span class="sd">    &gt;&gt;&gt; geometry.angles.size</span>
<span class="sd">    46</span>

<span class="sd">    If the source is close to the object, the detector becomes larger due</span>
<span class="sd">    to more magnification:</span>

<span class="sd">    &gt;&gt;&gt; geometry = cone_beam_geometry(space, src_radius=3, det_radius=9)</span>
<span class="sd">    &gt;&gt;&gt; geometry.angles.size</span>
<span class="sd">    80</span>
<span class="sd">    &gt;&gt;&gt; geometry.detector.size</span>
<span class="sd">    105</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    According to [NW2001]_, pages 75--76, a function</span>
<span class="sd">    :math:`f : \mathbb{R}^2 \to \mathbb{R}` that has compact support</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \| &gt; \rho  \implies f(x) = 0,</span>

<span class="sd">    and is essentially bandlimited</span>

<span class="sd">    .. math::</span>
<span class="sd">       \| \xi \| &gt; \Omega \implies \hat{f}(\xi) \approx 0,</span>

<span class="sd">    can be fully reconstructed from a fan beam ray transform with</span>
<span class="sd">    source-detector distance :math:`r` (assuming all detector</span>
<span class="sd">    points have the same distance to the source) if (1) the projection</span>
<span class="sd">    angles are sampled with a spacing of :math:`\Delta \psi` such that</span>

<span class="sd">    .. math::</span>
<span class="sd">        \Delta \psi \leq \frac{r + \rho}{r}\, \frac{\pi}{\rho \Omega},</span>

<span class="sd">    and (2) the detector is sampled with an angular interval</span>
<span class="sd">    :math:`\Delta \alpha` that satisfies</span>

<span class="sd">    .. math::</span>
<span class="sd">        \Delta \alpha \leq \frac{\pi}{r \Omega}.</span>

<span class="sd">    For a flat detector, the angular interval is smallest in the center</span>
<span class="sd">    of the fan and largest at the boundaries. The worst-case relation</span>
<span class="sd">    between the linear and angular sampling intervals are</span>

<span class="sd">    .. math::</span>
<span class="sd">        \Delta s = R \Delta \alpha, \quad R^2 = r^2 + (w / 2)^2,</span>

<span class="sd">    where :math:`w` is the width of the detector.</span>
<span class="sd">    Thus, to satisfy the angular detector condition one can choose</span>

<span class="sd">    .. math::</span>
<span class="sd">        \Delta s \leq \frac{\pi \sqrt{r^2 + (w / 2)^2}}{r \Omega}.</span>

<span class="sd">    The geometry returned by this function satisfies these conditions exactly.</span>

<span class="sd">    If the domain is 3-dimensional, a circular cone beam geometry is</span>
<span class="sd">    created with the third coordinate axis as rotation axis. This does,</span>
<span class="sd">    of course, not yield complete data, but is equivalent to the</span>
<span class="sd">    2D fan beam case in the :math:`z = 0` slice. The vertical size of</span>
<span class="sd">    the detector is chosen such that it covers the object vertically</span>
<span class="sd">    with rays, using a containing cuboid</span>
<span class="sd">    :math:`[-\rho, \rho]^2 \times [z_{\mathrm{min}}, z_{\mathrm{min}}]`</span>
<span class="sd">    to compute the cone angle.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [NW2001] Natterer, F and Wuebbeling, F.</span>
<span class="sd">       *Mathematical Methods in Image Reconstruction*.</span>
<span class="sd">       SIAM, 2001.</span>
<span class="sd">       https://dx.doi.org/10.1137/1.9780898718324</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find maximum distance from rotation axis</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">corners</span><span class="p">()[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Find default values according to Nyquist criterion.</span>

    <span class="c1"># We assume that the function is bandlimited by a wave along the x or y</span>
    <span class="c1"># axis. The highest frequency we can measure is then a standing wave with</span>
    <span class="c1"># period of twice the inter-node distance.</span>
    <span class="n">min_side</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">min_side</span>

    <span class="c1"># Compute minimum width of the detector to cover the object. The relation</span>
    <span class="c1"># used here is (w/2)/(rs+rd) = rho/rs since both are equal to tan(alpha),</span>
    <span class="c1"># where alpha is the half fan angle.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">src_radius</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rs</span> <span class="o">&lt;=</span> <span class="n">rho</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source too close to the object, resulting in &#39;</span>
                         <span class="s1">&#39;infinite detector for full coverage&#39;</span><span class="p">)</span>
    <span class="n">rd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">det_radius</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">src_radius</span> <span class="o">+</span> <span class="n">det_radius</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span><span class="p">)</span> <span class="o">/</span> <span class="n">rs</span>

    <span class="c1"># Compute minimum number of pixels given the constraint on the</span>
    <span class="c1"># sampling interval and the computed width</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># length of the boundary ray to the flat detector</span>
    <span class="n">num_px_horiz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rb</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">space</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">det_min_pt</span> <span class="o">=</span> <span class="o">-</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">det_max_pt</span> <span class="o">=</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">det_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_shape</span> <span class="o">=</span> <span class="n">num_px_horiz</span>
    <span class="k">elif</span> <span class="n">space</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># Compute number of vertical pixels required to cover the object,</span>
        <span class="c1"># using the same sampling interval vertically as horizontally.</span>
        <span class="c1"># The reasoning is the same as for the computation of w.</span>

        <span class="c1"># Minimum distance of the containing cuboid edges to the source</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">rs</span> <span class="o">-</span> <span class="n">rho</span>
        <span class="c1"># Take angle of the rays going through the top and bottom corners</span>
        <span class="c1"># in that edge</span>
        <span class="n">half_cone_angle</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">min_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist</span><span class="p">),</span>
                              <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">max_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">dist</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">half_cone_angle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span><span class="p">)</span>

        <span class="c1"># Use the vertical spacing from the reco space, corrected for</span>
        <span class="c1"># magnification at the &quot;back&quot; of the object, i.e., where it is</span>
        <span class="c1"># minimal</span>
        <span class="n">min_mag</span> <span class="o">=</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">delta_h</span> <span class="o">=</span> <span class="n">min_mag</span> <span class="o">*</span> <span class="n">space</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">num_px_vert</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="n">delta_h</span><span class="p">))</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">num_px_vert</span> <span class="o">*</span> <span class="n">delta_h</span>  <span class="c1"># make multiple of spacing</span>

        <span class="n">det_min_pt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">det_max_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">det_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">det_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_px_horiz</span><span class="p">,</span> <span class="n">num_px_vert</span><span class="p">]</span>

    <span class="n">fan_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">rho</span> <span class="o">/</span> <span class="n">rs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">short_scan</span><span class="p">:</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">fan_angle</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="k">if</span> <span class="n">num_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_angles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_angle</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                                 <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)))</span>

    <span class="n">angle_partition</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_angle</span><span class="p">,</span> <span class="n">num_angles</span><span class="p">)</span>
    <span class="n">det_partition</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="n">det_min_pt</span><span class="p">,</span> <span class="n">det_max_pt</span><span class="p">,</span> <span class="n">det_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">space</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FanBeamGeometry</span><span class="p">(</span><span class="n">angle_partition</span><span class="p">,</span> <span class="n">det_partition</span><span class="p">,</span>
                               <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">space</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ConeBeamGeometry</span><span class="p">(</span><span class="n">angle_partition</span><span class="p">,</span> <span class="n">det_partition</span><span class="p">,</span>
                                <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;``space.ndim`` must be 2 or 3.&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="helical_geometry">
<a class="viewcode-back" href="../../../../generated/odl.tomo.geometry.conebeam.helical_geometry.html#odl.tomo.geometry.conebeam.helical_geometry">[docs]</a>
<span class="k">def</span> <span class="nf">helical_geometry</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span> <span class="n">num_turns</span><span class="p">,</span>
                     <span class="n">n_pi</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">det_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a default helical geometry from ``space``.</span>

<span class="sd">    This function is intended for simple test cases where users do not</span>
<span class="sd">    need the full flexibility of the geometries, but simply wants a</span>
<span class="sd">    geometry that works.</span>

<span class="sd">    The geometry returned by this function has equidistant angles</span>
<span class="sd">    that lie (strictly) between 0 and ``2 * pi * num_turns``.</span>
<span class="sd">    The detector is centered around 0, and its size is chosen such that</span>
<span class="sd">    the whole ``space`` is covered with lines.</span>

<span class="sd">    The number of angles and detector elements is chosen such that</span>
<span class="sd">    the resulting sinogram is fully sampled according to the</span>
<span class="sd">    Nyquist criterion, which in general results in a very large number of</span>
<span class="sd">    samples. In particular, a ``space`` that is not centered at the origin</span>
<span class="sd">    can result in very large detectors since the latter is always</span>
<span class="sd">    origin-centered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    space : `DiscretizedSpace`</span>
<span class="sd">        Reconstruction space, the space of the volumetric data to be</span>
<span class="sd">        projected. Must be 3-dimensional.</span>
<span class="sd">    src_radius : nonnegative float</span>
<span class="sd">        Radius of the source circle. Must be larger than the radius of</span>
<span class="sd">        the smallest vertical cylinder containing ``space.domain``,</span>
<span class="sd">        i.e., the source must be outside the volume for all rotations.</span>
<span class="sd">    det_radius : nonnegative float</span>
<span class="sd">        Radius of the detector circle.</span>
<span class="sd">    num_turns : positive float</span>
<span class="sd">        Total number of helical turns.</span>
<span class="sd">    num_angles : int, optional</span>
<span class="sd">        Number of angles.</span>
<span class="sd">        Default: Enough to fully sample the data, see Notes.</span>
<span class="sd">    n_pi : odd int, optional</span>
<span class="sd">        Total number of half rotations to include in the window. Values larger</span>
<span class="sd">        than 1 should be used if the pitch is much smaller than the detector</span>
<span class="sd">        height.</span>
<span class="sd">    det_shape : int or sequence of ints, optional</span>
<span class="sd">        Number of detector pixels.</span>
<span class="sd">        Default: Enough to fully sample the data, see Notes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    geometry : `ConeBeamGeometry`</span>
<span class="sd">        Projection geometry with equidistant angles and zero-centered</span>
<span class="sd">        detector as determined by sampling criteria.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a helical beam geometry from space:</span>

<span class="sd">    &gt;&gt;&gt; space = odl.uniform_discr([-1, -1, -1], [1, 1, 1], (20, 20, 20))</span>
<span class="sd">    &gt;&gt;&gt; geometry = helical_geometry(space, src_radius=5, det_radius=5,</span>
<span class="sd">    ...                             num_turns=3)</span>
<span class="sd">    &gt;&gt;&gt; geometry.angles.size</span>
<span class="sd">    234</span>
<span class="sd">    &gt;&gt;&gt; geometry.detector.shape</span>
<span class="sd">    (57, 9)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the &quot;fan beam direction&quot;, the sampling exactly follows the</span>
<span class="sd">    two-dimensional case see `cone_beam_geometry` for a description.</span>

<span class="sd">    In the &quot;axial direction&quot;, e.g. along the [0, 0, 1] axis, the geometry is</span>
<span class="sd">    sampled according to two criteria. First, the bounds of the detector</span>
<span class="sd">    are chosen to satisfy the tuy condition.</span>
<span class="sd">    See `[TSS1998]`_ for a full description.</span>

<span class="sd">    Second, the sampling rate is selected according to the nyquist criterion</span>
<span class="sd">    to give a full sampling. This is done by sampling such that the pixel</span>
<span class="sd">    size is half of the size of the projection of the smallest voxel onto the</span>
<span class="sd">    detector.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [TSS1998] Tam, K C, Samarasekera, S and Sauer, F.</span>
<span class="sd">    *Exact cone beam CT with a spiral scan*.</span>
<span class="sd">    Physics in Medicine &amp; Biology 4 (1998), p 1015.</span>

<span class="sd">    .. _[TSS1998]: https://dx.doi.org/10.1088/0031-9155/43/4/028</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find maximum distance from rotation axis</span>
    <span class="n">corners</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">corners</span><span class="p">()[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">corners</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">offset_along_axis</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">min_pt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">pitch</span> <span class="o">=</span> <span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_turns</span>

    <span class="c1"># Find default values according to Nyquist criterion.</span>

    <span class="c1"># We assume that the function is bandlimited by a wave along the x or y</span>
    <span class="c1"># axis. The highest frequency we can measure is then a standing wave with</span>
    <span class="c1"># period of twice the inter-node distance.</span>
    <span class="n">min_side</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">min_side</span>

    <span class="c1"># Compute minimum width of the detector to cover the object. The relation</span>
    <span class="c1"># used here is (w/2)/(rs+rd) = rho/rs since both are equal to tan(alpha),</span>
    <span class="c1"># where alpha is the half fan angle.</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">src_radius</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rs</span> <span class="o">&lt;=</span> <span class="n">rho</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;source too close to the object, resulting in &#39;</span>
                         <span class="s1">&#39;infinite detector for full coverage&#39;</span><span class="p">)</span>
    <span class="n">rd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">det_radius</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span><span class="p">)</span> <span class="o">/</span> <span class="n">rs</span>

    <span class="c1"># Compute minimum number of pixels given the constraint on the</span>
    <span class="c1"># sampling interval and the computed width</span>
    <span class="n">rb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hypot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># length of the boundary ray to the flat detector</span>
    <span class="n">num_px_horiz</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rb</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Compute lower and upper bound needed to fully sample the object.</span>
    <span class="c1"># In particular, since in a helical geometry several turns are used,</span>
    <span class="c1"># this is selected so that the field of view of two opposing projections,</span>
    <span class="c1"># separated by theta = 180 deg, overlap, but as little as possible.</span>
    <span class="c1"># See `tam_danielson_window` for more information.</span>
    <span class="n">h_axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">pitch</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span>
              <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">rho</span> <span class="o">/</span> <span class="n">src_radius</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
              <span class="p">(</span><span class="n">n_pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="o">-</span><span class="n">rho</span> <span class="o">/</span> <span class="n">src_radius</span><span class="p">)))</span>
    <span class="n">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h_axis</span> <span class="o">*</span> <span class="p">(</span><span class="n">rs</span> <span class="o">+</span> <span class="n">rd</span><span class="p">)</span> <span class="o">/</span> <span class="n">rs</span>

    <span class="c1"># Compute number of pixels</span>
    <span class="n">min_mag</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">rs</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">space</span><span class="o">.</span><span class="n">partition</span><span class="o">.</span><span class="n">cell_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">min_mag</span>
    <span class="n">num_px_vert</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">h</span> <span class="o">/</span> <span class="n">dh</span><span class="p">))</span>

    <span class="n">det_min_pt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">det_max_pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">det_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">det_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">num_px_horiz</span><span class="p">,</span> <span class="n">num_px_vert</span><span class="p">]</span>

    <span class="n">max_angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">num_turns</span>

    <span class="k">if</span> <span class="n">num_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_angles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_angle</span> <span class="o">*</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                                 <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)))</span>

    <span class="n">angle_partition</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_angle</span><span class="p">,</span> <span class="n">num_angles</span><span class="p">)</span>
    <span class="n">det_partition</span> <span class="o">=</span> <span class="n">uniform_partition</span><span class="p">(</span><span class="n">det_min_pt</span><span class="p">,</span> <span class="n">det_max_pt</span><span class="p">,</span> <span class="n">det_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ConeBeamGeometry</span><span class="p">(</span><span class="n">angle_partition</span><span class="p">,</span> <span class="n">det_partition</span><span class="p">,</span>
                            <span class="n">src_radius</span><span class="p">,</span> <span class="n">det_radius</span><span class="p">,</span>
                            <span class="n">offset_along_axis</span><span class="o">=</span><span class="n">offset_along_axis</span><span class="p">,</span>
                            <span class="n">pitch</span><span class="o">=</span><span class="n">pitch</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2020 The ODL Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>