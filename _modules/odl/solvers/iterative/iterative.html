

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.solvers.iterative.iterative &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.solvers.iterative.iterative</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.solvers.iterative.iterative</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2019 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Simple iterative type optimization schemes.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">next</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.operator</span> <span class="kn">import</span> <span class="n">IdentityOperator</span><span class="p">,</span> <span class="n">OperatorComp</span><span class="p">,</span> <span class="n">OperatorSum</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">normalized_scalar_param_list</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;landweber&#39;</span><span class="p">,</span> <span class="s1">&#39;conjugate_gradient&#39;</span><span class="p">,</span> <span class="s1">&#39;conjugate_gradient_normal&#39;</span><span class="p">,</span>
           <span class="s1">&#39;gauss_newton&#39;</span><span class="p">,</span> <span class="s1">&#39;kaczmarz&#39;</span><span class="p">)</span>


<span class="c1"># TODO: update all docs</span>


<div class="viewcode-block" id="landweber"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.landweber.html#odl.solvers.iterative.iterative.landweber">[docs]</a><span class="k">def</span> <span class="nf">landweber</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Optimized implementation of Landweber&#39;s method.</span>

<span class="sd">    Solves the inverse problem::</span>

<span class="sd">        A(x) = rhs</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : `Operator`</span>
<span class="sd">        Operator in the inverse problem. ``op.derivative(x).adjoint`` must be</span>
<span class="sd">        well-defined for ``x`` in the operator domain.</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Element to which the result is written. Its initial value is</span>
<span class="sd">        used as starting point of the iteration, and its values are</span>
<span class="sd">        updated in each iteration step.</span>
<span class="sd">    rhs : ``op.range`` element</span>
<span class="sd">        Right-hand side of the equation defining the inverse problem.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    omega : positive float, optional</span>
<span class="sd">        Relaxation parameter in the iteration.</span>
<span class="sd">        Default: ``1 / op.norm(estimate=True) ** 2``</span>
<span class="sd">    projection : callable, optional</span>
<span class="sd">        Function that can be used to modify the iterates in each iteration,</span>
<span class="sd">        for example enforcing positivity. The function should take one</span>
<span class="sd">        argument and modify it in-place.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Object executing code per iteration, e.g. plotting each iterate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method calculates an approximate least-squares solution of</span>
<span class="sd">    the inverse problem of the first kind</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{A} (x) = y,</span>

<span class="sd">    for a given :math:`y\in \mathcal{Y}`, i.e. an approximate</span>
<span class="sd">    solution :math:`x^*` to</span>

<span class="sd">    .. math::</span>
<span class="sd">        \min_{x\in \mathcal{X}} \| \mathcal{A}(x) - y \|_{\mathcal{Y}}^2</span>

<span class="sd">    for a (Frechet-) differentiable operator</span>
<span class="sd">    :math:`\mathcal{A}: \mathcal{X} \to \mathcal{Y}` between Hilbert</span>
<span class="sd">    spaces :math:`\mathcal{X}` and :math:`\mathcal{Y}`. The method</span>
<span class="sd">    starts from an initial guess :math:`x_0` and uses the</span>
<span class="sd">    iteration</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_{k+1} = x_k -</span>
<span class="sd">                  \omega \ \partial \mathcal{A}(x)^* (\mathcal{A}(x_k) - y),</span>

<span class="sd">    where :math:`\partial \mathcal{A}(x)` is the Frechet derivative</span>
<span class="sd">    of :math:`\mathcal{A}` at :math:`x` and :math:`\omega` is a</span>
<span class="sd">    relaxation parameter. For linear problems, a choice</span>
<span class="sd">    :math:`0 &lt; \omega &lt; 2/\lVert \mathcal{A}^2\rVert` guarantees</span>
<span class="sd">    convergence, where :math:`\lVert\mathcal{A}\rVert` stands for the</span>
<span class="sd">    operator norm of :math:`\mathcal{A}`.</span>

<span class="sd">    Users may also optionally provide a projection to project each</span>
<span class="sd">    iterate onto some subset. For example enforcing positivity.</span>

<span class="sd">    This implementation uses a minimum amount of memory copies by</span>
<span class="sd">    applying re-usable temporaries and in-place evaluation.</span>

<span class="sd">    The method is also described in a</span>
<span class="sd">    `Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Landweber_iteration&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add a book reference</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` </span><span class="si">{!r}</span><span class="s1"> is not in the domain of `op` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">op</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">estimate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># Reusable temporaries</span>
    <span class="n">tmp_ran</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">tmp_dom</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_ran</span><span class="p">)</span>
        <span class="n">tmp_ran</span> <span class="o">-=</span> <span class="n">rhs</span>
        <span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">tmp_ran</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_dom</span><span class="p">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="p">,</span> <span class="n">tmp_dom</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="conjugate_gradient"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.conjugate_gradient.html#odl.solvers.iterative.iterative.conjugate_gradient">[docs]</a><span class="k">def</span> <span class="nf">conjugate_gradient</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimized implementation of CG for self-adjoint operators.</span>

<span class="sd">    This method solves the inverse problem (of the first kind)::</span>

<span class="sd">        A(x) = y</span>

<span class="sd">    for a linear and self-adjoint `Operator` ``A``.</span>

<span class="sd">    It uses a minimum amount of memory copies by applying re-usable</span>
<span class="sd">    temporaries and in-place evaluation.</span>

<span class="sd">    The method is described (for linear systems) in a</span>
<span class="sd">    `Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Conjugate_gradient_method&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : linear `Operator`</span>
<span class="sd">        Operator in the inverse problem. It must be linear and</span>
<span class="sd">        self-adjoint. This implies in particular that its domain and</span>
<span class="sd">        range are equal.</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Element to which the result is written. Its initial value is</span>
<span class="sd">        used as starting point of the iteration, and its values are</span>
<span class="sd">        updated in each iteration step.</span>
<span class="sd">    rhs : ``op.range`` element</span>
<span class="sd">        Right-hand side of the equation defining the inverse problem.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Object executing code per iteration, e.g. plotting each iterate.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    conjugate_gradient_normal : Solver for nonsymmetric matrices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add a book reference</span>
    <span class="c1"># TODO: update doc</span>

    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;operator needs to be self-adjoint&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` </span><span class="si">{!r}</span><span class="s1"> is not in the domain of `op` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>       <span class="c1"># r = rhs - A x</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>  <span class="c1"># Extra storage for storing A x</span>

    <span class="n">sqnorm_r_old</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># Only recalculate norm after update</span>

    <span class="k">if</span> <span class="n">sqnorm_r_old</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Return if no step forward</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">op</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># d = A p</span>

        <span class="n">inner_p_d</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inner_p_d</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># Return if step is 0</span>
            <span class="k">return</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">sqnorm_r_old</span> <span class="o">/</span> <span class="n">inner_p_d</span>

        <span class="n">x</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>            <span class="c1"># x = x + alpha*p</span>
        <span class="n">r</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>           <span class="c1"># r = r - alpha*d</span>

        <span class="n">sqnorm_r_new</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="n">beta</span> <span class="o">=</span> <span class="n">sqnorm_r_new</span> <span class="o">/</span> <span class="n">sqnorm_r_old</span>
        <span class="n">sqnorm_r_old</span> <span class="o">=</span> <span class="n">sqnorm_r_new</span>

        <span class="n">p</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>                       <span class="c1"># p = s + b * p</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="conjugate_gradient_normal"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.conjugate_gradient_normal.html#odl.solvers.iterative.iterative.conjugate_gradient_normal">[docs]</a><span class="k">def</span> <span class="nf">conjugate_gradient_normal</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimized implementation of CG for the normal equation.</span>

<span class="sd">    This method solves the inverse problem (of the first kind) ::</span>

<span class="sd">        A(x) == rhs</span>

<span class="sd">    with a linear `Operator` ``A`` by looking at the normal equation ::</span>

<span class="sd">        A.adjoint(A(x)) == A.adjoint(rhs)</span>

<span class="sd">    It uses a minimum amount of memory copies by applying re-usable</span>
<span class="sd">    temporaries and in-place evaluation.</span>

<span class="sd">    The method is described (for linear systems) in a</span>
<span class="sd">    `Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Conjugate_gradient_method#\</span>
<span class="sd">Conjugate_gradient_on_the_normal_equations&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : `Operator`</span>
<span class="sd">        Operator in the inverse problem. If not linear, it must have</span>
<span class="sd">        an implementation of `Operator.derivative`, which</span>
<span class="sd">        in turn must implement `Operator.adjoint`, i.e.</span>
<span class="sd">        the call ``op.derivative(x).adjoint`` must be valid.</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Element to which the result is written. Its initial value is</span>
<span class="sd">        used as starting point of the iteration, and its values are</span>
<span class="sd">        updated in each iteration step.</span>
<span class="sd">    rhs : ``op.range`` element</span>
<span class="sd">        Right-hand side of the equation defining the inverse problem</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Object executing code per iteration, e.g. plotting each iterate.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    conjugate_gradient : Optimized solver for symmetric matrices</span>
<span class="sd">    odl.solvers.smooth.nonlinear_cg.conjugate_gradient_nonlinear :</span>
<span class="sd">        Equivalent solver for the nonlinear case</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: add a book reference</span>
    <span class="c1"># TODO: update doc</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` </span><span class="si">{!r}</span><span class="s1"> is not in the domain of `op` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">d</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>               <span class="c1"># d = rhs - A x</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">sqnorm_s_old</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>  <span class="c1"># Only recalculate norm after update</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">op</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>                       <span class="c1"># q = A p</span>
        <span class="n">sqnorm_q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">sqnorm_q</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>  <span class="c1"># Return if residual is 0</span>
            <span class="k">return</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">sqnorm_s_old</span> <span class="o">/</span> <span class="n">sqnorm_q</span>
        <span class="n">x</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>               <span class="c1"># x = x + a*p</span>
        <span class="n">d</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>              <span class="c1"># d = d - a*Ap</span>
        <span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># s = A^T d</span>

        <span class="n">sqnorm_s_new</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sqnorm_s_new</span> <span class="o">/</span> <span class="n">sqnorm_s_old</span>
        <span class="n">sqnorm_s_old</span> <span class="o">=</span> <span class="n">sqnorm_s_new</span>

        <span class="n">p</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>               <span class="c1"># p = s + b * p</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="exp_zero_seq"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.exp_zero_seq.html#odl.solvers.iterative.iterative.exp_zero_seq">[docs]</a><span class="k">def</span> <span class="nf">exp_zero_seq</span><span class="p">(</span><span class="n">base</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default exponential zero sequence.</span>

<span class="sd">    It is defined by</span>

<span class="sd">        t_0 = 1.0</span>
<span class="sd">        t_m = t_(m-1) / base</span>

<span class="sd">    or, in closed form</span>

<span class="sd">        t_m = base^(-m-1)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    base : float</span>
<span class="sd">        Base of the sequence. Its absolute value must be larger than 1.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    val : float</span>
<span class="sd">        The next value in the exponential sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">/=</span> <span class="n">base</span>
        <span class="k">yield</span> <span class="n">value</span></div>


<div class="viewcode-block" id="gauss_newton"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.gauss_newton.html#odl.solvers.iterative.iterative.gauss_newton">[docs]</a><span class="k">def</span> <span class="nf">gauss_newton</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">zero_seq</span><span class="o">=</span><span class="n">exp_zero_seq</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span>
                 <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optimized implementation of a Gauss-Newton method.</span>

<span class="sd">    This method solves the inverse problem (of the first kind)::</span>

<span class="sd">        A(x) = y</span>

<span class="sd">    for a (Frechet-) differentiable `Operator` ``A`` using a</span>
<span class="sd">    Gauss-Newton iteration.</span>

<span class="sd">    It uses a minimum amount of memory copies by applying re-usable</span>
<span class="sd">    temporaries and in-place evaluation.</span>

<span class="sd">    A variant of the method applied to a specific problem is described</span>
<span class="sd">    in a</span>
<span class="sd">    `Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Gauss%E2%80%93Newton_algorithm&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : `Operator`</span>
<span class="sd">        Operator in the inverse problem. If not linear, it must have</span>
<span class="sd">        an implementation of `Operator.derivative`, which</span>
<span class="sd">        in turn must implement `Operator.adjoint`, i.e.</span>
<span class="sd">        the call ``op.derivative(x).adjoint`` must be valid.</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Element to which the result is written. Its initial value is</span>
<span class="sd">        used as starting point of the iteration, and its values are</span>
<span class="sd">        updated in each iteration step.</span>
<span class="sd">    rhs : ``op.range`` element</span>
<span class="sd">        Right-hand side of the equation defining the inverse problem</span>
<span class="sd">    niter : int</span>
<span class="sd">        Maximum number of iterations.</span>
<span class="sd">    zero_seq : iterable, optional</span>
<span class="sd">        Zero sequence whose values are used for the regularization of</span>
<span class="sd">        the linearized problem in each Newton step.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Object executing code per iteration, e.g. plotting each iterate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` </span><span class="si">{!r}</span><span class="s1"> is not in the domain of `op` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

    <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">id_op</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

    <span class="n">tmp_dom</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">tmp_ran</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">zero_seq</span><span class="p">)</span>
        <span class="n">deriv</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">deriv_adjoint</span> <span class="o">=</span> <span class="n">deriv</span><span class="o">.</span><span class="n">adjoint</span>

        <span class="c1"># v = rhs - op(x) - deriv(x0-x)</span>
        <span class="c1"># u = deriv.T(v)</span>
        <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_ran</span><span class="p">)</span>              <span class="c1"># eval  op(x)</span>
        <span class="n">v</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">tmp_ran</span><span class="p">)</span>  <span class="c1"># assign  v = rhs - op(x)</span>
        <span class="n">tmp_dom</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>   <span class="c1"># assign temp  tmp_dom = x0 - x</span>
        <span class="n">deriv</span><span class="p">(</span><span class="n">tmp_dom</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_ran</span><span class="p">)</span>     <span class="c1"># eval  deriv(x0-x)</span>
        <span class="n">v</span> <span class="o">-=</span> <span class="n">tmp_ran</span>                    <span class="c1"># assign  v = rhs-op(x)-deriv(x0-x)</span>
        <span class="n">deriv_adjoint</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>         <span class="c1"># eval/assign  u = deriv.T(v)</span>

        <span class="c1"># Solve equation Tikhonov regularized system</span>
        <span class="c1"># (deriv.T o deriv + tm * id_op)^-1 u = dx</span>
        <span class="n">tikh_op</span> <span class="o">=</span> <span class="n">OperatorSum</span><span class="p">(</span><span class="n">OperatorComp</span><span class="p">(</span><span class="n">deriv</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span> <span class="n">deriv</span><span class="p">),</span>
                              <span class="n">tm</span> <span class="o">*</span> <span class="n">id_op</span><span class="p">,</span> <span class="n">tmp_dom</span><span class="p">)</span>

        <span class="c1"># TODO: allow user to select other method</span>
        <span class="n">conjugate_gradient</span><span class="p">(</span><span class="n">tikh_op</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Update x</span>
        <span class="n">x</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>  <span class="c1"># x = x0 + dx</span>

        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="kaczmarz"><a class="viewcode-back" href="../../../../generated/odl.solvers.iterative.iterative.kaczmarz.html#odl.solvers.iterative.iterative.kaczmarz">[docs]</a><span class="k">def</span> <span class="nf">kaczmarz</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">niter</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback_loop</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Optimized implementation of Kaczmarz&#39;s method.</span>

<span class="sd">    Solves the inverse problem given by the set of equations::</span>

<span class="sd">        A_n(x) = rhs_n</span>

<span class="sd">    This is also known as the Landweber-Kaczmarz&#39;s method, since the method</span>
<span class="sd">    coincides with the Landweber method for a single operator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ops : sequence of `Operator`&#39;s</span>
<span class="sd">        Operators in the inverse problem. ``op[i].derivative(x).adjoint`` must</span>
<span class="sd">        be well-defined for ``x`` in the operator domain and for all ``i``.</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Element to which the result is written. Its initial value is</span>
<span class="sd">        used as starting point of the iteration, and its values are</span>
<span class="sd">        updated in each iteration step.</span>
<span class="sd">    rhs : sequence of ``ops[i].range`` elements</span>
<span class="sd">        Right-hand side of the equation defining the inverse problem.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations.</span>
<span class="sd">    omega : positive float or sequence of positive floats, optional</span>
<span class="sd">        Relaxation parameter in the iteration. If a single float is given the</span>
<span class="sd">        same step is used for all operators, otherwise separate steps are used.</span>
<span class="sd">    projection : callable, optional</span>
<span class="sd">        Function that can be used to modify the iterates in each iteration,</span>
<span class="sd">        for example enforcing positivity. The function should take one</span>
<span class="sd">        argument and modify it in-place.</span>
<span class="sd">    random : bool, optional</span>
<span class="sd">        If `True`, the order of the operators is randomized in each iteration.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Object executing code per iteration, e.g. plotting each iterate.</span>
<span class="sd">    callback_loop : {&#39;inner&#39;, &#39;outer&#39;}</span>
<span class="sd">        Whether the callback should be called in the inner or outer loop.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This method calculates an approximate least-squares solution of</span>
<span class="sd">    the inverse problem of the first kind</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{A}_i (x) = y_i \quad 1 \leq i \leq n,</span>

<span class="sd">    for a given :math:`y_n \in \mathcal{Y}_n`, i.e. an approximate</span>
<span class="sd">    solution :math:`x^*` to</span>

<span class="sd">    .. math::</span>
<span class="sd">        \min_{x\in \mathcal{X}}</span>
<span class="sd">        \sum_{i=1}^n \| \mathcal{A}_i(x) - y_i \|_{\mathcal{Y}_i}^2</span>

<span class="sd">    for a (Frechet-) differentiable operator</span>
<span class="sd">    :math:`\mathcal{A}: \mathcal{X} \to \mathcal{Y}` between Hilbert</span>
<span class="sd">    spaces :math:`\mathcal{X}` and :math:`\mathcal{Y}`. The method</span>
<span class="sd">    starts from an initial guess :math:`x_0` and uses the</span>
<span class="sd">    iteration</span>

<span class="sd">    .. math::</span>
<span class="sd">        x_{k+1} = x_k - \omega_{[k]} \ \partial \mathcal{A}_{[k]}(x_k)^*</span>
<span class="sd">                                 (\mathcal{A}_{[k]}(x_k) - y_{[k]}),</span>

<span class="sd">    where :math:`\partial \mathcal{A}_{[k]}(x_k)` is the Frechet derivative</span>
<span class="sd">    of :math:`\mathcal{A}_{[k]}` at :math:`x_k`, :math:`\omega_{[k]}` is a</span>
<span class="sd">    relaxation parameter and :math:`[k] := k \text{ mod } n`.</span>

<span class="sd">    For linear problems, a choice</span>
<span class="sd">    :math:`0 &lt; \omega_i &lt; 2/\lVert \mathcal{A}_{i}^2\rVert` guarantees</span>
<span class="sd">    convergence, where :math:`\|\mathcal{A}_{i}\|` stands for the</span>
<span class="sd">    operator norm of :math:`\mathcal{A}_{i}`.</span>

<span class="sd">    This implementation uses a minimum amount of memory copies by</span>
<span class="sd">    applying re-usable temporaries and in-place evaluation.</span>

<span class="sd">    The method is also described in a</span>
<span class="sd">    `Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kaczmarz_method&gt;`_. and in Natterer, F.</span>
<span class="sd">    Mathematical Methods in Image Reconstruction, section 5.3.2.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    landweber</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">domain</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">domain</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">opi</span><span class="o">.</span><span class="n">domain</span> <span class="k">for</span> <span class="n">opi</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;domains of `ops` are not all equal&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` </span><span class="si">{!r}</span><span class="s1"> is not in the domain of `ops` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">domain</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`number of `ops` </span><span class="si">{}</span><span class="s1"> does not match number of &#39;</span>
                         <span class="s1">&#39;`rhs` </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">rhs</span><span class="p">)))</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">param_conv</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="c1"># Reusable elements in the range, one per type of space</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">opi</span><span class="o">.</span><span class="n">range</span> <span class="k">for</span> <span class="n">opi</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">]</span>
    <span class="n">unique_ranges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ranges</span><span class="p">)</span>
    <span class="n">tmp_rans</span> <span class="o">=</span> <span class="p">{</span><span class="n">ran</span><span class="p">:</span> <span class="n">ran</span><span class="o">.</span><span class="n">element</span><span class="p">()</span> <span class="k">for</span> <span class="n">ran</span> <span class="ow">in</span> <span class="n">unique_ranges</span><span class="p">}</span>

    <span class="c1"># Single reusable element in the domain</span>
    <span class="n">tmp_dom</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>

    <span class="c1"># Iteratively find solution</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rng</span><span class="p">:</span>
            <span class="c1"># Find residual</span>
            <span class="n">tmp_ran</span> <span class="o">=</span> <span class="n">tmp_rans</span><span class="p">[</span><span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">range</span><span class="p">]</span>
            <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_ran</span><span class="p">)</span>
            <span class="n">tmp_ran</span> <span class="o">-=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Update x</span>
            <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">tmp_ran</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp_dom</span><span class="p">)</span>
            <span class="n">x</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tmp_dom</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">projection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">projection</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callback_loop</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callback_loop</span> <span class="o">==</span> <span class="s1">&#39;outer&#39;</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>