

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.solvers.functional.default_functionals &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.solvers.functional.default_functionals</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.solvers.functional.default_functionals</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Default functionals defined on any space similar to R^n or L^2.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.operator</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ConstantOperator</span><span class="p">,</span> <span class="n">DiagonalOperator</span><span class="p">,</span> <span class="n">Operator</span><span class="p">,</span> <span class="n">PointwiseNorm</span><span class="p">,</span>
    <span class="n">ScalingOperator</span><span class="p">,</span> <span class="n">ZeroOperator</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.solvers.functional.functional</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Functional</span><span class="p">,</span> <span class="n">FunctionalQuadraticPerturb</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.solvers.nonsmooth.proximal_operators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">combine_proximals</span><span class="p">,</span> <span class="n">proj_simplex</span><span class="p">,</span> <span class="n">proximal_box_constraint</span><span class="p">,</span>
    <span class="n">proximal_const_func</span><span class="p">,</span> <span class="n">proximal_convex_conj</span><span class="p">,</span> <span class="n">proximal_convex_conj_kl</span><span class="p">,</span>
    <span class="n">proximal_convex_conj_kl_cross_entropy</span><span class="p">,</span> <span class="n">proximal_convex_conj_l1</span><span class="p">,</span>
    <span class="n">proximal_convex_conj_l1_l2</span><span class="p">,</span> <span class="n">proximal_convex_conj_l2</span><span class="p">,</span>
    <span class="n">proximal_convex_conj_linfty</span><span class="p">,</span> <span class="n">proximal_huber</span><span class="p">,</span> <span class="n">proximal_l1</span><span class="p">,</span> <span class="n">proximal_l1_l2</span><span class="p">,</span>
    <span class="n">proximal_l2</span><span class="p">,</span> <span class="n">proximal_l2_squared</span><span class="p">,</span> <span class="n">proximal_linfty</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="kn">import</span> <span class="n">ProductSpace</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">conj_exponent</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ZeroFunctional&#39;</span><span class="p">,</span> <span class="s1">&#39;ConstantFunctional&#39;</span><span class="p">,</span> <span class="s1">&#39;ScalingFunctional&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IdentityFunctional&#39;</span><span class="p">,</span>
           <span class="s1">&#39;LpNorm&#39;</span><span class="p">,</span> <span class="s1">&#39;L1Norm&#39;</span><span class="p">,</span> <span class="s1">&#39;GroupL1Norm&#39;</span><span class="p">,</span> <span class="s1">&#39;L2Norm&#39;</span><span class="p">,</span> <span class="s1">&#39;L2NormSquared&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Huber&#39;</span><span class="p">,</span> <span class="s1">&#39;NuclearNorm&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndicatorZero&#39;</span><span class="p">,</span> <span class="s1">&#39;IndicatorBox&#39;</span><span class="p">,</span> <span class="s1">&#39;IndicatorNonnegativity&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndicatorLpUnitBall&#39;</span><span class="p">,</span> <span class="s1">&#39;IndicatorGroupL1UnitBall&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndicatorNuclearNormUnitBall&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndicatorSimplex&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndicatorSumConstraint&#39;</span><span class="p">,</span>
           <span class="s1">&#39;KullbackLeibler&#39;</span><span class="p">,</span> <span class="s1">&#39;KullbackLeiblerCrossEntropy&#39;</span><span class="p">,</span>
           <span class="s1">&#39;QuadraticForm&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SeparableSum&#39;</span><span class="p">,</span> <span class="s1">&#39;MoreauEnvelope&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="LpNorm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.LpNorm.html#odl.solvers.functional.default_functionals.LpNorm">[docs]</a><span class="k">class</span> <span class="nc">LpNorm</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to the Lp-norm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the functional is defined on an :math:`\mathbb{R}^n`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_p`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_p = \left(\sum_{i=1}^n |x_i|^p \right)^{1/p}.</span>

<span class="sd">    If the functional is defined on an :math:`L_2`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_p`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_p = \left(\int_\Omega |x(t)|^p dt. \right)^{1/p}</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LpNorm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.LpNorm.html#odl.solvers.functional.default_functionals.LpNorm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        exponent : float</span>
<span class="sd">            Exponent for the norm (``p``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LpNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span></div>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="LpNorm._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.LpNorm._call.html#odl.solvers.functional.default_functionals.LpNorm._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the Lp-norm of ``x``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">()),</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;unknown exponent&#39;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the Lp-norm.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndicatorLpUnitBall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                   <span class="n">exponent</span><span class="o">=</span><span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the proximal factory of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_l1 :</span>
<span class="sd">            proximal factory for the L1-norm.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_l2 :</span>
<span class="sd">            proximal factory for the L2-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_l1</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_l2</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_linfty</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for p=1, &#39;</span>
                                      <span class="s1">&#39;p=2, and p=inf&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The functional is not differentiable in ``x=0``. However, when</span>
<span class="sd">        evaluating the gradient operator in this point it will return 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">L1Gradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

                <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

                <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">L1Gradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                        <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.&quot;&quot;&quot;</span>
                    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>

                <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Derivative is a.e. zero.&quot;&quot;&quot;</span>
                    <span class="k">return</span> <span class="n">ZeroOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">L1Gradient</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">L2Gradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

                <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

                <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">L2Gradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                        <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                    <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.</span>

<span class="sd">                    The gradient is not defined in 0.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="n">norm_of_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">norm_of_x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">norm_of_x</span>

            <span class="k">return</span> <span class="n">L2Gradient</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`gradient` only implemented for p=1 &#39;</span>
                                      <span class="s1">&#39;and p=2&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="GroupL1Norm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.GroupL1Norm.html#odl.solvers.functional.default_functionals.GroupL1Norm">[docs]</a><span class="k">class</span> <span class="nc">GroupL1Norm</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to the mixed L1-Lp norm on `ProductSpace`.</span>

<span class="sd">    The L1-norm, ``|| ||x||_p ||_1``,  is defined as the integral/sum of</span>
<span class="sd">    ``||x||_p``, where  ``||x||_p`` is the pointwise p-norm.</span>

<span class="sd">    This is also known as the cross norm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the functional is defined on an :math:`\mathbb{R}^{n \times m}`-like</span>
<span class="sd">    space, the group :math:`L_1`-norm, denoted</span>
<span class="sd">    :math:`\| \cdot \|_{\times, p}` is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \|F\|_{\times, p} =</span>
<span class="sd">        \sum_{i = 1}^n \left(\sum_{j=1}^m |F_{i,j}|^p\right)^{1/p}</span>

<span class="sd">    If the functional is defined on an :math:`(\mathcal{L}^p)^m`-like space,</span>
<span class="sd">    the group :math:`L_1`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| F \|_{\times, p} =</span>
<span class="sd">        \int_{\Omega} \left(\sum_{j = 1}^m |F_j(x)|^p\right)^{1/p}</span>
<span class="sd">        \mathrm{d}x.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GroupL1Norm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.GroupL1Norm.html#odl.solvers.functional.default_functionals.GroupL1Norm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        exponent : non-zero float, optional</span>
<span class="sd">            Exponent of the norm in each point. Values between</span>
<span class="sd">            0 and 1 are currently not supported due to numerical</span>
<span class="sd">            instability. Infinity gives the supremum norm.</span>
<span class="sd">            Default: ``vfspace.exponent``, usually 2.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(2)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(space, 2)</span>
<span class="sd">        &gt;&gt;&gt; op = GroupL1Norm(pspace)</span>
<span class="sd">        &gt;&gt;&gt; op([[3, 3], [4, 4]])</span>
<span class="sd">        10.0</span>

<span class="sd">        Set exponent of inner (p) norm:</span>

<span class="sd">        &gt;&gt;&gt; op2 = GroupL1Norm(pspace, exponent=1)</span>
<span class="sd">        &gt;&gt;&gt; op2([[3, 3], [4, 4]])</span>
<span class="sd">        14.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space` must be a `ProductSpace`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vfspace</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space.is_power_space` must be `True`&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GroupL1Norm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span> <span class="o">=</span> <span class="n">PointwiseNorm</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span></div>

<div class="viewcode-block" id="GroupL1Norm._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.GroupL1Norm._call.html#odl.solvers.functional.default_functionals.GroupL1Norm._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the group L1-norm of ``x``.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
        <span class="n">pointwise_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pointwise_norm</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">one</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The functional is not differentiable in ``x=0``. However, when</span>
<span class="sd">        evaluating the gradient operator in this point it will return 0.</span>

<span class="sd">         Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The gradient is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left[ \nabla \| \|f\|_1 \|_1 \right]_i =</span>
<span class="sd">            \frac{f_i}{|f_i|}</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left[ \nabla \| \|f\|_2 \|_1 \right]_i =</span>
<span class="sd">            \frac{f_i}{\|f\|_2}</span>

<span class="sd">        else:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \left[ \nabla || ||f||_p ||_1 \right]_i =</span>
<span class="sd">            \frac{| f_i |^{p-2} f_i}{||f||_p^{p-1}}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">GroupL1Gradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of the `GroupL1Norm` functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">GroupL1Gradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
                <span class="n">pwnorm_x</span> <span class="o">=</span> <span class="n">functional</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">pwnorm_x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">pwnorm_x</span><span class="p">)</span>
                <span class="n">functional</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="n">pwnorm_x</span><span class="p">,</span>
                                                                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">GroupL1Gradient</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the ``proximal factory`` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_l1 :</span>
<span class="sd">            `proximal factory` for the L1-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_l1</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_l1_l2</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for p = 1 &#39;</span>
                                      <span class="s1">&#39;or 2&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the group L1-norm.&quot;&quot;&quot;</span>
        <span class="n">conj_exp</span> <span class="o">=</span> <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IndicatorGroupL1UnitBall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">conj_exp</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, exponent=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorGroupL1UnitBall"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall.html#odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall">[docs]</a><span class="k">class</span> <span class="nc">IndicatorGroupL1UnitBall</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;The convex conjugate to the mixed L1--Lp norm on `ProductSpace`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    GroupL1Norm</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorGroupL1UnitBall.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall.html#odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vfspace</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vfspace : `ProductSpace`</span>
<span class="sd">            Space of vector fields on which the operator acts.</span>
<span class="sd">            It has to be a product space of identical spaces, i.e. a</span>
<span class="sd">            power space.</span>
<span class="sd">        exponent : non-zero float, optional</span>
<span class="sd">            Exponent of the norm in each point. Values between</span>
<span class="sd">            0 and 1 are currently not supported due to numerical</span>
<span class="sd">            instability. Infinity gives the supremum norm.</span>
<span class="sd">            Default: ``vfspace.exponent``, usually 2.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(2)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(space, 2)</span>
<span class="sd">        &gt;&gt;&gt; op = IndicatorGroupL1UnitBall(pspace)</span>
<span class="sd">        &gt;&gt;&gt; op([[0.1, 0.5], [0.2, 0.3]])</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; op([[3, 3], [4, 4]])</span>
<span class="sd">        inf</span>

<span class="sd">        Set exponent of inner (p) norm:</span>

<span class="sd">        &gt;&gt;&gt; op2 = IndicatorGroupL1UnitBall(pspace, exponent=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space` must be a `ProductSpace`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vfspace</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space.is_power_space` must be `True`&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorGroupL1UnitBall</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span> <span class="o">=</span> <span class="n">PointwiseNorm</span><span class="p">(</span><span class="n">vfspace</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndicatorGroupL1UnitBall._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall._call.html#odl.solvers.functional.default_functionals.IndicatorGroupL1UnitBall._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">x_norm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l1 :</span>
<span class="sd">            `proximal factory` for the L1-norms convex conjugate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_convex_conj_l1</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_convex_conj_l1_l2</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for p = 1 &#39;</span>
                                      <span class="s1">&#39;or 2&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convex conjugate functional of IndicatorLpUnitBall.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        convex_conj : GroupL1Norm</span>
<span class="sd">            The convex conjugate is the the group L1-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conj_exp</span> <span class="o">=</span> <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GroupL1Norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">conj_exp</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, exponent=</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">pointwise_norm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorLpUnitBall"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorLpUnitBall.html#odl.solvers.functional.default_functionals.IndicatorLpUnitBall">[docs]</a><span class="k">class</span> <span class="nc">IndicatorLpUnitBall</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The indicator function on the unit ball in given the ``Lp`` norm.</span>

<span class="sd">    It does not implement `gradient` since it is not differentiable everywhere.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This functional is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            f(x) = \left\{ \begin{array}{ll}</span>
<span class="sd">            0 &amp; \text{if } ||x||_{L_p} \leq 1, \</span>
<span class="sd">            \infty &amp; \text{else,}</span>
<span class="sd">            \end{array} \right.</span>

<span class="sd">    where :math:`||x||_{L_p}` is the :math:`L_p`-norm, which for finite values</span>
<span class="sd">    of :math:`p` is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \| x \|_{L_p} = \left( \int_{\Omega} |x|^p dx \right)^{1/p},</span>

<span class="sd">    and for :math:`p = \infty` it is defined as</span>

<span class="sd">        .. math::</span>
<span class="sd">            ||x||_{\infty} = \max_x (|x|).</span>

<span class="sd">    The functional also allows noninteger and nonpositive values of the</span>
<span class="sd">    exponent :math:`p`, however in this case :math:`\| x \|_{L_p}` is not a</span>
<span class="sd">    norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorLpUnitBall.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorLpUnitBall.html#odl.solvers.functional.default_functionals.IndicatorLpUnitBall.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">exponent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        exponent : int or infinity</span>
<span class="sd">            Specifies wich norm to use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorLpUnitBall</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span> <span class="o">=</span> <span class="n">LpNorm</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">exponent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Exponent corresponding to the norm.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exponent</span>

<div class="viewcode-block" id="IndicatorLpUnitBall._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorLpUnitBall._call.html#odl.solvers.functional.default_functionals.IndicatorLpUnitBall._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the functional to the given point.&quot;&quot;&quot;</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_norm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The conjugate functional of IndicatorLpUnitBall.</span>

<span class="sd">        The convex conjugate functional of an ``Lp`` norm, ``p &lt; infty`` is the</span>
<span class="sd">        indicator function on the unit ball defined by the corresponding dual</span>
<span class="sd">        norm ``q``, given by ``1/p + 1/q = 1`` and where ``q = infty`` if</span>
<span class="sd">        ``p = 1`` [Roc1970]. By the Fenchel-Moreau theorem, the convex</span>
<span class="sd">        conjugate functional of indicator function on the unit ball in ``Lq``</span>
<span class="sd">        is the corresponding Lp-norm [BC2011].</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [Roc1970] Rockafellar, R. T. *Convex analysis*. Princeton</span>
<span class="sd">        University Press, 1970.</span>

<span class="sd">        [BC2011] Bauschke, H H, and Combettes, P L. *Convex analysis and</span>
<span class="sd">        monotone operator theory in Hilbert spaces*. Springer, 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">L1Norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">L2Norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LpNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l1 :</span>
<span class="sd">            `proximal factory` for convex conjuagte of L1-norm.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_l2 :</span>
<span class="sd">            `proximal factory` for convex conjuagte of L2-norm.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_linfty :</span>
<span class="sd">            `proximal factory` for convex conjuagte of Linfty-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_convex_conj_l1</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_convex_conj_l2</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">proximal_convex_conj_linfty</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for p=1, &#39;</span>
                                      <span class="s1">&#39;p=2 or p=inf&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">,</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="L1Norm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L1Norm.html#odl.solvers.functional.default_functionals.L1Norm">[docs]</a><span class="k">class</span> <span class="nc">L1Norm</span><span class="p">(</span><span class="n">LpNorm</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to L1-norm.</span>

<span class="sd">    The L1-norm, ``||x||_1``,  is defined as the integral/sum of ``|x|``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the functional is defined on an :math:`\mathbb{R}^n`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_1`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_1 = \sum_{i=1}^n |x_i|.</span>

<span class="sd">    If the functional is defined on an :math:`L_2`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_1`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_1 = \int_\Omega |x(t)| dt.</span>

<span class="sd">    The `proximal` factory allows using vector-valued stepsizes:</span>

<span class="sd">    &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">    &gt;&gt;&gt; f = odl.solvers.L1Norm(space)</span>
<span class="sd">    &gt;&gt;&gt; x = space.one()</span>
<span class="sd">    &gt;&gt;&gt; f.proximal([0.5, 1.0, 1.5])(x)</span>
<span class="sd">    rn(3).element([ 0.5,  0. ,  0. ])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="L1Norm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L1Norm.html#odl.solvers.functional.default_functionals.L1Norm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L1Norm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="L2Norm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L2Norm.html#odl.solvers.functional.default_functionals.L2Norm">[docs]</a><span class="k">class</span> <span class="nc">L2Norm</span><span class="p">(</span><span class="n">LpNorm</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to the L2-norm.</span>

<span class="sd">    The L2-norm, ``||x||_2``,  is defined as the square-root out of the</span>
<span class="sd">    integral/sum of ``x^2``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the functional is defined on an :math:`\mathbb{R}^n`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_2`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_2 = \sqrt{ \sum_{i=1}^n |x_i|^2 }.</span>

<span class="sd">    If the functional is defined on an :math:`L_2`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_2`-norm is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_2 = \sqrt{ \int_\Omega |x(t)|^2 dt. }</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="L2Norm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L2Norm.html#odl.solvers.functional.default_functionals.L2Norm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2Norm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="L2NormSquared"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L2NormSquared.html#odl.solvers.functional.default_functionals.L2NormSquared">[docs]</a><span class="k">class</span> <span class="nc">L2NormSquared</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to the squared L2-norm.</span>

<span class="sd">    The squared L2-norm, ``||x||_2^2``,  is defined as the integral/sum of</span>
<span class="sd">    ``x^2``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the functional is defined on an :math:`\mathbb{R}^n`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_2^2`-functional is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_2^2 = \sum_{i=1}^n |x_i|^2.</span>

<span class="sd">    If the functional is defined on an :math:`L_2`-like space, the</span>
<span class="sd">    :math:`\| \cdot \|_2^2`-functional is defined as</span>

<span class="sd">    .. math::</span>
<span class="sd">        \| x \|_2^2 = \int_\Omega |x(t)|^2 dt.</span>

<span class="sd">    The `proximal` factory allows using vector-valued stepsizes:</span>

<span class="sd">    &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">    &gt;&gt;&gt; f = odl.solvers.L2NormSquared(space)</span>
<span class="sd">    &gt;&gt;&gt; x = space.one()</span>
<span class="sd">    &gt;&gt;&gt; f.proximal([0.5, 1.5, 2.0])(x)</span>
<span class="sd">    rn(3).element([ 0.5 ,  0.25,  0.2 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="L2NormSquared.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L2NormSquared.html#odl.solvers.functional.default_functionals.L2NormSquared.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">L2NormSquared</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="L2NormSquared._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.L2NormSquared._call.html#odl.solvers.functional.default_functionals.L2NormSquared._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the squared L2-norm of ``x``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ScalingOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_l2_squared :</span>
<span class="sd">            `proximal factory` for the squared L2-norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_l2_squared</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The convex conjugate functional of the squared L2-norm.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The conjugate functional of :math:`\| \cdot \|_2^2` is</span>
<span class="sd">        :math:`\frac{1}{4}\| \cdot \|_2^2`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">L2NormSquared</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConstantFunctional"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ConstantFunctional.html#odl.solvers.functional.default_functionals.ConstantFunctional">[docs]</a><span class="k">class</span> <span class="nc">ConstantFunctional</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;The constant functional.</span>

<span class="sd">    This functional maps all elements in the domain to a given, constant value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ConstantFunctional.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ConstantFunctional.html#odl.solvers.functional.default_functionals.ConstantFunctional.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">constant</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `LinearSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        constant : element in ``domain.field``</span>
<span class="sd">            The constant value of the functional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConstantFunctional</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="p">(</span><span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constant value of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span>

<div class="viewcode-block" id="ConstantFunctional._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ConstantFunctional._call.html#odl.solvers.functional.default_functionals.ConstantFunctional._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a constant value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ZeroOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_const_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convex conjugate functional of the constant functional.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This functional is defined as</span>

<span class="sd">         .. math::</span>
<span class="sd">            f^*(x) = \left\{ \begin{array}{ll}</span>
<span class="sd">            -constant &amp; \text{if } x = 0, \\</span>
<span class="sd">            \infty &amp; \text{else}</span>
<span class="sd">            \end{array} \right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndicatorZero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span></div>


<div class="viewcode-block" id="ZeroFunctional"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ZeroFunctional.html#odl.solvers.functional.default_functionals.ZeroFunctional">[docs]</a><span class="k">class</span> <span class="nc">ZeroFunctional</span><span class="p">(</span><span class="n">ConstantFunctional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Functional that maps all elements in the domain to zero.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ZeroFunctional.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ZeroFunctional.html#odl.solvers.functional.default_functionals.ZeroFunctional.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `LinearSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ZeroFunctional</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="ScalingFunctional"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ScalingFunctional.html#odl.solvers.functional.default_functionals.ScalingFunctional">[docs]</a><span class="k">class</span> <span class="nc">ScalingFunctional</span><span class="p">(</span><span class="n">Functional</span><span class="p">,</span> <span class="n">ScalingOperator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Functional that scales the input argument by a value.</span>

<span class="sd">    Since the range of a functional is always a field, the domain of this</span>
<span class="sd">    functional is also a field, i.e. real or complex numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ScalingFunctional.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.ScalingFunctional.html#odl.solvers.functional.default_functionals.ScalingFunctional.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : `Field`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        scale : element in ``domain``</span>
<span class="sd">            The constant value to scale by.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; field = odl.RealNumbers()</span>
<span class="sd">        &gt;&gt;&gt; func = ScalingFunctional(field, 3)</span>
<span class="sd">        &gt;&gt;&gt; func(5)</span>
<span class="sd">        15.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Functional</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="n">field</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ScalingOperator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ConstantFunctional</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span></div>


<div class="viewcode-block" id="IdentityFunctional"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IdentityFunctional.html#odl.solvers.functional.default_functionals.IdentityFunctional">[docs]</a><span class="k">class</span> <span class="nc">IdentityFunctional</span><span class="p">(</span><span class="n">ScalingFunctional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Functional that maps a scalar to itself.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    odl.operator.default_ops.IdentityOperator</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IdentityFunctional.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IdentityFunctional.html#odl.solvers.functional.default_functionals.IdentityFunctional.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : `Field`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IdentityFunctional</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IndicatorBox"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorBox.html#odl.solvers.functional.default_functionals.IndicatorBox">[docs]</a><span class="k">class</span> <span class="nc">IndicatorBox</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicator on some box shaped domain.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The indicator :math:`F` with lower bound :math:`a` and upper bound</span>
<span class="sd">    :math:`b` is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \begin{cases}</span>
<span class="sd">            0 &amp; \text{if } a \leq x \leq b \text{ everywhere}, \\</span>
<span class="sd">            \infty &amp; \text{else}</span>
<span class="sd">            \end{cases}</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorBox.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorBox.html#odl.solvers.functional.default_functionals.IndicatorBox.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `LinearSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        lower : ``space.field`` element or ``space`` `element-like`, optional</span>
<span class="sd">            The lower bound.</span>
<span class="sd">            Default: ``None``, interpreted as -infinity</span>
<span class="sd">        upper : ``space.field`` element or ``space`` `element-like`, optional</span>
<span class="sd">            The upper bound.</span>
<span class="sd">            Default: ``None``, interpreted as +infinity</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; func = IndicatorBox(space, 0, 2)</span>
<span class="sd">        &gt;&gt;&gt; func([0, 1, 2])  # all points inside</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; func([0, 1, 3])  # one point outside</span>
<span class="sd">        inf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorBox</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper</span> <span class="o">=</span> <span class="n">upper</span></div>

<div class="viewcode-block" id="IndicatorBox._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorBox._call.html#odl.solvers.functional.default_functionals.IndicatorBox._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the functional to the given point.&quot;&quot;&quot;</span>
        <span class="c1"># Since the proximal projects onto our feasible set we can simply</span>
        <span class="c1"># check if it changes anything</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_box_constraint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorNonnegativity"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorNonnegativity.html#odl.solvers.functional.default_functionals.IndicatorNonnegativity">[docs]</a><span class="k">class</span> <span class="nc">IndicatorNonnegativity</span><span class="p">(</span><span class="n">IndicatorBox</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicator on the set of non-negative numbers.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The nonnegativity indicator :math:`F`  is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \begin{cases}</span>
<span class="sd">            0 &amp; \text{if } 0 \leq x \text{ everywhere}, \\</span>
<span class="sd">            \infty &amp; \text{else}</span>
<span class="sd">            \end{cases}</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorNonnegativity.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorNonnegativity.html#odl.solvers.functional.default_functionals.IndicatorNonnegativity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `LinearSpace`</span>
<span class="sd">            Domain of the functional.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; func = IndicatorNonnegativity(space)</span>
<span class="sd">        &gt;&gt;&gt; func([0, 1, 2])  # all points positive</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; func([0, 1, -3])  # one point negative</span>
<span class="sd">        inf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorNonnegativity</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorZero"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorZero.html#odl.solvers.functional.default_functionals.IndicatorZero">[docs]</a><span class="k">class</span> <span class="nc">IndicatorZero</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;The indicator function of the singleton set {0}.</span>

<span class="sd">    The function has a constant value if the input is zero, otherwise infinity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorZero.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorZero.html#odl.solvers.functional.default_functionals.IndicatorZero.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `LinearSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        constant : element in ``domain.field``, optional</span>
<span class="sd">            The constant value of the functional</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; func = IndicatorZero(space)</span>
<span class="sd">        &gt;&gt;&gt; func([0, 0, 0])</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; func([0, 0, 1])</span>
<span class="sd">        inf</span>

<span class="sd">        &gt;&gt;&gt; func = IndicatorZero(space, constant=2)</span>
<span class="sd">        &gt;&gt;&gt; func([0, 0, 0])</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorZero</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">=</span> <span class="n">constant</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constant value of the functional if ``x=0``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span>

<div class="viewcode-block" id="IndicatorZero._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorZero._call.html#odl.solvers.functional.default_functionals.IndicatorZero._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the functional to the given point.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># In this case x is the zero-element.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By the Fenchel-Moreau theorem the convex conjugate is the constant</span>
<span class="sd">        functional [BC2011] with the constant value of -`constant`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [BC2011] Bauschke, H H, and Combettes, P L. *Convex analysis and</span>
<span class="sd">        monotone operator theory in Hilbert spaces*. Springer, 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ConstantFunctional</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the proximal factory of the functional.</span>

<span class="sd">        This is the zero operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">zero_proximal</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Proximal factory for zero operator.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            sigma : positive float, optional</span>
<span class="sd">                Step size parameter.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">ZeroOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">zero_proximal</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span></div>


<div class="viewcode-block" id="KullbackLeibler"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeibler.html#odl.solvers.functional.default_functionals.KullbackLeibler">[docs]</a><span class="k">class</span> <span class="nc">KullbackLeibler</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Kullback-Leibler divergence functional.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F` with prior :math:`g&gt;=0` is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x)</span>
<span class="sd">        =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \int \left( x(t) - g(t) + g(t) \log \left( \frac{g(t)}{x(t)}</span>
<span class="sd">            \right) \right) dt &amp; \text{if } x(t) &gt; 0  \; \forall t</span>
<span class="sd">            \\</span>
<span class="sd">            +\infty &amp; \text{else.}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    Note that we use the common definition 0 log(0) := 0.</span>
<span class="sd">    KL based objectives are common in MLEM optimization problems and are often</span>
<span class="sd">    used as data-matching term when data noise governed by a multivariate</span>
<span class="sd">    Poisson probability distribution is significant.</span>

<span class="sd">    The functional is related to the Kullback-Leibler cross entropy functional</span>
<span class="sd">    `KullbackLeiblerCrossEntropy`. The KL cross entropy is the one</span>
<span class="sd">    diescribed in `this Wikipedia article</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&gt;`_, and</span>
<span class="sd">    the functional :math:`F` is obtained by switching place of the prior and</span>
<span class="sd">    the varialbe in the KL cross entropy functional.</span>

<span class="sd">    For a theoretical exposition, see `Csiszar1991`_.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    KullbackLeiblerConvexConj : the convex conjugate functional</span>
<span class="sd">    KullbackLeiblerCrossEntropy : related functional</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. _Csiszar1991:  http://www.jstor.org/stable/2241918</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KullbackLeibler.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeibler.html#odl.solvers.functional.default_functionals.KullbackLeibler.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        prior : ``space`` `element-like`, optional</span>
<span class="sd">            Depending on the context, the prior, target or data</span>
<span class="sd">            distribution. It is assumed to be nonnegative.</span>
<span class="sd">            Default: if None it is take as the one-element.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Test that KullbackLeibler(x,x) = 0</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; prior = 3 * space.one()</span>
<span class="sd">        &gt;&gt;&gt; func = odl.solvers.KullbackLeibler(space, prior=prior)</span>
<span class="sd">        &gt;&gt;&gt; func(prior)</span>
<span class="sd">        0.0</span>


<span class="sd">        Test that zeros in the prior are handled correctly</span>

<span class="sd">        &gt;&gt;&gt; prior = space.zero()</span>
<span class="sd">        &gt;&gt;&gt; func = odl.solvers.KullbackLeibler(space, prior=prior)</span>
<span class="sd">        &gt;&gt;&gt; x = space.one()</span>
<span class="sd">        &gt;&gt;&gt; func(x)</span>
<span class="sd">        3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KullbackLeibler</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`prior` not in `domain`&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span> <span class="o">=</span> <span class="n">prior</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The prior in the Kullback-Leibler functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="KullbackLeibler._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeibler._call.html#odl.solvers.functional.default_functionals.KullbackLeibler._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the KL-diveregnce in the point ``x``.</span>

<span class="sd">        If any components of ``x`` is non-positive, the value is positive</span>
<span class="sd">        infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.special</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlogy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">xlogy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">+</span> <span class="n">xlogy</span><span class="p">)</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="c1"># In this case, some element was less than or equal to zero</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gradient of the KL functional.</span>

<span class="sd">        The gradient of `KullbackLeibler` with ``prior`` :math:`g` is given</span>
<span class="sd">        as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \nabla F(x) = 1 - \frac{g}{x}.</span>

<span class="sd">        The gradient is not defined in points where one or more components</span>
<span class="sd">        are non-positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">KLGradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">KLGradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.</span>

<span class="sd">                The gradient is not defined in points where one or more</span>
<span class="sd">                components are non-positive.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">functional</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">KLGradient</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl :</span>
<span class="sd">            `proximal factory` for convex conjugate of KL.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj :</span>
<span class="sd">            Proximal of the convex conjugate of a functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="n">proximal_convex_conj_kl</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                                            <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the KL-functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">KullbackLeiblerConvexConj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span></div>


<div class="viewcode-block" id="KullbackLeiblerConvexConj"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj.html#odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj">[docs]</a><span class="k">class</span> <span class="nc">KullbackLeiblerConvexConj</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The convex conjugate of Kullback-Leibler divergence functional.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F^*` with prior :math:`g&gt;=0` is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(x)</span>
<span class="sd">        =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \sum_{i} \left( -g_i \ln(1 - x_i) \right)</span>
<span class="sd">            &amp; \text{if } x_i &lt; 1 \forall i</span>
<span class="sd">            \\</span>
<span class="sd">            +\infty &amp; \text{else}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    KullbackLeibler : convex conjugate functional</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KullbackLeiblerConvexConj.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj.html#odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        prior : ``space`` `element-like`, optional</span>
<span class="sd">            Depending on the context, the prior, target or data</span>
<span class="sd">            distribution. It is assumed to be nonnegative.</span>
<span class="sd">            Default: if None it is take as the one-element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KullbackLeiblerConvexConj</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`prior` not in `domain`&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span> <span class="o">=</span> <span class="n">prior</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The prior in convex conjugate Kullback-Leibler functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="KullbackLeiblerConvexConj._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj._call.html#odl.solvers.functional.default_functionals.KullbackLeiblerConvexConj._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value in the point ``x``.</span>

<span class="sd">        If any components of ``x`` is larger than or equal to 1, the value is</span>
<span class="sd">        positive infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.special</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlogy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">xlogy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">xlogy</span><span class="p">)</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="c1"># In this case, some element was larger than or equal to one</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The gradient is not defined in points where one or more components</span>
<span class="sd">        are larger than or equal to one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">KLCCGradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">KLCCGradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.</span>

<span class="sd">                The gradient is not defined in points where one or more</span>
<span class="sd">                components are larger than or equal to one.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KLCCGradient</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl :</span>
<span class="sd">            `proximal factory` for convex conjugate of KL.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj :</span>
<span class="sd">            Proximal of the convex conjugate of a functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_convex_conj_kl</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the conjugate KL-functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">KullbackLeibler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span></div>


<div class="viewcode-block" id="KullbackLeiblerCrossEntropy"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy">[docs]</a><span class="k">class</span> <span class="nc">KullbackLeiblerCrossEntropy</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Kullback-Leibler Cross Entropy divergence functional.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F` with prior :math:`g&gt;0` is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x)</span>
<span class="sd">        =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \sum_{i} \left( g_i - x_i + x_i \log \left( \frac{x_i}{g_i}</span>
<span class="sd">            \right) \right)</span>
<span class="sd">            &amp; \text{if } g_i &gt; 0 \forall i</span>
<span class="sd">            \\</span>
<span class="sd">            +\infty &amp; \text{else}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    For further information about the functional, see the</span>
<span class="sd">    `Wikipedia article on the Kullback Leibler divergence</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence&gt;`_,</span>
<span class="sd">    or read for example `this article</span>
<span class="sd">    &lt;http://ieeexplore.ieee.org/document/1056144/?arnumber=1056144&gt;`_.</span>

<span class="sd">    The KL cross entropy functional :math:`F`, described above, is related to</span>
<span class="sd">    another functional which is also know as KL divergence. This functional</span>
<span class="sd">    is often used as data discrepancy term in inverse problems, when data is</span>
<span class="sd">    corrupted with Poisson noise. It is obtained by changing place</span>
<span class="sd">    of the prior and the variable. See the See Also section.</span>

<span class="sd">    For a theoretical exposition, see `Csiszar1991`_.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    KullbackLeibler : related functional</span>
<span class="sd">    KullbackLeiblerCrossEntropyConvexConj : the convex conjugate functional</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. _Csiszar1991:  http://www.jstor.org/stable/2241918</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KullbackLeiblerCrossEntropy.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        prior : ``space`` `element-like`, optional</span>
<span class="sd">            Depending on the context, the prior, target or data</span>
<span class="sd">            distribution. It is assumed to be nonnegative.</span>
<span class="sd">            Default: if None it is take as the one-element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KullbackLeiblerCrossEntropy</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`prior` not in `domain`&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span> <span class="o">=</span> <span class="n">prior</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The prior in the Kullback-Leibler functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="KullbackLeiblerCrossEntropy._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy._call.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropy._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the KL-diveregnce in the point ``x``.</span>

<span class="sd">        If any components of ``x`` is non-positive, the value is positive</span>
<span class="sd">        infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.special</span>

        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xlogx</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">xlogy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xlogx</span><span class="p">)</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xlogy</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">xlogy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">-</span> <span class="n">x</span> <span class="o">+</span> <span class="n">xlogy</span><span class="p">)</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="c1"># In this case, some element was less than or equal to zero</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The gradient is not defined in points where one or more components</span>
<span class="sd">        are less than or equal to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">KLCrossEntropyGradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">KLCrossEntropyGradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.</span>

<span class="sd">                The gradient is not defined in for points with components less</span>
<span class="sd">                than or equal to zero.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">tmp</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="n">tmp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The derivative is not defined.</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The gradient of the Kullback-Leibler &#39;</span>
                                     <span class="s1">&#39;Cross Entropy functional is not defined &#39;</span>
                                     <span class="s1">&#39;for `x` with one or more components &#39;</span>
                                     <span class="s1">&#39;less than or equal to zero.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">KLCrossEntropyGradient</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl_cross_entropy :</span>
<span class="sd">            `proximal factory` for convex conjugate of the KL cross entropy.</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj :</span>
<span class="sd">            Proximal of the convex conjugate of a functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="n">proximal_convex_conj_kl_cross_entropy</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the KL-functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">KullbackLeiblerCrossEntropyConvexConj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span></div>


<div class="viewcode-block" id="KullbackLeiblerCrossEntropyConvexConj"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj">[docs]</a><span class="k">class</span> <span class="nc">KullbackLeiblerCrossEntropyConvexConj</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The convex conjugate of Kullback-Leibler Cross Entorpy functional.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F^*` with prior :math:`g&gt;0` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F^*(x) = \sum_i g_i \left(e^{x_i} - 1\right)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    KullbackLeiblerCrossEntropy : convex conjugate functional</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KullbackLeiblerCrossEntropyConvexConj.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        prior : ``space`` `element-like`, optional</span>
<span class="sd">            Depending on the context, the prior, target or data</span>
<span class="sd">            distribution. It is assumed to be nonnegative.</span>
<span class="sd">            Default: if None it is take as the one-element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">KullbackLeiblerCrossEntropyConvexConj</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prior</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prior</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`prior` not in `domain`&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span> <span class="o">=</span> <span class="n">prior</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prior</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The prior in convex conjugate Kullback-Leibler Cross Entorpy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prior</span>

    <span class="c1"># TODO: update when integration operator is in place: issue #440</span>
<div class="viewcode-block" id="KullbackLeiblerCrossEntropyConvexConj._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj._call.html#odl.solvers.functional.default_functionals.KullbackLeiblerCrossEntropyConvexConj._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value in the point ``x``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">one</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">tmp</span></div>

    <span class="c1"># TODO: replace this when UFuncOperators is in place: PL #576</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">KLCrossEntCCGradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">KLCrossEntCCGradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">functional</span><span class="o">.</span><span class="n">prior</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">KLCrossEntCCGradient</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_convex_conj_kl_cross_entropy :</span>
<span class="sd">            `proximal factory` for convex conjugate of the KL cross entropy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_convex_conj_kl_cross_entropy</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                                     <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional of the conjugate KL-functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">KullbackLeiblerCrossEntropy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">)</span></div>


<div class="viewcode-block" id="SeparableSum"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.SeparableSum.html#odl.solvers.functional.default_functionals.SeparableSum">[docs]</a><span class="k">class</span> <span class="nc">SeparableSum</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The functional corresponding to separable sum of functionals.</span>

<span class="sd">    The separable sum of functionals ``f_1, f_2, ..., f_n`` is given by ::</span>

<span class="sd">        h(x_1, x_2, ..., x_n) = sum_i^n f_i(x_i)</span>

<span class="sd">    The separable sum is thus defined for any collection of functionals with</span>
<span class="sd">    the same range.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The separable sum of functionals :math:`f_1, f_2, ..., f_n` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        h(x_1, x_2, ..., x_n) = \sum_{i=1}^n f_i(x_i)</span>

<span class="sd">    It has several useful features that also distribute. For example, the</span>
<span class="sd">    gradient is a `DiagonalOperator`:</span>

<span class="sd">    .. math::</span>
<span class="sd">        [\nabla h](x_1, x_2, ..., x_n) =</span>
<span class="sd">        [\nabla f_1(x_i), \nabla f_2(x_i), ..., \nabla f_n(x_i)]</span>

<span class="sd">    The convex conjugate is also a separable sum:</span>

<span class="sd">    .. math::</span>
<span class="sd">        [h^*](y_1, y_2, ..., y_n) = \sum_{i=1}^n f_i^*(y_i)</span>

<span class="sd">    And the proximal distributes:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\sigma h}(x_1, x_2, ..., x_n) =</span>
<span class="sd">        [\mathrm{prox}_{\sigma f_1}(x_1),</span>
<span class="sd">         \mathrm{prox}_{\sigma f_2}(x_2),</span>
<span class="sd">         ...,</span>
<span class="sd">         \mathrm{prox}_{\sigma f_n}(x_n)].</span>

<span class="sd">    If :math:`\sigma = (\sigma_1, \sigma_2, \ldots, \sigma_n)` is a list</span>
<span class="sd">    of positive ``float``&#39;s, then it distributes, too:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{prox}_{\sigma h}(x_1, x_2, ..., x_n) =</span>
<span class="sd">        [\mathrm{prox}_{\sigma_1 f_1}(x_1),</span>
<span class="sd">         \mathrm{prox}_{\sigma_2 f_2}(x_2),</span>
<span class="sd">         ...,</span>
<span class="sd">         \mathrm{prox}_{\sigma_n f_n}(x_n)].</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SeparableSum.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.SeparableSum.html#odl.solvers.functional.default_functionals.SeparableSum.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">functionals</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        functional1, ..., functionalN : `Functional`</span>
<span class="sd">            The functionals in the sum.</span>
<span class="sd">            Can also be given as ``space, n`` with ``n`` integer,</span>
<span class="sd">            in which case the functional is repeated ``n`` times.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create functional ``f([x1, x2]) = ||x1||_1 + ||x2||_2``:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; l1 = odl.solvers.L1Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; l2 = odl.solvers.L2Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; f_sum = odl.solvers.SeparableSum(l1, l2)</span>

<span class="sd">        The `proximal` factory allows using vector-valued stepsizes:</span>

<span class="sd">        &gt;&gt;&gt; x = f_sum.domain.one()</span>
<span class="sd">        &gt;&gt;&gt; f_sum.proximal([0.5, 2.0])(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 0.5,  0.5,  0.5],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>

<span class="sd">        Create functional ``f([x1, ... ,xn]) = \sum_i ||xi||_1``:</span>

<span class="sd">        &gt;&gt;&gt; f_sum = odl.solvers.SeparableSum(l1, 5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a power space if the second argument is an integer</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">functionals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">functionals</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">functionals</span> <span class="o">=</span> <span class="p">[</span><span class="n">functionals</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">functionals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Functional</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">functionals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;all arguments must be `Functional` instances&#39;</span><span class="p">)</span>

        <span class="n">domains</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">domain</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functionals</span><span class="p">]</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="n">domains</span><span class="p">)</span>
        <span class="n">linear</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">is_linear</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functionals</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SeparableSum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__functionals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">functionals</span><span class="p">)</span></div>

<div class="viewcode-block" id="SeparableSum._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.SeparableSum._call.html#odl.solvers.functional.default_functionals.SeparableSum._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the separable sum evaluated in ``x``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fi</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">fi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functionals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The summands of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__functionals</span>

<div class="viewcode-block" id="SeparableSum.__getitem__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.SeparableSum.__getitem__.html#odl.solvers.functional.default_functionals.SeparableSum.__getitem__">[docs]</a>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self[index]``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : index expression</span>
<span class="sd">            Object determining which parts of the sum to extract.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subfunctional : `Functional` or `SeparableSum`</span>
<span class="sd">            Functional corresponding to the given indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; l1 = odl.solvers.L1Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; l2 = odl.solvers.L2Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; f_sum = odl.solvers.SeparableSum(l1, l2, 2*l2)</span>

<span class="sd">        Extract single sub-functional via integer index:</span>

<span class="sd">        &gt;&gt;&gt; f_sum[0]</span>
<span class="sd">        L1Norm(rn(3))</span>

<span class="sd">        Extract subset of functionals:</span>

<span class="sd">        &gt;&gt;&gt; f_sum[:2]</span>
<span class="sd">        SeparableSum(L1Norm(rn(3)), L2Norm(rn(3)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">SeparableSum</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">gradient</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="o">*</span><span class="n">gradients</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.</span>

<span class="sd">        The proximal operator separates over separable sums.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        proximal : combine_proximals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">proximals</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">proximal</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">combine_proximals</span><span class="p">(</span><span class="o">*</span><span class="n">proximals</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate functional.</span>

<span class="sd">        Convex conjugate distributes over separable sums, so the result is</span>
<span class="sd">        simply the separable sum of the convex conjugates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">convex_conjs</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">convex_conj</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">SeparableSum</span><span class="p">(</span><span class="o">*</span><span class="n">convex_conjs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">func_repr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functionals</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">func_repr</span><span class="p">)</span></div>


<div class="viewcode-block" id="QuadraticForm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.QuadraticForm.html#odl.solvers.functional.default_functionals.QuadraticForm">[docs]</a><span class="k">class</span> <span class="nc">QuadraticForm</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Functional for a general quadratic form ``x^T A x + b^T x + c``.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="QuadraticForm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.QuadraticForm.html#odl.solvers.functional.default_functionals.QuadraticForm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">constant</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        All parameters are optional, but at least one of ``op`` and ``vector``</span>
<span class="sd">        have to be provided in order to infer the space.</span>

<span class="sd">        The computed value is::</span>

<span class="sd">            x.inner(operator(x)) + vector.inner(x) + constant</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`, optional</span>
<span class="sd">            Operator for the quadratic part of the functional.</span>
<span class="sd">            ``None`` means that this part is ignored.</span>
<span class="sd">        vector : `LinearSpaceElement`, optional</span>
<span class="sd">            Vector for the linear part of the functional.</span>
<span class="sd">            ``None`` means that this part is ignored.</span>
<span class="sd">        constant : `Operator`, optional</span>
<span class="sd">            Constant offset of the functional.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;need to provide at least one of `operator` and &#39;</span>
                             <span class="s1">&#39;`vector`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">operator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">elif</span> <span class="n">vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">space</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">operator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="n">vector</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;domain of `operator` and space of `vector` need &#39;</span>
                             <span class="s1">&#39;to match&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">QuadraticForm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="p">(</span><span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">constant</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span> <span class="o">=</span> <span class="n">vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span> <span class="o">=</span> <span class="n">constant</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`constant` must be an element in the range of &#39;</span>
                             <span class="s1">&#39;the functional&#39;</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Operator for the quadratic part of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Vector for the linear part of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">constant</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constant offset of the functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__constant</span>

<div class="viewcode-block" id="QuadraticForm._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.QuadraticForm._call.html#odl.solvers.functional.default_functionals.QuadraticForm._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ConstantOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
                <span class="c1"># TODO: Acutally works otherwise, but needs more work</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`operator` must be linear&#39;</span><span class="p">)</span>

            <span class="c1"># Figure out if operator is symmetric</span>
            <span class="n">opadjoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span>
            <span class="k">if</span> <span class="n">opadjoint</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">:</span>
                <span class="n">gradient</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">+</span> <span class="n">opadjoint</span>

            <span class="c1"># Return gradient</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gradient</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">gradient</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The convex conjugate functional of the quadratic form.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The convex conjugate of the quadratic form :math:`&lt;x, Ax&gt; + &lt;b, x&gt; + c`</span>
<span class="sd">        is given by</span>

<span class="sd">        .. math::</span>
<span class="sd">            (&lt;x, Ax&gt; + &lt;b, x&gt; + c)^* (x) =</span>
<span class="sd">            &lt;(x - b), A^-1 (x - b)&gt; - c =</span>
<span class="sd">            &lt;x , A^-1 x&gt; - &lt;x, A^-* b&gt; - &lt;x, A^-1 b&gt; + &lt;b, A^-1 b&gt; - c.</span>

<span class="sd">        If the quadratic part of the functional is zero it is instead given</span>
<span class="sd">        by a translated indicator function on zero, i.e., if</span>

<span class="sd">        .. math::</span>
<span class="sd">            f(x) = &lt;b, x&gt; + c,</span>

<span class="sd">        then</span>

<span class="sd">        .. math::</span>
<span class="sd">            f^*(x^*) =</span>
<span class="sd">            \begin{cases}</span>
<span class="sd">                -c &amp; \text{if } x^* = b \\</span>
<span class="sd">                \infty &amp; \text{else.}</span>
<span class="sd">            \end{cases}</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        IndicatorZero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">IndicatorZero</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">constant</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tmp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tmp</span><span class="o">.</span><span class="n">translated</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Handle trivial case separately</span>
            <span class="k">return</span> <span class="n">QuadraticForm</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                                 <span class="n">constant</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">constant</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Compute the needed variables</span>
            <span class="n">opinv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="o">-</span><span class="n">opinv</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">-</span> <span class="n">opinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">opinv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">))</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">constant</span>

            <span class="c1"># Create new quadratic form</span>
            <span class="k">return</span> <span class="n">QuadraticForm</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">opinv</span><span class="p">,</span>
                                 <span class="n">vector</span><span class="o">=</span><span class="n">vector</span><span class="p">,</span>
                                 <span class="n">constant</span><span class="o">=</span><span class="n">constant</span><span class="p">)</span></div>


<div class="viewcode-block" id="NuclearNorm"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.NuclearNorm.html#odl.solvers.functional.default_functionals.NuclearNorm">[docs]</a><span class="k">class</span> <span class="nc">NuclearNorm</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Nuclear norm for matrix valued functions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a matrix-valued function</span>
<span class="sd">    :math:`f : \Omega \rightarrow \mathbb{R}^{n \times m}`,</span>
<span class="sd">    the nuclear norm with parameters :math:`p` and :math:`q` is defined by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left( \int_\Omega \|\sigma(f(x))\|_p^q d x \right)^{1/q},</span>

<span class="sd">    where :math:`\sigma(f(x))` is the vector of singular values of the matrix</span>
<span class="sd">    :math:`f(x)` and :math:`\| \cdot \|_p` is the usual :math:`p`-norm on</span>
<span class="sd">    :math:`\mathbb{R}^{\min(n, m)}`.</span>

<span class="sd">    For a detailed description of its properties, e.g, its proximal, convex</span>
<span class="sd">    conjugate and more, see [Du+2016].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Du+2016] J. Duran, M. Moeller, C. Sbert, and D. Cremers.</span>
<span class="sd">    *Collaborative Total Variation: A General Framework for Vectorial TV</span>
<span class="sd">    Models* SIAM Journal of Imaging Sciences 9(1): 116--151, 2016.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NuclearNorm.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.NuclearNorm.html#odl.solvers.functional.default_functionals.NuclearNorm.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">outer_exp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">singular_vector_exp</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `ProductSpace` of `ProductSpace` of `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        outer_exp : {1, 2, inf}, optional</span>
<span class="sd">            Exponent for the outer norm.</span>
<span class="sd">        singular_vector_exp : {1, 2, inf}, optional</span>
<span class="sd">            Exponent for the norm for the singular vectors.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Simple example, nuclear norm of matrix valued function with all ones</span>
<span class="sd">        in 3 points. The singular values are [2, 0], which has squared 2-norm</span>
<span class="sd">        2. Since there are 3 points, the expected total value is 6.</span>

<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(odl.ProductSpace(r3, 2), 2)</span>
<span class="sd">        &gt;&gt;&gt; norm = NuclearNorm(space)</span>
<span class="sd">        &gt;&gt;&gt; norm(space.one())</span>
<span class="sd">        6.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">)</span> <span class="ow">or</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ProductSpace</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space` must be a `ProductSpace` of &#39;</span>
                            <span class="s1">&#39;`ProductSpace`s&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">space</span><span class="o">.</span><span class="n">is_power_space</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">space</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_power_space</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`space` must be of the form `TensorSpace^(nxm)`&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">NuclearNorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outernorm</span> <span class="o">=</span> <span class="n">LpNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">exponent</span><span class="o">=</span><span class="n">outer_exp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pwisenorm</span> <span class="o">=</span> <span class="n">PointwiseNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                       <span class="n">exponent</span><span class="o">=</span><span class="n">singular_vector_exp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pshape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>

    <span class="k">def</span> <span class="nf">_asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert ``x`` to an array.</span>

<span class="sd">        Here the indices are changed such that the &quot;outer&quot; indices come last</span>
<span class="sd">        in order to have the access order as `numpy.linalg.svd` needs it.</span>

<span class="sd">        This is the inverse of `_asvector`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pshape</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">xij</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                <span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">arr</span>

    <span class="k">def</span> <span class="nf">_asvector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert ``arr`` to a `domain` element.</span>

<span class="sd">        This is the inverse of `_asarray`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<div class="viewcode-block" id="NuclearNorm._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.NuclearNorm._call.html#odl.solvers.functional.default_functionals.NuclearNorm._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>

        <span class="c1"># Convert to array with most</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">svd_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Rotate the axes so the svd-direction is first</span>
        <span class="n">s_reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">svd_diag</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Return nuclear norm</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outernorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pwisenorm</span><span class="p">(</span><span class="n">s_reordered</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the proximal operator.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            if ``outer_exp`` is not 1 or ``singular_vector_exp`` is not 1, 2 or</span>
<span class="sd">            infinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">outernorm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for &#39;</span>
                                      <span class="s1">&#39;`outer_exp==1`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`proximal` only implemented for &#39;</span>
                                      <span class="s1">&#39;`singular_vector_exp` in [1, 2, inf]&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">nddot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Compute pointwise matrix product in the last indices.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij,...jk-&gt;...ik&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># Add epsilon to fix rounding errors, i.e. make sure that when we</span>
        <span class="c1"># project on the unit ball, we actually end up slightly inside the unit</span>
        <span class="c1"># ball. Without, we may end up slightly outside.</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">resolution</span> <span class="o">*</span> <span class="mi">10</span>

        <span class="k">class</span> <span class="nc">NuclearNormProximal</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Proximal operator of `NuclearNorm`.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">NuclearNormProximal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">func</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">_asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># Compute SVD</span>
                <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># transpose pointwise</span>
                <span class="n">V</span> <span class="o">=</span> <span class="n">Vt</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

                <span class="c1"># Take pseudoinverse of s</span>
                <span class="n">sinv</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">sinv</span><span class="p">[</span><span class="n">sinv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">sinv</span><span class="p">[</span><span class="n">sinv</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

                <span class="c1"># Take pointwise proximal operator of s w.r.t. the norm</span>
                <span class="c1"># on the singular vectors</span>
                <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">abss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span>
                    <span class="n">sprox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">abss</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">func</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">s_reordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">snorm</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">pwisenorm</span><span class="p">(</span><span class="n">s_reordered</span><span class="p">)</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>
                    <span class="n">snorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">snorm</span><span class="p">)</span>
                    <span class="n">sprox</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">snorm</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span>
                <span class="k">elif</span> <span class="n">func</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">snorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">snorm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">snorm</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">snorm</span><span class="p">)</span>
                    <span class="n">sprox</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">/</span> <span class="n">snorm</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span>

                <span class="c1"># Compute s matrix</span>
                <span class="n">sproxsinv</span> <span class="o">=</span> <span class="p">(</span><span class="n">sprox</span> <span class="o">*</span> <span class="n">sinv</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span>

                <span class="c1"># Compute the final result</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">nddot</span><span class="p">(</span><span class="n">nddot</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">sproxsinv</span> <span class="o">*</span> <span class="n">Vt</span><span class="p">)</span>

                <span class="c1"># Cast to vector and return. Note array and vector have</span>
                <span class="c1"># different shapes.</span>
                <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">_asvector</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
                <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1">.proximal(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">NuclearNormProximal</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convex conjugate of the nuclear norm.</span>

<span class="sd">        The convex conjugate is the indicator function on the unit ball of</span>
<span class="sd">        the dual norm where the dual norm is obtained by taking the conjugate</span>
<span class="sd">        exponent of both the outer and singular vector exponents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IndicatorNuclearNormUnitBall</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outernorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">),</span>
            <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">outernorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorNuclearNormUnitBall"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall.html#odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall">[docs]</a><span class="k">class</span> <span class="nc">IndicatorNuclearNormUnitBall</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicator on unit ball of nuclear norm for matrix valued functions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a matrix-valued function</span>
<span class="sd">    :math:`f : \Omega \rightarrow \mathbb{R}^{n \times m}`,</span>
<span class="sd">    the nuclear norm with parameters :math:`p` and :math:`q` is defined by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left( \int_\Omega \|\sigma(f(x))\|_p^q d x \right)^{1/q},</span>

<span class="sd">    where :math:`\sigma(f(x))` is the vector of singular values of the matrix</span>
<span class="sd">    :math:`f(x)` and :math:`\| \cdot \|_p` is the usual :math:`p`-norm on</span>
<span class="sd">    :math:`\mathbb{R}^{\min(n, m)}`.</span>

<span class="sd">    This function is defined as the indicator on the unit ball of the nuclear</span>
<span class="sd">    norm, that is, 0 if the nuclear norm is less than 1, and infinity else.</span>

<span class="sd">    For a detailed description of its properties, e.g, its proximal, convex</span>
<span class="sd">    conjugate and more, see [Du+2016].</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [Du+2016] J. Duran, M. Moeller, C. Sbert, and D. Cremers.</span>
<span class="sd">    *Collaborative Total Variation: A General Framework for Vectorial TV</span>
<span class="sd">    Models* SIAM Journal of Imaging Sciences 9(1): 116--151, 2016.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorNuclearNormUnitBall.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall.html#odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">outer_exp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">singular_vector_exp</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `ProductSpace` of `ProductSpace` of `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        outer_exp : {1, 2, inf}, optional</span>
<span class="sd">            Exponent for the outer norm.</span>
<span class="sd">        singular_vector_exp : {1, 2, inf}, optional</span>
<span class="sd">            Exponent for the norm for the singular vectors.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Simple example, nuclear norm of matrix valued function with all ones</span>
<span class="sd">        in 3 points. The singular values are [2, 0], which has squared 2-norm</span>
<span class="sd">        2. Since there are 3 points, the expected total value is 6.</span>
<span class="sd">        Since the nuclear norm is larger than 1, the indicator is infinity.</span>

<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(odl.ProductSpace(r3, 2), 2)</span>
<span class="sd">        &gt;&gt;&gt; norm = IndicatorNuclearNormUnitBall(space)</span>
<span class="sd">        &gt;&gt;&gt; norm(space.one())</span>
<span class="sd">        inf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorNuclearNormUnitBall</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span> <span class="o">=</span> <span class="n">NuclearNorm</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">outer_exp</span><span class="p">,</span> <span class="n">singular_vector_exp</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndicatorNuclearNormUnitBall._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall._call.html#odl.solvers.functional.default_functionals.IndicatorNuclearNormUnitBall._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
        <span class="n">x_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x_norm</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The proximal operator.&quot;&quot;&quot;</span>
        <span class="c1"># Implement proximal via duality</span>
        <span class="k">return</span> <span class="n">proximal_convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convex_conj</span><span class="o">.</span><span class="n">proximal</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convex conjugate of the unit ball indicator of the nuclear norm.</span>

<span class="sd">        The convex conjugate is the dual nuclear norm where the dual norm is</span>
<span class="sd">        obtained by taking the conjugate exponent of both the outer and</span>
<span class="sd">        singular vector exponents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NuclearNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                           <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="o">.</span><span class="n">outernorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">),</span>
                           <span class="n">conj_exponent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="o">.</span><span class="n">outernorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span><span class="o">.</span><span class="n">pwisenorm</span><span class="o">.</span><span class="n">exponent</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorSimplex"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSimplex.html#odl.solvers.functional.default_functionals.IndicatorSimplex">[docs]</a><span class="k">class</span> <span class="nc">IndicatorSimplex</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicator functional of simplex.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F` is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x)</span>
<span class="sd">        =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            0 &amp; \text{if } x_i \geq 0 \forall i \text{ and } \sum_i x_i = r \</span>
<span class="sd">            +\infty &amp; \text{else.}</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    where :math:`r` is the diameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorSimplex.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSimplex.html#odl.solvers.functional.default_functionals.IndicatorSimplex.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">diameter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sum_rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        diameter : positive float, optional</span>
<span class="sd">            Diameter of the simplex.</span>
<span class="sd">        sum_rtol : float, optional</span>
<span class="sd">            Relative tolerance for sum comparison.</span>
<span class="sd">            Default:</span>
<span class="sd">                - ``space.dtype == &#39;float64&#39;``: ``1e-10 * space.size``</span>
<span class="sd">                - Otherwise: ``1e-6 * space.size``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Example where a point lies outside the unit simplex ...</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; ind_simplex = IndicatorSimplex(space)</span>
<span class="sd">        &gt;&gt;&gt; x = space.one()</span>
<span class="sd">        &gt;&gt;&gt; ind_simplex(x)</span>
<span class="sd">        inf</span>

<span class="sd">        ... and one where it lies inside the unit simplex.</span>

<span class="sd">        &gt;&gt;&gt; x /= x.ufuncs.sum()</span>
<span class="sd">        &gt;&gt;&gt; ind_simplex(x)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorSimplex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">diameter</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sum_rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">space</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
                <span class="n">sum_rtol</span> <span class="o">=</span> <span class="mf">1e-10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_rtol</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_rtol</span> <span class="o">=</span> <span class="n">sum_rtol</span></div>

<div class="viewcode-block" id="IndicatorSimplex._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSimplex._call.html#odl.solvers.functional.default_functionals.IndicatorSimplex._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>

        <span class="n">sum_constr</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_rtol</span>

        <span class="n">nonneq_constr</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">sum_constr</span> <span class="ow">and</span> <span class="n">nonneq_constr</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The indicator functional is not differentiable over the entire domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not implemented&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.&quot;&quot;&quot;</span>

        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="n">diameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diameter</span>

        <span class="k">class</span> <span class="nc">ProximalSimplex</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Proximal operator implemented by the algorithm of [D+2008].</span>

<span class="sd">            [D+2008] Duchi, J., Shalev-Shwartz, S., Singer, Y., and Chandra, T.</span>
<span class="sd">            *Efficient Projections onto the L1-ball for Learning in High</span>
<span class="sd">            dimensions*. ICML 2008, pp. 272-279.</span>
<span class="sd">            http://doi.org/10.1145/1390156.1390191</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ProximalSimplex</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>

                <span class="c1"># projection onto simplex</span>
                <span class="n">proj_simplex</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ProximalSimplex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not yet implemented&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndicatorSumConstraint"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSumConstraint.html#odl.solvers.functional.default_functionals.IndicatorSumConstraint">[docs]</a><span class="k">class</span> <span class="nc">IndicatorSumConstraint</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Indicator functional of a unit sum constraint.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The functional :math:`F` is given by:</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x)</span>
<span class="sd">        =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            0 &amp; \text{if } \sum_i x_i = 1 \</span>
<span class="sd">            +\infty &amp; \text{else.}</span>
<span class="sd">        \end{cases}</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IndicatorSumConstraint.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSumConstraint.html#odl.solvers.functional.default_functionals.IndicatorSumConstraint.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">sum_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sum_rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `DiscretizedSpace` or `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        sum_value : float</span>
<span class="sd">            Desired value of the sum constraint.</span>
<span class="sd">        sum_rtol : float, optional</span>
<span class="sd">            Relative tolerance for sum comparison. If set to None, the default</span>
<span class="sd">            is ``space.size`` times ``1e-10`` when ``space.dtype`` is</span>
<span class="sd">            ``float64`` and ``1e-6`` otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Example where a point does not have unit sum ...</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; ind_sum = IndicatorSumConstraint(space)</span>
<span class="sd">        &gt;&gt;&gt; x = space.one()</span>
<span class="sd">        &gt;&gt;&gt; ind_sum(x)</span>
<span class="sd">        inf</span>

<span class="sd">        ... and one where it does.</span>

<span class="sd">        &gt;&gt;&gt; x /= x.ufuncs.sum()</span>
<span class="sd">        &gt;&gt;&gt; ind_sum(x)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IndicatorSumConstraint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sum_rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">space</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
                <span class="n">sum_rtol</span> <span class="o">=</span> <span class="mf">1e-10</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sum_rtol</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_rtol</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sum_rtol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sum_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sum_value</span><span class="p">)</span></div>

<div class="viewcode-block" id="IndicatorSumConstraint._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.IndicatorSumConstraint._call.html#odl.solvers.functional.default_functionals.IndicatorSumConstraint._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_rtol</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The indicator functional is not differentiable over the entire domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not implemented&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `proximal factory` of the functional.&quot;&quot;&quot;</span>

        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>

        <span class="k">class</span> <span class="nc">ProximalSum</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Proximal operator.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ProximalSum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>

                <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_value</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">offset</span>

        <span class="k">return</span> <span class="n">ProximalSum</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate.&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not yet implemented&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span></div>


<div class="viewcode-block" id="MoreauEnvelope"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.MoreauEnvelope.html#odl.solvers.functional.default_functionals.MoreauEnvelope">[docs]</a><span class="k">class</span> <span class="nc">MoreauEnvelope</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Moreau envelope of a convex functional.</span>

<span class="sd">    The Moreau envelope is a way to smooth an arbitrary convex functional</span>
<span class="sd">    such that its gradient can be computed given the proximal of the original</span>
<span class="sd">    functional.</span>
<span class="sd">    The new functional has the same critical points as the original.</span>
<span class="sd">    It is also called the Moreau-Yosida regularization.</span>

<span class="sd">    Note that the only computable property of the Moreau envelope is the</span>
<span class="sd">    gradient, the functional itself cannot be evaluated efficiently.</span>

<span class="sd">    See `Proximal Algorithms`_ for more information.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Moreau envelope of a convex functional</span>
<span class="sd">    :math:`f : \mathcal{X} \rightarrow \mathbb{R}` multiplied by a scalar</span>
<span class="sd">    :math:`\sigma` is defined by</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathrm{env}_{\sigma f}(x) =</span>
<span class="sd">        \inf_{y \in \mathcal{X}}</span>
<span class="sd">        \left\{ \frac{1}{2 \sigma} \| x - y \|_2^2 + f(y) \right\}</span>

<span class="sd">    The gradient of the envelope is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        [\nabla \mathrm{env}_{\sigma f}](x) =</span>
<span class="sd">        \frac{1}{\sigma} (x - \mathrm{prox}_{\sigma f}(x))</span>

<span class="sd">    Example: if :math:`f = \| \cdot \|_1`, then</span>

<span class="sd">    .. math::</span>
<span class="sd">        [\mathrm{env}_{\sigma  \| \cdot \|_1}(x)]_i =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{1}{2 \sigma} x_i^2 &amp; \text{if } |x_i| \leq \sigma \\</span>
<span class="sd">            |x_i| - \frac{\sigma}{2} &amp; \text{if } |x_i| &gt; \sigma,</span>
<span class="sd">        \end{cases}</span>

<span class="sd">    which is the usual Huber functional.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. _Proximal Algorithms: \</span>
<span class="sd">https://web.stanford.edu/~boyd/papers/pdf/prox_algs.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MoreauEnvelope.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.MoreauEnvelope.html#odl.solvers.functional.default_functionals.MoreauEnvelope.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functional</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize an instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        functional : `Functional`</span>
<span class="sd">            The functional ``f`` in the definition of the Moreau envelope that</span>
<span class="sd">            is to be smoothed.</span>
<span class="sd">        sigma : positive float, optional</span>
<span class="sd">            The scalar ``sigma`` in the definition of the Moreau envelope.</span>
<span class="sd">            Larger values mean stronger smoothing.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create smoothed l1 norm:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; l1_norm = odl.solvers.L1Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; smoothed_l1 = MoreauEnvelope(l1_norm)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MoreauEnvelope</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__functional</span> <span class="o">=</span> <span class="n">functional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sigma</span> <span class="o">=</span> <span class="n">sigma</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The functional that has been regularized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__functional</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Regularization constant, larger means stronger regularization.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The gradient operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ScalingOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> <span class="o">-</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">proximal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span></div>


<div class="viewcode-block" id="Huber"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.Huber.html#odl.solvers.functional.default_functionals.Huber">[docs]</a><span class="k">class</span> <span class="nc">Huber</span><span class="p">(</span><span class="n">Functional</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The Huber functional.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Huber norm is the integral over a smoothed norm. In detail, it is given</span>
<span class="sd">    by</span>

<span class="sd">    .. math::</span>
<span class="sd">        F(x) = \int_\Omega f_{\gamma}(||x(y)||_2) dy</span>

<span class="sd">    where :math:`||\cdot||_2` denotes the Euclidean norm for vector-valued</span>
<span class="sd">    functions which reduces to the absolute value for scalar-valued functions.</span>
<span class="sd">    The function :math:`f` with smoothing :math:`\gamma` is given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        f_{\gamma}(t) =</span>
<span class="sd">        \begin{cases}</span>
<span class="sd">            \frac{1}{2 \gamma} t^2 &amp; \text{if } |t| \leq \gamma \\</span>
<span class="sd">            |t| - \frac{\gamma}{2} &amp; \text{else}</span>
<span class="sd">        \end{cases}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Huber.__init__"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.Huber.html#odl.solvers.functional.default_functionals.Huber.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">gamma</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `TensorSpace`</span>
<span class="sd">            Domain of the functional.</span>
<span class="sd">        gamma : float</span>
<span class="sd">            Smoothing parameter of the Huber functional. If ``gamma = 0``,</span>
<span class="sd">            the functional is non-smooth and corresponds to the usual L1 norm.</span>
<span class="sd">            For ``gamma &gt; 0``, it has a ``1/gamma``-Lipschitz gradient so that</span>
<span class="sd">            its convex conjugate is ``gamma``-strongly convex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Example of initializing the Huber functional:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(0, 1, 14)</span>
<span class="sd">        &gt;&gt;&gt; gamma = 0.1</span>
<span class="sd">        &gt;&gt;&gt; huber_norm = odl.solvers.Huber(space, gamma=0.1)</span>

<span class="sd">        Check that if all elements are &gt; ``gamma`` we get the L1-norm up to a</span>
<span class="sd">        constant:</span>

<span class="sd">        &gt;&gt;&gt; x = 2 * gamma * space.one()</span>
<span class="sd">        &gt;&gt;&gt; tol = 1e-5</span>
<span class="sd">        &gt;&gt;&gt; constant = gamma / 2 * space.one().inner(space.one())</span>
<span class="sd">        &gt;&gt;&gt; f = odl.solvers.L1Norm(space) - constant</span>
<span class="sd">        &gt;&gt;&gt; abs(huber_norm(x) - f(x)) &lt; tol</span>
<span class="sd">        True</span>

<span class="sd">        Check that if all elements are &lt; ``gamma`` we get the squared L2-norm</span>
<span class="sd">        times the weight ``1/(2*gamma)``:</span>

<span class="sd">        &gt;&gt;&gt; x = gamma / 2 * space.one()</span>
<span class="sd">        &gt;&gt;&gt; f = 1 / (2 * gamma) * odl.solvers.L2NormSquared(space)</span>
<span class="sd">        &gt;&gt;&gt; abs(huber_norm(x) - f(x)) &lt; tol</span>
<span class="sd">        True</span>

<span class="sd">        Compare Huber- and L1-norm for vanishing smoothing ``gamma=0``:</span>

<span class="sd">        &gt;&gt;&gt; x = odl.phantom.white_noise(space)</span>
<span class="sd">        &gt;&gt;&gt; huber_norm = odl.solvers.Huber(space, gamma=0)</span>
<span class="sd">        &gt;&gt;&gt; l1_norm = odl.solvers.L1Norm(space)</span>
<span class="sd">        &gt;&gt;&gt; abs(huber_norm(x) - l1_norm(x)) &lt; tol</span>
<span class="sd">        True</span>

<span class="sd">        Redo previous example for a product space in two dimensions:</span>

<span class="sd">        &gt;&gt;&gt; domain = odl.uniform_discr([0, 0], [1, 1], [5, 5])</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(domain, 2)</span>
<span class="sd">        &gt;&gt;&gt; x = odl.phantom.white_noise(space)</span>
<span class="sd">        &gt;&gt;&gt; huber_norm = odl.solvers.Huber(space, gamma=0)</span>
<span class="sd">        &gt;&gt;&gt; l1_norm = odl.solvers.GroupL1Norm(space, 2)</span>
<span class="sd">        &gt;&gt;&gt; abs(huber_norm(x) - l1_norm(x)) &lt; tol</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__gamma</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grad_lipschitz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grad_lipschitz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Huber</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="o">=</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">grad_lipschitz</span><span class="o">=</span><span class="n">grad_lipschitz</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The smoothing parameter of the Huber norm functional.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gamma</span>

<div class="viewcode-block" id="Huber._call"><a class="viewcode-back" href="../../../../generated/odl.solvers.functional.default_functionals.Huber._call.html#odl.solvers.functional.default_functionals.Huber._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">PointwiseNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">square</span><span class="p">()</span>
            <span class="n">tmp</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">norm</span>

        <span class="k">return</span> <span class="n">tmp</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">tmp</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">one</span><span class="p">())</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">convex_conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The convex conjugate&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">GroupL1Norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="n">L1Norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FunctionalQuadraticPerturb</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">convex_conj</span><span class="p">,</span>
                                          <span class="n">quadratic_coeff</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">proximal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the ``proximal factory`` of the functional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.solvers.nonsmooth.proximal_operators.proximal_huber :</span>
<span class="sd">            `proximal factory` for the Huber norm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">proximal_huber</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Gradient operator of the functional.</span>

<span class="sd">        The gradient of the Huber functional is given by</span>

<span class="sd">            .. math::</span>
<span class="sd">                \nabla f_{\gamma}(x) =</span>
<span class="sd">                \begin{cases}</span>
<span class="sd">                \frac{1}{\gamma} x &amp; \text{if } \|x\|_2 \leq \gamma \\</span>
<span class="sd">                \frac{1}{\|x\|_2} x &amp; \text{else}</span>
<span class="sd">                \end{cases}.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Check that the gradient norm is less than the norm of the one element:</span>

<span class="sd">        &gt;&gt;&gt; space = odl.uniform_discr(0, 1, 14)</span>
<span class="sd">        &gt;&gt;&gt; norm_one = space.one().norm()</span>
<span class="sd">        &gt;&gt;&gt; x = odl.phantom.white_noise(space)</span>
<span class="sd">        &gt;&gt;&gt; huber_norm = odl.solvers.Huber(space, gamma=0.1)</span>
<span class="sd">        &gt;&gt;&gt; grad = huber_norm.gradient(x)</span>
<span class="sd">        &gt;&gt;&gt; tol = 1e-5</span>
<span class="sd">        &gt;&gt;&gt; grad.norm() &lt;=  norm_one + tol</span>
<span class="sd">        True</span>

<span class="sd">        Redo previous example for a product space in two dimensions:</span>

<span class="sd">        &gt;&gt;&gt; domain = odl.uniform_discr([0, 0], [1, 1], [5, 5])</span>
<span class="sd">        &gt;&gt;&gt; space = odl.ProductSpace(domain, 2)</span>
<span class="sd">        &gt;&gt;&gt; norm_one = space.one().norm()</span>
<span class="sd">        &gt;&gt;&gt; x = odl.phantom.white_noise(space)</span>
<span class="sd">        &gt;&gt;&gt; huber_norm = odl.solvers.Huber(space, gamma=0.2)</span>
<span class="sd">        &gt;&gt;&gt; grad = huber_norm.gradient(x)</span>
<span class="sd">        &gt;&gt;&gt; tol = 1e-5</span>
<span class="sd">        &gt;&gt;&gt; grad.norm() &lt;=  norm_one + tol</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">functional</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">class</span> <span class="nc">HuberGradient</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

            <span class="sd">&quot;&quot;&quot;The gradient operator of this functional.&quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Initialize a new instance.&quot;&quot;&quot;</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">HuberGradient</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                    <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;Apply the gradient operator to the given point.&quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">PointwiseNorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>

                <span class="n">grad</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">functional</span><span class="o">.</span><span class="n">gamma</span>

                <span class="n">index</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">functional</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">gi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
                        <span class="n">gi</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grad</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">grad</span>

        <span class="k">return</span> <span class="n">HuberGradient</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return ``repr(self)``.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>