

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.trafos.fourier &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.trafos.fourier</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.trafos.fourier</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Discretized Fourier transform on L^p spaces.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.discr</span> <span class="kn">import</span> <span class="n">DiscretizedSpace</span><span class="p">,</span> <span class="n">uniform_discr</span>
<span class="kn">from</span> <span class="nn">odl.operator</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">odl.set</span> <span class="kn">import</span> <span class="n">ComplexNumbers</span><span class="p">,</span> <span class="n">RealNumbers</span>
<span class="kn">from</span> <span class="nn">odl.trafos.backends.pyfftw_bindings</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PYFFTW_AVAILABLE</span><span class="p">,</span> <span class="n">_flag_pyfftw_to_odl</span><span class="p">,</span> <span class="n">pyfftw_call</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.trafos.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dft_postprocess_data</span><span class="p">,</span> <span class="n">dft_preprocess_data</span><span class="p">,</span> <span class="n">reciprocal_grid</span><span class="p">,</span>
    <span class="n">reciprocal_space</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">complex_dtype</span><span class="p">,</span> <span class="n">conj_exponent</span><span class="p">,</span> <span class="n">dtype_repr</span><span class="p">,</span> <span class="n">is_complex_floating_dtype</span><span class="p">,</span>
    <span class="n">is_real_dtype</span><span class="p">,</span> <span class="n">normalized_axes_tuple</span><span class="p">,</span> <span class="n">normalized_scalar_param_list</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;DiscreteFourierTransform&#39;</span><span class="p">,</span> <span class="s1">&#39;DiscreteFourierTransformInverse&#39;</span><span class="p">,</span>
           <span class="s1">&#39;FourierTransform&#39;</span><span class="p">,</span> <span class="s1">&#39;FourierTransformInverse&#39;</span><span class="p">)</span>


<span class="n">_SUPPORTED_FOURIER_IMPLS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;numpy&#39;</span><span class="p">,)</span>
<span class="n">_DEFAULT_FOURIER_IMPL</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span>
<span class="k">if</span> <span class="n">PYFFTW_AVAILABLE</span><span class="p">:</span>
    <span class="n">_SUPPORTED_FOURIER_IMPLS</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;pyfftw&#39;</span><span class="p">,)</span>
    <span class="n">_DEFAULT_FOURIER_IMPL</span> <span class="o">=</span> <span class="s1">&#39;pyfftw&#39;</span>


<div class="viewcode-block" id="DiscreteFourierTransformBase"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformBase.html#odl.trafos.fourier.DiscreteFourierTransformBase">[docs]</a><span class="k">class</span> <span class="nc">DiscreteFourierTransformBase</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for discrete fourier transform classes.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiscreteFourierTransformBase.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformBase.html#odl.trafos.fourier.DiscreteFourierTransformBase.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                 <span class="n">halfcomplex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        All parameters are given according to the specifics of the forward</span>
<span class="sd">        transform. The ``inverse`` parameter is used to control conversions</span>
<span class="sd">        for the inverse transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inverse : bool</span>
<span class="sd">            If ``True``, the inverse transform is created, otherwise the</span>
<span class="sd">            forward transform.</span>
<span class="sd">        domain : `DiscretizedSpace`</span>
<span class="sd">            Domain of the Fourier transform. If its</span>
<span class="sd">            `DiscretizedSpace.exponent` is equal to 2.0, this operator has</span>
<span class="sd">            an adjoint which is equal to the inverse.</span>
<span class="sd">        range : `DiscretizedSpace`, optional</span>
<span class="sd">            Range of the Fourier transform. If not given, the range</span>
<span class="sd">            is determined from ``domain`` and the other parameters as</span>
<span class="sd">            a `uniform_discr` with exponent unit cell size and exponent</span>
<span class="sd">            ``p / (p - 1)`` (read as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;).</span>
<span class="sd">        axes : int or sequence of ints, optional</span>
<span class="sd">            Dimensions in which a transform is to be calculated. ``None``</span>
<span class="sd">            means all axes.</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent.</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, calculate only the negative frequency part</span>
<span class="sd">            along the last axis in ``axes`` for real input. This</span>
<span class="sd">            reduces the size of the range to ``floor(N[i]/2) + 1`` in</span>
<span class="sd">            this axis ``i``, where ``N`` is the shape of the input</span>
<span class="sd">            arrays.</span>
<span class="sd">            Otherwise, calculate the full complex FFT. If ``dom_dtype``</span>
<span class="sd">            is a complex type, this option has no effect.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;, ``None``}, optional</span>
<span class="sd">            Backend for the FFT implementation. The &#39;pyfftw&#39; backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">DiscretizedSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> is not a `DiscretizedSpace` instance&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">DiscretizedSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> is not a `DiscretizedSpace` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>

        <span class="c1"># Implementation</span>
        <span class="k">if</span> <span class="n">impl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">impl</span> <span class="o">=</span> <span class="n">_DEFAULT_FOURIER_IMPL</span>
        <span class="n">impl</span><span class="p">,</span> <span class="n">impl_in</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">impl</span>
        <span class="k">if</span> <span class="n">impl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SUPPORTED_FOURIER_IMPLS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`impl` &#39;</span><span class="si">{}</span><span class="s2">&#39; not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">impl_in</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__impl</span> <span class="o">=</span> <span class="n">impl</span>

        <span class="c1"># Axes</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__axes</span> <span class="o">=</span> <span class="n">normalized_axes_tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="c1"># Half-complex</span>
        <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">halfcomplex</span><span class="p">)</span>

        <span class="n">ran_dtype</span> <span class="o">=</span> <span class="n">complex_dtype</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Sign of the transform</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`sign` &#39;</span><span class="si">{}</span><span class="s2">&#39; not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sign</span><span class="p">))</span>
        <span class="n">fwd_sign</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">inverse</span> <span class="k">else</span> <span class="n">sign</span>
        <span class="k">if</span> <span class="n">fwd_sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot combine sign &#39;+&#39; with a half-complex &quot;</span>
                             <span class="s2">&quot;transform&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sign</span> <span class="o">=</span> <span class="n">sign</span>

        <span class="c1"># Calculate the range</span>
        <span class="n">ran_shape</span> <span class="o">=</span> <span class="n">reciprocal_grid</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">impl</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">tspace</span><span class="o">.</span><span class="n">impl</span>

            <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">ran_shape</span><span class="p">)</span>
            <span class="nb">range</span> <span class="o">=</span> <span class="n">uniform_discr</span><span class="p">(</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">shape</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">ran_dtype</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span>
                <span class="n">nodes_on_bdry</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=</span><span class="n">conj_exponent</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">range</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ran_shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected range shape </span><span class="si">{}</span><span class="s1">, got </span><span class="si">{}</span><span class="s1">.&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ran_shape</span><span class="p">,</span> <span class="nb">range</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">range</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">ran_dtype</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected range data type </span><span class="si">{}</span><span class="s1">, got </span><span class="si">{}</span><span class="s1">.&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dtype_repr</span><span class="p">(</span><span class="n">ran_dtype</span><span class="p">),</span>
                                           <span class="n">dtype_repr</span><span class="p">(</span><span class="nb">range</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteFourierTransformBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteFourierTransformBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="DiscreteFourierTransformBase._call"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformBase._call.html#odl.trafos.fourier.DiscreteFourierTransformBase._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x, out[, **kwargs])``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            Discretized function to be transformed</span>
<span class="sd">        out : `range` element</span>
<span class="sd">            Element to which the output is written</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the ``pyfftw_call`` function for ``**kwargs`` options.</span>
<span class="sd">        The parameters ``axes`` and ``halfcomplex`` cannot be</span>
<span class="sd">        overridden.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.trafos.backends.pyfftw_bindings.pyfftw_call :</span>
<span class="sd">            Call pyfftw backend directly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Implement zero padding</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_numpy</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asarray</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_pyfftw</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="n">out</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Backend for the FFT implementation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__impl</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Axes along the FT is calculated by this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sign of the complex exponent in the transform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sign</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halfcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the last transform axis is halved.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint transform, equal to the inverse.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        inverse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;no adjoint defined for exponents (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">) != (2, 2)&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse Fourier transform.</span>

<span class="sd">        Abstract method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` using numpy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Input array to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` using pyfftw.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Input array to be transformed</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Output array storing the result</span>
<span class="sd">        flags : sequence of strings, optional</span>
<span class="sd">            Flags for the transform. ``&#39;FFTW_UNALIGNED&#39;`` is not</span>
<span class="sd">            supported, and ``&#39;FFTW_DESTROY_INPUT&#39;`` is enabled by</span>
<span class="sd">            default. See the `pyfftw API documentation`_</span>
<span class="sd">            for futher information.</span>
<span class="sd">            Default: ``(&#39;FFTW_MEASURE&#39;,)``</span>
<span class="sd">        threads : positive int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>
<span class="sd">        planning_timelimit : float or ``None``, optional</span>
<span class="sd">            Rough upper limit in seconds for the planning step of the</span>
<span class="sd">            transform. ``None`` means no limit. See the</span>
<span class="sd">            `pyfftw API documentation`_ for futher information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform. If ``out`` was given, the returned</span>
<span class="sd">            object is a reference to it.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. _pyfftw API documentation:</span>
<span class="sd">           https://pyfftw.readthedocs.io</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;normalise_idft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Using `False` here</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_flag_pyfftw_to_odl</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span>
                     <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;FFTW_MEASURE&#39;</span><span class="p">,)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;unaligned&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;destroy_input&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">effort</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">flags</span> <span class="k">else</span> <span class="s1">&#39;measure&#39;</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">planning_effort</span><span class="o">=</span><span class="n">effort</span><span class="p">,</span>
            <span class="n">fftw_plan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span><span class="p">,</span> <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="DiscreteFourierTransformBase.init_fftw_plan"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformBase.init_fftw_plan.html#odl.trafos.fourier.DiscreteFourierTransformBase.init_fftw_plan">[docs]</a>    <span class="k">def</span> <span class="nf">init_fftw_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">planning_effort</span><span class="o">=</span><span class="s1">&#39;measure&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the FFTW plan for this transform for later use.</span>

<span class="sd">        If the implementation of this operator is not ``&#39;pyfftw&#39;``, this</span>
<span class="sd">        method should not be called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        planning_effort : str, optional</span>
<span class="sd">            Flag for the amount of effort put into finding an optimal</span>
<span class="sd">            FFTW plan. See the `FFTW doc on planner flags</span>
<span class="sd">            &lt;http://www.fftw.org/fftw3_doc/Planner-Flags.html&gt;`_.</span>
<span class="sd">            Options: {&#39;estimate&#39;, &#39;measure&#39;, &#39;patient&#39;, &#39;exhaustive&#39;}</span>
<span class="sd">        planning_timelimit : float, optional</span>
<span class="sd">            Limit planning time to roughly this amount of seconds.</span>
<span class="sd">            Default: None (no limit)</span>
<span class="sd">        threads : int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `impl` is not ``&#39;pyfftw&#39;``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To save memory, clear the plan when the transform is no longer</span>
<span class="sd">        used (the plan stores 2 arrays).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        clear_fftw_plan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;pyfftw&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot create fftw plan without fftw backend&#39;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;planning_timelimit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">planning_effort</span><span class="o">=</span><span class="n">planning_effort</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="DiscreteFourierTransformBase.clear_fftw_plan"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformBase.clear_fftw_plan.html#odl.trafos.fourier.DiscreteFourierTransformBase.clear_fftw_plan">[docs]</a>    <span class="k">def</span> <span class="nf">clear_fftw_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the FFTW plan of this transform.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `impl` is not ``&#39;pyfftw&#39;``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If no plan exists, this is a no-op.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;pyfftw&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot create fftw plan without fftw backend&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="DiscreteFourierTransform"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransform.html#odl.trafos.fourier.DiscreteFourierTransform">[docs]</a><span class="k">class</span> <span class="nc">DiscreteFourierTransform</span><span class="p">(</span><span class="n">DiscreteFourierTransformBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Plain forward DFT, only evaluating the trigonometric sum.</span>

<span class="sd">    This operator calculates the forward DFT::</span>

<span class="sd">        f_hat[k] = sum_j( f[j] * exp(-+ 1j*2*pi * j*k/N) )</span>

<span class="sd">    without any further shifting or scaling compensation. See the</span>
<span class="sd">    `Numpy FFT documentation`_, the `pyfftw API documentation`_ or</span>
<span class="sd">    `What FFTW really computes`_ for further information.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.fft.fftn : n-dimensional FFT routine</span>
<span class="sd">    numpy.fft.rfftn : n-dimensional half-complex FFT</span>
<span class="sd">    odl.trafos.backends.pyfftw_bindings.pyfftw_call : apply an FFTW transform</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. _Numpy FFT documentation:</span>
<span class="sd">        http://docs.scipy.org/doc/numpy/reference/routines.fft.html</span>
<span class="sd">    .. _pyfftw API documentation:</span>
<span class="sd">       https://pyfftw.readthedocs.io</span>
<span class="sd">    .. _What FFTW really computes:</span>
<span class="sd">       http://www.fftw.org/fftw3_doc/What-FFTW-Really-Computes.html</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiscreteFourierTransform.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransform.html#odl.trafos.fourier.DiscreteFourierTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
                 <span class="n">halfcomplex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : `DiscretizedSpace`</span>
<span class="sd">            Domain of the Fourier transform. If its</span>
<span class="sd">            `DiscretizedSpace.exponent` is equal to 2.0, this operator has</span>
<span class="sd">            an adjoint which is equal to the inverse.</span>
<span class="sd">        range : `DiscretizedSpace`, optional</span>
<span class="sd">            Range of the Fourier transform. If not given, the range</span>
<span class="sd">            is determined from ``domain`` and the other parameters as</span>
<span class="sd">            a `uniform_discr` with unit cell size and exponent</span>
<span class="sd">            ``p / (p - 1)`` (read as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;).</span>
<span class="sd">        axes : int or sequence of ints, optional</span>
<span class="sd">            Dimensions in which a transform is to be calculated. ``None``</span>
<span class="sd">            means all axes.</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent.</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, calculate only the negative frequency part</span>
<span class="sd">            along the last axis in ``axes`` for real input. This</span>
<span class="sd">            reduces the size of the range to ``floor(N[i]/2) + 1`` in</span>
<span class="sd">            this axis ``i``, where ``N`` is the shape of the input</span>
<span class="sd">            arrays.</span>
<span class="sd">            Otherwise, calculate the full complex FFT. If ``dom_dtype``</span>
<span class="sd">            is a complex type, this option has no effect.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;}, optional</span>
<span class="sd">            Backend for the FFT implementation. The ``&#39;pyfftw&#39;`` backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Complex-to-complex (default) transforms have the same grids</span>
<span class="sd">        in domain and range:</span>

<span class="sd">        &gt;&gt;&gt; domain = odl.uniform_discr([0, 0], [2, 4], (2, 4),</span>
<span class="sd">        ...                            nodes_on_bdry=True)</span>
<span class="sd">        &gt;&gt;&gt; fft = DiscreteFourierTransform(domain)</span>
<span class="sd">        &gt;&gt;&gt; fft.domain.shape</span>
<span class="sd">        (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; fft.range.shape</span>
<span class="sd">        (2, 4)</span>

<span class="sd">        Real-to-complex transforms have a range grid with shape</span>
<span class="sd">        ``n // 2 + 1`` in the last tranform axis:</span>

<span class="sd">        &gt;&gt;&gt; domain = odl.uniform_discr([0, 0, 0], [2, 3, 4], (2, 3, 4),</span>
<span class="sd">        ...                            nodes_on_bdry=True)</span>
<span class="sd">        &gt;&gt;&gt; axes = (0, 1)</span>
<span class="sd">        &gt;&gt;&gt; fft = DiscreteFourierTransform(</span>
<span class="sd">        ...     domain, halfcomplex=True, axes=axes)</span>
<span class="sd">        &gt;&gt;&gt; fft.range.shape   # shortened in the second axis</span>
<span class="sd">        (2, 2, 4)</span>
<span class="sd">        &gt;&gt;&gt; fft.domain.shape</span>
<span class="sd">        (2, 3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteFourierTransform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` using numpy.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DiscreteFourierTransformBase._call_numpy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Need to undo Numpy IFFT scaling</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span> <span class="o">*</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` using pyfftw.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DiscreteFourierTransformBase._call_numpy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;normalise_idft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Using `False` here</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_flag_pyfftw_to_odl</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span>
                     <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;FFTW_MEASURE&#39;</span><span class="p">,)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;unaligned&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;destroy_input&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">effort</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">flags</span> <span class="k">else</span> <span class="s1">&#39;measure&#39;</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">planning_effort</span><span class="o">=</span><span class="n">effort</span><span class="p">,</span>
            <span class="n">fftw_plan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span><span class="p">,</span> <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse Fourier transform.&quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">return</span> <span class="n">DiscreteFourierTransformInverse</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span></div>


<div class="viewcode-block" id="DiscreteFourierTransformInverse"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformInverse.html#odl.trafos.fourier.DiscreteFourierTransformInverse">[docs]</a><span class="k">class</span> <span class="nc">DiscreteFourierTransformInverse</span><span class="p">(</span><span class="n">DiscreteFourierTransformBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Plain backward DFT, only evaluating the trigonometric sum.</span>

<span class="sd">    This operator calculates the inverse DFT::</span>

<span class="sd">        f[k] = 1/prod(N) * sum_j( f_hat[j] * exp(+- 1j*2*pi * j*k/N) )</span>

<span class="sd">    without any further shifting or scaling compensation. See the</span>
<span class="sd">    `Numpy FFT documentation`_, the `pyfftw API documentation`_ or</span>
<span class="sd">    `What FFTW really computes`_ for further information.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DiscreteFourierTransform</span>
<span class="sd">    FourierTransformInverse</span>
<span class="sd">    numpy.fft.ifftn : n-dimensional inverse FFT routine</span>
<span class="sd">    numpy.fft.irfftn : n-dimensional half-complex inverse FFT</span>
<span class="sd">    odl.trafos.backends.pyfftw_bindings.pyfftw_call : apply an FFTW transform</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. _Numpy FFT documentation:</span>
<span class="sd">        http://docs.scipy.org/doc/numpy/reference/routines.fft.html</span>
<span class="sd">    .. _pyfftw API documentation:</span>
<span class="sd">       https://pyfftw.readthedocs.io</span>
<span class="sd">    .. _What FFTW really computes:</span>
<span class="sd">       http://www.fftw.org/fftw3_doc/What-FFTW-Really-Computes.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="DiscreteFourierTransformInverse.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.DiscreteFourierTransformInverse.html#odl.trafos.fourier.DiscreteFourierTransformInverse.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                 <span class="n">halfcomplex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        range : `DiscretizedSpace`</span>
<span class="sd">            Range of the inverse Fourier transform. If its</span>
<span class="sd">            `DiscretizedSpace.exponent` is equal to 2.0, this operator has</span>
<span class="sd">            an adjoint which is equal to the inverse.</span>
<span class="sd">        domain : `DiscretizedSpace`, optional</span>
<span class="sd">            Domain of the inverse Fourier transform. If not given, the</span>
<span class="sd">            domain is determined from ``range`` and the other parameters as</span>
<span class="sd">            a `uniform_discr` with unit cell size and exponent</span>
<span class="sd">            ``p / (p - 1)`` (read as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;).</span>
<span class="sd">        axes : sequence of ints, optional</span>
<span class="sd">            Dimensions in which a transform is to be calculated. `None`</span>
<span class="sd">            means all axes.</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent.</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, interpret the last axis in ``axes`` as the</span>
<span class="sd">            negative frequency part of the transform of a real signal</span>
<span class="sd">            and calculate a &quot;half-complex-to-real&quot; inverse FFT. In this</span>
<span class="sd">            case, the domain has by default the shape</span>
<span class="sd">            ``floor(N[i]/2) + 1`` in this axis ``i``.</span>
<span class="sd">            Otherwise, domain and range have the same shape. If</span>
<span class="sd">            ``range`` is a complex space, this option has no effect.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;}, optional</span>
<span class="sd">            Backend for the FFT implementation. The &#39;pyfftw&#39; backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Complex-to-complex (default) transforms have the same grids</span>
<span class="sd">        in domain and range:</span>

<span class="sd">        &gt;&gt;&gt; range = odl.uniform_discr([0, 0], [2, 4], (2, 4),</span>
<span class="sd">        ...                           nodes_on_bdry=True)</span>
<span class="sd">        &gt;&gt;&gt; ifft = DiscreteFourierTransformInverse(range)</span>
<span class="sd">        &gt;&gt;&gt; ifft.domain.shape</span>
<span class="sd">        (2, 4)</span>
<span class="sd">        &gt;&gt;&gt; ifft.range.shape</span>
<span class="sd">        (2, 4)</span>

<span class="sd">        Complex-to-real transforms have a domain grid with shape</span>
<span class="sd">        ``n // 2 + 1`` in the last tranform axis:</span>

<span class="sd">        &gt;&gt;&gt; range = odl.uniform_discr([0, 0, 0], [2, 3, 4], (2, 3, 4),</span>
<span class="sd">        ...                           nodes_on_bdry=True)</span>
<span class="sd">        &gt;&gt;&gt; axes = (0, 1)</span>
<span class="sd">        &gt;&gt;&gt; ifft = DiscreteFourierTransformInverse(</span>
<span class="sd">        ...     range, halfcomplex=True, axes=axes)</span>
<span class="sd">        &gt;&gt;&gt; ifft.domain.shape   # shortened in the second axis</span>
<span class="sd">        (2, 2, 4)</span>
<span class="sd">        &gt;&gt;&gt; ifft.range.shape</span>
<span class="sd">        (2, 3, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiscreteFourierTransformInverse</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` using numpy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Input array to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span> <span class="o">/</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` using pyfftw.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            Input element to be transformed.</span>
<span class="sd">        out : `range` element</span>
<span class="sd">            Output element storing the result.</span>
<span class="sd">        flags : sequence of strings, optional</span>
<span class="sd">            Flags for the transform. ``&#39;FFTW_UNALIGNED&#39;`` is not</span>
<span class="sd">            supported, and ``&#39;FFTW_DESTROY_INPUT&#39;`` is enabled by</span>
<span class="sd">            default. See the `pyfftw API documentation`_</span>
<span class="sd">            for futher information.</span>
<span class="sd">            Default: ``(&#39;FFTW_MEASURE&#39;,)``</span>
<span class="sd">        threads : positive int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>
<span class="sd">        planning_timelimit : float, optional</span>
<span class="sd">            Rough upper limit in seconds for the planning step of the</span>
<span class="sd">            transform. The default is no limit. See the</span>
<span class="sd">            `pyfftw API documentation`_ for futher information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `range` element</span>
<span class="sd">            Result of the transform. If ``out`` was given, the returned</span>
<span class="sd">            object is a reference to it.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. _pyfftw API documentation:</span>
<span class="sd">           https://pyfftw.readthedocs.io</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;normalise_idft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># Using `True` here</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_flag_pyfftw_to_odl</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span>
                     <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;flags&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;FFTW_MEASURE&#39;</span><span class="p">,)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;unaligned&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flags</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;destroy_input&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">effort</span> <span class="o">=</span> <span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">flags</span> <span class="k">else</span> <span class="s1">&#39;measure&#39;</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">planning_effort</span><span class="o">=</span><span class="n">effort</span><span class="p">,</span>
            <span class="n">fftw_plan</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span><span class="p">,</span> <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Need to normalize for &#39;forward&#39;, no way to force pyfftw</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse Fourier transform.&quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span>
        <span class="k">return</span> <span class="n">DiscreteFourierTransform</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierTransformBase"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.html#odl.trafos.fourier.FourierTransformBase">[docs]</a><span class="k">class</span> <span class="nc">FourierTransformBase</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Discretized Fourier transform between discrete L^p spaces.</span>

<span class="sd">    This operator is the discretized variant of the continuous</span>
<span class="sd">    `Fourier Transform</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Fourier_Transform&gt;`_ between</span>
<span class="sd">    Lebesgue L^p spaces. It applies a three-step procedure consisting</span>
<span class="sd">    of a pre-processing step of the data, an FFT evaluation and</span>
<span class="sd">    a post-processing step. Pre- and post-processing account for</span>
<span class="sd">    the shift and scaling of the real-space and Fourier-space grids.</span>

<span class="sd">    The sign convention (&#39;-&#39; vs. &#39;+&#39;) can be changed with the ``sign``</span>
<span class="sd">    parameter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DiscreteFourierTransform</span>
<span class="sd">    FourierTransformInverse</span>
<span class="sd">    odl.trafos.util.ft_utils.dft_preprocess_data</span>
<span class="sd">    odl.trafos.backends.pyfftw_bindings.pyfftw_call</span>
<span class="sd">    odl.trafos.util.ft_utils.dft_postprocess_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FourierTransformBase.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.html#odl.trafos.fourier.FourierTransformBase.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        All parameters are given according to the specifics of the forward</span>
<span class="sd">        transform. The ``inverse`` parameter is used to control conversions</span>
<span class="sd">        for the inverse transform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inverse : bool</span>
<span class="sd">            If ``True``, create the inverse transform, otherwise the forward</span>
<span class="sd">            transform.</span>
<span class="sd">        domain : `DiscretizedSpace`</span>
<span class="sd">            Domain of the Fourier transform. If the</span>
<span class="sd">            `DiscretizedSpace.exponent` of ``domain`` and ``range`` are equal</span>
<span class="sd">            to 2.0, this operator has an adjoint which is equal to its</span>
<span class="sd">            inverse.</span>
<span class="sd">        range : `DiscretizedSpace`, optional</span>
<span class="sd">            Range of the Fourier transform. If not given, the range</span>
<span class="sd">            is determined from ``domain`` and the other parameters. The</span>
<span class="sd">            exponent is chosen to be the conjugate ``p / (p - 1)``,</span>
<span class="sd">            which reads as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;}, optional</span>
<span class="sd">            Backend for the FFT implementation. The &#39;pyfftw&#39; backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>
<span class="sd">        axes : int or sequence of ints, optional</span>
<span class="sd">            Dimensions along which to take the transform.</span>
<span class="sd">            Default: all axes</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent. Default: &#39;-&#39;</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, calculate only the negative frequency part</span>
<span class="sd">            along the last axis for real input. If ``False``,</span>
<span class="sd">            calculate the full complex FFT.</span>
<span class="sd">            For complex ``domain``, it has no effect.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        shift : bool or sequence of bools, optional</span>
<span class="sd">            If ``True``, the reciprocal grid is shifted by half a stride in</span>
<span class="sd">            the negative direction. With a boolean sequence, this option</span>
<span class="sd">            is applied separately to each axis.</span>
<span class="sd">            If a sequence is provided, it must have the same length as</span>
<span class="sd">            ``axes`` if supplied. Note that this must be set to ``True``</span>
<span class="sd">            in the halved axis in half-complex transforms.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        tmp_r : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the real space (domain of</span>
<span class="sd">            this transform). It is shared with the inverse.</span>

<span class="sd">            Variants using this: R2C, R2HC, C2R (inverse)</span>

<span class="sd">        tmp_f : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the frequency (reciprocal)</span>
<span class="sd">            space. It is shared with the inverse.</span>

<span class="sd">            Variants using this: R2C, C2R (inverse), HC2R (inverse)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The transform variants are:</span>

<span class="sd">          - **C2C**: complex-to-complex.</span>
<span class="sd">            The default variant, one-to-one and unitary.</span>

<span class="sd">          - **R2C**: real-to-complex.</span>
<span class="sd">            This variants adjoint and inverse may suffer</span>
<span class="sd">            from information loss since the result is cast to real.</span>

<span class="sd">          - **R2HC**: real-to-halfcomplex.</span>
<span class="sd">            This variant stores only a half-space of frequencies and</span>
<span class="sd">            is guaranteed to be one-to-one (invertible).</span>

<span class="sd">        * The `Operator.range` of this operator always has the</span>
<span class="sd">          `ComplexNumbers` as `LinearSpace.field`, i.e. if the</span>
<span class="sd">          field of ``domain`` is the `RealNumbers`, this operator&#39;s adjoint</span>
<span class="sd">          is defined by identifying real and imaginary parts with</span>
<span class="sd">          the components of a real product space element.</span>
<span class="sd">          See the `mathematical background documentation</span>
<span class="sd">          &lt;odlgroup.github.io/odl/math/trafos/fourier_transform.html#adjoint&gt;`_</span>
<span class="sd">          for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">DiscretizedSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;domain </span><span class="si">{!r}</span><span class="s1"> is not a `DiscretizedSpace` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;Only Numpy-based data spaces are supported, got </span><span class="si">{}</span><span class="s1">&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">tspace</span><span class="p">))</span>

        <span class="c1"># axes</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__axes</span> <span class="o">=</span> <span class="n">normalized_axes_tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">domain</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

        <span class="c1"># Implementation</span>
        <span class="k">if</span> <span class="n">impl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">impl</span> <span class="o">=</span> <span class="n">_DEFAULT_FOURIER_IMPL</span>
        <span class="n">impl</span><span class="p">,</span> <span class="n">impl_in</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">impl</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">impl</span>
        <span class="k">if</span> <span class="n">impl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_SUPPORTED_FOURIER_IMPLS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`impl` &#39;</span><span class="si">{}</span><span class="s2">&#39; not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">impl_in</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__impl</span> <span class="o">=</span> <span class="n">impl</span>

        <span class="c1"># Handle half-complex yes/no and shifts</span>
        <span class="n">halfcomplex</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">domain</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">is_uniform_byaxis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">halfcomplex</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__shifts</span> <span class="o">=</span> <span class="n">normalized_scalar_param_list</span><span class="p">(</span>
                <span class="n">shift</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">),</span> <span class="n">param_conv</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;non-uniform grids not yet supported&#39;</span><span class="p">)</span>

        <span class="n">sign</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;sign&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sign</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`sign` &#39;</span><span class="si">{}</span><span class="s2">&#39; not understood&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sign</span><span class="p">))</span>
        <span class="n">fwd_sign</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">inverse</span> <span class="k">else</span> <span class="n">sign</span>
        <span class="k">if</span> <span class="n">fwd_sign</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot combine sign &#39;+&#39; with a half-complex &quot;</span>
                             <span class="s2">&quot;transform&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__sign</span> <span class="o">=</span> <span class="n">sign</span>

        <span class="c1"># Need to filter out this situation since the pre-processing step</span>
        <span class="c1"># casts to complex otherwise, and then no half-complex transform</span>
        <span class="c1"># is possible.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`shift` must be `True` in the halved (last) &#39;</span>
                             <span class="s1">&#39;axis in half-complex transforms&#39;</span><span class="p">)</span>

        <span class="c1"># Storing temporaries directly as arrays</span>
        <span class="n">tmp_r</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tmp_r&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">tmp_f</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tmp_f&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Before starting to calculate stuff, we check for bad arguments</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;got unexpected keyword arguments: </span><span class="si">{}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="c1"># Infer the range if necessary</span>
        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># self._halfcomplex and self._axes need to be set for this</span>
            <span class="nb">range</span> <span class="o">=</span> <span class="n">reciprocal_space</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
                                     <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span>
                                     <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FourierTransformBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">FourierTransformBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_r</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">tmp_r</span><span class="p">)</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">tmp_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp_f</span> <span class="o">=</span> <span class="nb">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">tmp_f</span><span class="p">)</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="o">=</span> <span class="n">tmp_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="o">=</span> <span class="n">tmp_f</span></div>

<div class="viewcode-block" id="FourierTransformBase._call"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase._call.html#odl.trafos.fourier.FourierTransformBase._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x, out[, **kwargs])``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            Discretized function to be transformed</span>
<span class="sd">        out : `range` element</span>
<span class="sd">            Element to which the output is written</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the ``pyfftw_call`` function for ``**kwargs`` options.</span>
<span class="sd">        The parameters ``axes`` and ``halfcomplex`` cannot be</span>
<span class="sd">        overridden.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        odl.trafos.backends.pyfftw_bindings.pyfftw_call :</span>
<span class="sd">            Call pyfftw backend directly</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Implement zero padding</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_numpy</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asarray</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 0-overhead assignment if asarray() does not copy</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_pyfftw</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="n">out</span><span class="o">.</span><span class="n">asarray</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` for numpy back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` for pyfftw back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Array to which the output is written</span>
<span class="sd">        planning_effort : {&#39;estimate&#39;, &#39;measure&#39;, &#39;patient&#39;, &#39;exhaustive&#39;}</span>
<span class="sd">            Flag for the amount of effort put into finding an optimal</span>
<span class="sd">            FFTW plan. See the `FFTW doc on planner flags</span>
<span class="sd">            &lt;http://www.fftw.org/fftw3_doc/Planner-Flags.html&gt;`_.</span>
<span class="sd">        planning_timelimit : float or ``None``, optional</span>
<span class="sd">            Limit planning time to roughly this many seconds.</span>
<span class="sd">            Default: ``None`` (no limit)</span>
<span class="sd">        threads : int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform. The returned object is a reference</span>
<span class="sd">            to the input parameter ``out``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;abstract method&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Backend for the FFT implementation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__impl</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Axes along the FT is calculated by this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__axes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sign of the complex exponent in the transform.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sign</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">halfcomplex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the last transform axis is halved.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__halfcomplex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the boolean list indicating shifting per axis.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shifts</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint transform, equal to the inverse.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        inverse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">exponent</span> <span class="o">==</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;no adjoint defined for exponents (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">) != (2, 2)&#39;</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">exponent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">exponent</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse Fourier transform.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        adjoint : Equivalent since the fourier transform is unitary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">return</span> <span class="n">FourierTransformInverse</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">tmp_r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span><span class="p">,</span> <span class="n">tmp_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span><span class="p">)</span>

<div class="viewcode-block" id="FourierTransformBase.create_temporaries"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.create_temporaries.html#odl.trafos.fourier.FourierTransformBase.create_temporaries">[docs]</a>    <span class="k">def</span> <span class="nf">create_temporaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Allocate and store reusable temporaries.</span>

<span class="sd">        Existing temporaries are overridden.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        r : bool, optional</span>
<span class="sd">            Create temporary for the real space</span>
<span class="sd">        f : bool, optional</span>
<span class="sd">            Create temporary for the frequency space</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To save memory, clear the temporaries when the transform is</span>
<span class="sd">        no longer used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        clear_temporaries</span>
<span class="sd">        clear_fftw_plan : can also hold references to the temporaries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FourierTransformInverse</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="n">rspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span>
            <span class="n">fspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
            <span class="n">fspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span>

        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="o">=</span> <span class="n">rspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="o">=</span> <span class="n">fspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span></div>

<div class="viewcode-block" id="FourierTransformBase.clear_temporaries"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.clear_temporaries.html#odl.trafos.fourier.FourierTransformBase.clear_temporaries">[docs]</a>    <span class="k">def</span> <span class="nf">clear_temporaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the temporaries to ``None``.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="FourierTransformBase.init_fftw_plan"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.init_fftw_plan.html#odl.trafos.fourier.FourierTransformBase.init_fftw_plan">[docs]</a>    <span class="k">def</span> <span class="nf">init_fftw_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">planning_effort</span><span class="o">=</span><span class="s1">&#39;measure&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the FFTW plan for this transform for later use.</span>

<span class="sd">        If the implementation of this operator is not &#39;pyfftw&#39;, this</span>
<span class="sd">        method should not be called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        planning_effort : str, optional</span>
<span class="sd">            Flag for the amount of effort put into finding an optimal</span>
<span class="sd">            FFTW plan. See the `FFTW doc on planner flags</span>
<span class="sd">            &lt;http://www.fftw.org/fftw3_doc/Planner-Flags.html&gt;`_.</span>
<span class="sd">            Options: {&#39;estimate&#39;, &#39;measure&#39;, &#39;patient&#39;, &#39;exhaustive&#39;}</span>
<span class="sd">        planning_timelimit : float or ``None``, optional</span>
<span class="sd">            Limit planning time to roughly this many seconds.</span>
<span class="sd">            Default: ``None`` (no limit)</span>
<span class="sd">        threads : int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `impl` is not &#39;pyfftw&#39;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        To save memory, clear the plan when the transform is no longer</span>
<span class="sd">        used (the plan stores 2 arrays).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        clear_fftw_plan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;pyfftw&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot create fftw plan without fftw backend&#39;</span><span class="p">)</span>

        <span class="c1"># Using available temporaries if possible</span>
        <span class="n">inverse</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FourierTransformInverse</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="n">rspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span>
            <span class="n">fspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
            <span class="n">fspace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span>

        <span class="k">if</span> <span class="n">rspace</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="c1"># C2C: Use either one of &#39;r&#39; or &#39;f&#39; temporary if initialized</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr_in</span> <span class="o">=</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr_in</span> <span class="o">=</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr_in</span> <span class="o">=</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="n">rspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="c1"># R2HC / HC2R: Use &#39;r&#39; and &#39;f&#39; temporary distinctly if initialized</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr_r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr_r</span> <span class="o">=</span> <span class="n">rspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr_f</span> <span class="o">=</span> <span class="n">fspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">inverse</span><span class="p">:</span>
                <span class="n">arr_in</span><span class="p">,</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="n">arr_f</span><span class="p">,</span> <span class="n">arr_r</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr_in</span><span class="p">,</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="n">arr_r</span><span class="p">,</span> <span class="n">arr_f</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># R2C / C2R: Use &#39;f&#39; temporary for both sides if initialized</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">arr_in</span> <span class="o">=</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr_in</span> <span class="o">=</span> <span class="n">arr_out</span> <span class="o">=</span> <span class="n">fspace</span><span class="o">.</span><span class="n">element</span><span class="p">()</span><span class="o">.</span><span class="n">asarray</span><span class="p">()</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;planning_timelimit&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">arr_in</span><span class="p">,</span> <span class="n">arr_out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
            <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
            <span class="n">planning_effort</span><span class="o">=</span><span class="n">planning_effort</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="FourierTransformBase.clear_fftw_plan"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformBase.clear_fftw_plan.html#odl.trafos.fourier.FourierTransformBase.clear_fftw_plan">[docs]</a>    <span class="k">def</span> <span class="nf">clear_fftw_plan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete the FFTW plan of this transform.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `impl` is not &#39;pyfftw&#39;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If no plan exists, this is a no-op.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">impl</span> <span class="o">!=</span> <span class="s1">&#39;pyfftw&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cannot create fftw plan without fftw backend&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="FourierTransform"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransform.html#odl.trafos.fourier.FourierTransform">[docs]</a><span class="k">class</span> <span class="nc">FourierTransform</span><span class="p">(</span><span class="n">FourierTransformBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Discretized Fourier transform between discrete L^p spaces.</span>

<span class="sd">    This operator is the discretized variant of the continuous</span>
<span class="sd">    `Fourier Transform</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Fourier_Transform&gt;`_ between</span>
<span class="sd">    Lebesgue L^p spaces. It applies a three-step procedure consisting</span>
<span class="sd">    of a pre-processing step of the data, an FFT evaluation and</span>
<span class="sd">    a post-processing step. Pre- and post-processing account for</span>
<span class="sd">    the shift and scaling of the real-space and Fourier-space grids.</span>

<span class="sd">    The sign convention (&#39;-&#39; vs. &#39;+&#39;) can be changed with the ``sign``</span>
<span class="sd">    parameter.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DiscreteFourierTransform</span>
<span class="sd">    FourierTransformInverse</span>
<span class="sd">    odl.trafos.util.ft_utils.dft_preprocess_data</span>
<span class="sd">    odl.trafos.backends.pyfftw_bindings.pyfftw_call</span>
<span class="sd">    odl.trafos.util.ft_utils.dft_postprocess_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FourierTransform.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransform.html#odl.trafos.fourier.FourierTransform.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : `DiscretizedSpace`</span>
<span class="sd">            Domain of the Fourier transform. If the</span>
<span class="sd">            `DiscretizedSpace.exponent` of ``domain`` and ``range`` are equal</span>
<span class="sd">            to 2.0, this operator has an adjoint which is equal to its</span>
<span class="sd">            inverse.</span>
<span class="sd">        range : `DiscretizedSpace`, optional</span>
<span class="sd">            Range of the Fourier transform. If not given, the range</span>
<span class="sd">            is determined from ``domain`` and the other parameters. The</span>
<span class="sd">            exponent is chosen to be the conjugate ``p / (p - 1)``,</span>
<span class="sd">            which reads as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;}, optional</span>
<span class="sd">            Backend for the FFT implementation. The &#39;pyfftw&#39; backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>
<span class="sd">        axes : int or sequence of ints, optional</span>
<span class="sd">            Dimensions along which to take the transform.</span>
<span class="sd">            Default: all axes</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent. Default: &#39;-&#39;</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, calculate only the negative frequency part</span>
<span class="sd">            along the last axis for real input. If ``False``,</span>
<span class="sd">            calculate the full complex FFT.</span>
<span class="sd">            For complex ``domain``, it has no effect.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        shift : bool or sequence of bools, optional</span>
<span class="sd">            If ``True``, the reciprocal grid is shifted by half a stride in</span>
<span class="sd">            the negative direction. With a boolean sequence, this option</span>
<span class="sd">            is applied separately to each axis.</span>
<span class="sd">            If a sequence is provided, it must have the same length as</span>
<span class="sd">            ``axes`` if supplied. Note that this must be set to ``True``</span>
<span class="sd">            in the halved axis in half-complex transforms.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        tmp_r : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the real space (domain of</span>
<span class="sd">            this transform). It is shared with the inverse.</span>

<span class="sd">            Variants using this: R2C, R2HC, C2R (inverse)</span>

<span class="sd">        tmp_f : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the frequency (reciprocal)</span>
<span class="sd">            space. It is shared with the inverse.</span>

<span class="sd">            Variants using this: R2C, C2R (inverse), HC2R (inverse)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The transform variants are:</span>

<span class="sd">          - **C2C**: complex-to-complex.</span>
<span class="sd">            The default variant, one-to-one and unitary.</span>

<span class="sd">          - **R2C**: real-to-complex.</span>
<span class="sd">            This variants adjoint and inverse may suffer</span>
<span class="sd">            from information loss since the result is cast to real.</span>

<span class="sd">          - **R2HC**: real-to-halfcomplex.</span>
<span class="sd">            This variant stores only a half-space of frequencies and</span>
<span class="sd">            is guaranteed to be one-to-one (invertible).</span>

<span class="sd">        * The `Operator.range` of this operator always has the</span>
<span class="sd">          `ComplexNumbers` as `LinearSpace.field`, i.e. if the</span>
<span class="sd">          field of ``domain`` is the `RealNumbers`, this operator&#39;s adjoint</span>
<span class="sd">          is defined by identifying real and imaginary parts with</span>
<span class="sd">          the components of a real product space element.</span>
<span class="sd">          See the `mathematical background documentation</span>
<span class="sd">          &lt;odlgroup.github.io/odl/math/trafos/fourier_transform.html#adjoint&gt;`_</span>
<span class="sd">          for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FourierTransform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pre-processed version of ``x``.</span>

<span class="sd">        C2C: use ``tmp_r`` or ``tmp_f`` (C2C operation)</span>
<span class="sd">        R2C: use ``tmp_f`` (R2C operation)</span>
<span class="sd">        HALFC: use ``tmp_r`` (R2R operation)</span>

<span class="sd">        The result is stored in ``out`` if given, otherwise in</span>
<span class="sd">        a temporary or a new array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span>
        <span class="k">return</span> <span class="n">dft_preprocess_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the post-processed version of ``x``.</span>

<span class="sd">        C2C: use ``tmp_f`` (C2C operation)</span>
<span class="sd">        R2C: use ``tmp_f`` (C2C operation)</span>
<span class="sd">        HALFC: use ``tmp_f`` (C2C operation)</span>

<span class="sd">        The result is stored in ``out`` if given, otherwise in</span>
<span class="sd">        a temporary or a new array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
        <span class="c1"># TODO(kohr-h): Add `interp` to operator or simplify it by not</span>
        <span class="c1"># performing interpolation filter</span>
        <span class="k">return</span> <span class="n">dft_postprocess_data</span><span class="p">(</span>
            <span class="n">out</span><span class="p">,</span> <span class="n">real_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">recip_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">,</span>
            <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;multiply&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` for numpy back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pre-processing before calculating the DFT</span>
        <span class="c1"># Note: since the FFT call is out-of-place, it does not matter if</span>
        <span class="c1"># preprocess produces real or complex output in the R2C variant.</span>
        <span class="c1"># There is no significant time difference between (full) R2C and</span>
        <span class="c1"># C2C DFT in Numpy.</span>
        <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># The actual call to the FFT library, out-of-place unfortunately</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                <span class="c1"># Numpy&#39;s FFT normalizes by 1 / prod(shape[axes]), we</span>
                <span class="c1"># need to undo that</span>
                <span class="n">out</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>

        <span class="c1"># Post-processing accounting for shift, scaling and interpolation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postprocess</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` for pyfftw back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Array to which the output is written</span>
<span class="sd">        planning_effort : {&#39;estimate&#39;, &#39;measure&#39;, &#39;patient&#39;, &#39;exhaustive&#39;}</span>
<span class="sd">            Flag for the amount of effort put into finding an optimal</span>
<span class="sd">            FFTW plan. See the `FFTW doc on planner flags</span>
<span class="sd">            &lt;http://www.fftw.org/fftw3_doc/Planner-Flags.html&gt;`_.</span>
<span class="sd">        planning_timelimit : float or ``None``, optional</span>
<span class="sd">            Limit planning time to roughly this many seconds.</span>
<span class="sd">            Default: ``None`` (no limit)</span>
<span class="sd">        threads : int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform. The returned object is a reference</span>
<span class="sd">            to the input parameter ``out``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We pop some kwargs options here so that we always use the ones</span>
        <span class="c1"># given during init or implicitly assumed.</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;normalise_idft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># We use `False`</span>

        <span class="c1"># Pre-processing before calculating the sums, in-place for C2C and R2C</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">preproc</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># out is preproc in this case</span>
            <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">is_complex_floating_dtype</span><span class="p">(</span><span class="n">preproc</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># The actual call to the FFT library. We store the plan for re-use.</span>
        <span class="c1"># The FFT is calculated in-place, except if the range is real and</span>
        <span class="c1"># we don&#39;t use halfcomplex.</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
            <span class="n">preproc</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">is_complex_floating_dtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Post-processing accounting for shift, scaling and interpolation</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postprocess</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">is_complex_floating_dtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The inverse Fourier transform.&quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">return</span> <span class="n">FourierTransformInverse</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">tmp_r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span><span class="p">,</span> <span class="n">tmp_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span><span class="p">)</span></div>


<div class="viewcode-block" id="FourierTransformInverse"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformInverse.html#odl.trafos.fourier.FourierTransformInverse">[docs]</a><span class="k">class</span> <span class="nc">FourierTransformInverse</span><span class="p">(</span><span class="n">FourierTransformBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Inverse of the discretized Fourier transform between L^p spaces.</span>

<span class="sd">    This operator is the exact inverse of the `FourierTransform`, and</span>
<span class="sd">    **not** a discretization of the Fourier integral with &quot;+&quot; sign in</span>
<span class="sd">    the complex exponent. For the latter, use the ``sign`` parameter</span>
<span class="sd">    of the forward transform.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    FourierTransform</span>
<span class="sd">    DiscreteFourierTransformInverse</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FourierTransformInverse.__init__"><a class="viewcode-back" href="../../../generated/odl.trafos.fourier.FourierTransformInverse.html#odl.trafos.fourier.FourierTransformInverse.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        range : `DiscretizedSpace`</span>
<span class="sd">            Range of the inverse Fourier transform. If the</span>
<span class="sd">            `DiscretizedSpace.exponent` of ``domain`` and ``range`` are equal</span>
<span class="sd">            to 2.0, this operator has an adjoint which is equal to its</span>
<span class="sd">            inverse.</span>
<span class="sd">        domain : `DiscretizedSpace`, optional</span>
<span class="sd">            Domain of the inverse Fourier transform. If not given, the</span>
<span class="sd">            domain is determined from ``range`` and the other parameters.</span>
<span class="sd">            The exponent is chosen to be the conjugate ``p / (p - 1)``,</span>
<span class="sd">            which reads as &#39;inf&#39; for p=1 and 1 for p=&#39;inf&#39;.</span>
<span class="sd">        impl : {&#39;numpy&#39;, &#39;pyfftw&#39;}, optional</span>
<span class="sd">            Backend for the FFT implementation. The &#39;pyfftw&#39; backend</span>
<span class="sd">            is faster but requires the ``pyfftw`` package.</span>
<span class="sd">            ``None`` selects the fastest available backend.</span>
<span class="sd">        axes : int or sequence of ints, optional</span>
<span class="sd">            Dimensions along which to take the transform.</span>
<span class="sd">            Default: all axes</span>
<span class="sd">        sign : {&#39;-&#39;, &#39;+&#39;}, optional</span>
<span class="sd">            Sign of the complex exponent. Default: ``&#39;+&#39;``</span>
<span class="sd">        halfcomplex : bool, optional</span>
<span class="sd">            If ``True``, calculate only the negative frequency part</span>
<span class="sd">            along the last axis for real input. If ``False``,</span>
<span class="sd">            calculate the full complex FFT.</span>
<span class="sd">            For complex ``domain``, it has no effect.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        shift : bool or sequence of bools, optional</span>
<span class="sd">            If ``True``, the reciprocal grid is shifted by half a stride in</span>
<span class="sd">            the negative direction. With a boolean sequence, this option</span>
<span class="sd">            is applied separately to each axis.</span>
<span class="sd">            If a sequence is provided, it must have the same length as</span>
<span class="sd">            ``axes`` if supplied. Note that this must be set to ``True``</span>
<span class="sd">            in the halved axis in half-complex transforms.</span>
<span class="sd">            Default: ``True``</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        tmp_r : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the real space (range of</span>
<span class="sd">            this transform). It is shared with the inverse.</span>

<span class="sd">            Variants using this: C2R, R2C (forward), R2HC (forward)</span>

<span class="sd">        tmp_f : `DiscretizedSpaceElement` or `numpy.ndarray`, optional</span>
<span class="sd">            Temporary for calculations in the frequency (reciprocal)</span>
<span class="sd">            space. It is shared with the inverse.</span>

<span class="sd">            Variants using this: C2R, HC2R, R2C (forward)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * The transform variants are:</span>

<span class="sd">          - **C2C**: complex-to-complex.</span>
<span class="sd">            The default variant, one-to-one and unitary.</span>

<span class="sd">          - **C2R**: complex-to-real.</span>
<span class="sd">            This variants adjoint and inverse may suffer</span>
<span class="sd">            from information loss since the result is cast to real.</span>

<span class="sd">          - **HC2R**: halfcomplex-to-real.</span>
<span class="sd">            This variant interprets input as a signal on a half-space</span>
<span class="sd">            of frequencies. It is guaranteed to be one-to-one</span>
<span class="sd">            (invertible).</span>

<span class="sd">        * The `Operator.range` of this operator always has the</span>
<span class="sd">          `ComplexNumbers` as `LinearSpace.field`, i.e. if the</span>
<span class="sd">          field of ``domain`` is the `RealNumbers`, this operator&#39;s adjoint</span>
<span class="sd">          is defined by identifying real and imaginary parts with</span>
<span class="sd">          the components of a real product space element.</span>
<span class="sd">          See the `mathematical background documentation</span>
<span class="sd">          &lt;odlgroup.github.io/odl/math/trafos/fourier_transform.html#adjoint&gt;`_</span>
<span class="sd">          for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FourierTransformInverse</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="n">impl</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_preprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the pre-processed version of ``x``.</span>

<span class="sd">        Note that pre-processing in IFT is the same as post-processing</span>
<span class="sd">        in FT with ``op=&#39;divide&#39;``.</span>

<span class="sd">        C2C: use ``tmp_r`` or``tmp_f`` (C2C operation)</span>
<span class="sd">        R2C: use ``tmp_f`` (C2C operation)</span>
<span class="sd">        HALFC: use ``tmp_f`` (C2C operation)</span>

<span class="sd">        The result is stored in ``out`` if given, otherwise in</span>
<span class="sd">        a temporary or a new array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
        <span class="c1"># TODO(kohr-h): Add `interp` to operator or simplify it by not</span>
        <span class="c1"># performing interpolation filter</span>
        <span class="k">return</span> <span class="n">dft_postprocess_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">real_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">recip_grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">,</span>
            <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;divide&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_postprocess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the post-processed version of ``x``.</span>

<span class="sd">        C2C: use ``tmp_r`` or ``tmp_f`` (C2C operation)</span>
<span class="sd">        R2C: use ``tmp_f`` (C2C operation)</span>
<span class="sd">        HALFC: use ``tmp_r`` (R2R operation)</span>

<span class="sd">        The result is stored in ``out`` if given, otherwise in</span>
<span class="sd">        a temporary or a new array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># halfcomplex</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span>
        <span class="k">return</span> <span class="n">dft_preprocess_data</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sign</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x)`` for numpy back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pre-processing before calculating the DFT</span>
        <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># The actual call to the FFT library</span>
        <span class="c1"># Normalization by 1 / prod(shape[axes]) is done by Numpy&#39;s FFT if</span>
        <span class="c1"># one of the &quot;i&quot; functions is used. For sign=&#39;-&#39; we need to do it</span>
        <span class="c1"># ourselves.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">preproc</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Post-processing in IFT = pre-processing in FT (in-place)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postprocess</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">is_real_dtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">real</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_call_pyfftw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out, **kwargs])`` for pyfftw back-end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `numpy.ndarray`</span>
<span class="sd">            Array representing the function to be transformed</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Array to which the output is written</span>
<span class="sd">        planning_effort : {&#39;estimate&#39;, &#39;measure&#39;, &#39;patient&#39;, &#39;exhaustive&#39;}</span>
<span class="sd">            Flag for the amount of effort put into finding an optimal</span>
<span class="sd">            FFTW plan. See the `FFTW doc on planner flags</span>
<span class="sd">            &lt;http://www.fftw.org/fftw3_doc/Planner-Flags.html&gt;`_.</span>
<span class="sd">        planning_timelimit : float or ``None``, optional</span>
<span class="sd">            Limit planning time to roughly this many seconds.</span>
<span class="sd">            Default: ``None`` (no limit)</span>
<span class="sd">        threads : int, optional</span>
<span class="sd">            Number of threads to use. Default: 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `numpy.ndarray`</span>
<span class="sd">            Result of the transform. If ``out`` was given, the returned</span>
<span class="sd">            object is a reference to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We pop some kwargs options here so that we always use the ones</span>
        <span class="c1"># given during init or implicitly assumed.</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;halfcomplex&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;normalise_idft&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># We use `True`</span>

        <span class="c1"># Pre-processing in IFT = post-processing in FT, but with division</span>
        <span class="c1"># instead of multiplication and switched grids. In-place for C2C only.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">ComplexNumbers</span><span class="p">():</span>
            <span class="c1"># preproc is out in this case</span>
            <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">preproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># The actual call to the FFT library. We store the plan for re-use.</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="s1">&#39;forward&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;backward&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="n">RealNumbers</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">:</span>
            <span class="c1"># Need to use a complex array as out if we do C2R since the</span>
            <span class="c1"># FFT has to be C2C</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
                <span class="n">preproc</span><span class="p">,</span> <span class="n">preproc</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fft_arr</span> <span class="o">=</span> <span class="n">preproc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Only here we can use out directly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fftw_plan</span> <span class="o">=</span> <span class="n">pyfftw_call</span><span class="p">(</span>
                <span class="n">preproc</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span>
                <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span>
                <span class="n">normalise_idft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">fft_arr</span> <span class="o">=</span> <span class="n">out</span>

        <span class="c1"># Normalization is only done for &#39;backward&#39;, we need it for &#39;forward&#39;,</span>
        <span class="c1"># too.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">fft_arr</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">))</span>

        <span class="c1"># Post-processing in IFT = pre-processing in FT. In-place for</span>
        <span class="c1"># C2C and HC2R. For C2R, this is out-of-place and discards the</span>
        <span class="c1"># imaginary part.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postprocess</span><span class="p">(</span><span class="n">fft_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of the inverse, the forward FT.&quot;&quot;&quot;</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">return</span> <span class="n">FourierTransform</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">impl</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">,</span> <span class="n">halfcomplex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">halfcomplex</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shifts</span><span class="p">,</span>
            <span class="n">sign</span><span class="o">=</span><span class="n">sign</span><span class="p">,</span> <span class="n">tmp_r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_r</span><span class="p">,</span> <span class="n">tmp_f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tmp_f</span><span class="p">)</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>