

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>odl.operator.operator &mdash; odl 1.0.0.dev0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> odl
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User’s guide – selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>odl.operator.operator</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for odl.operator.operator</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2020 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Abstract mathematical operators.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">object</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Number</span>

<span class="kn">from</span> <span class="nn">odl.set</span> <span class="kn">import</span> <span class="n">Field</span><span class="p">,</span> <span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">odl.set.space</span> <span class="kn">import</span> <span class="n">LinearSpaceElement</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">cache_arguments</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;Operator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorComp&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorSum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorVectorSum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorLeftScalarMult&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorRightScalarMult&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FunctionalLeftVectorMult&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorLeftVectorMult&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorRightVectorMult&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OperatorPointwiseProduct&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OpTypeError&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OpDomainError&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OpRangeError&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OpNotImplementedError&#39;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_default_call_out_of_place</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default out-of-place evaluation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : `Operator`</span>
<span class="sd">        Operator to call</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Point in which to call the operator.</span>
<span class="sd">    kwargs:</span>
<span class="sd">        Optional arguments to the operator.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : `range` element</span>
<span class="sd">        An object in the operator range. The result of an operator</span>
<span class="sd">        evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">_call_in_place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`op` returned a different value than `out`.&#39;</span>
                         <span class="s1">&#39;With in-place evaluation, the operator can &#39;</span>
                         <span class="s1">&#39;only return nothing (`None`) or the `out` &#39;</span>
                         <span class="s1">&#39;parameter.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_default_call_in_place</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default in-place evaluation using ``Operator._call()``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    op : `Operator`</span>
<span class="sd">        Operator to call</span>
<span class="sd">    x : ``op.domain`` element</span>
<span class="sd">        Point in which to call the operator.</span>
<span class="sd">    out : ``op.range`` element</span>
<span class="sd">        An object in the operator range. The result of an operator</span>
<span class="sd">        evaluation is written here.</span>
<span class="sd">    kwargs:</span>
<span class="sd">        Optional arguments to the operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">_call_out_of_place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_function_signature</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the signature of a callable as a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function whose signature to extract.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sig : string</span>
<span class="sd">        Signature of the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Python 3 already implements this functionality</span>
        <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="c1"># In Python 2 we have to do it manually, unfortunately</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">posargs</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">args</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">defaults</span> <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="n">varargs</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">varargs</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">keywords</span>
    <span class="n">deflen</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
    <span class="n">nodeflen</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">posargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">posargs</span><span class="p">)</span> <span class="o">-</span> <span class="n">deflen</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">posargs</span><span class="p">[:</span><span class="n">nodeflen</span><span class="p">]]</span>
    <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">dval</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">dval</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">posargs</span><span class="p">[</span><span class="n">nodeflen</span><span class="p">:],</span> <span class="n">defaults</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">varargs</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;*</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">varargs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;**</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="n">argstr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">argstr</span><span class="p">)</span>


<span class="nd">@cache_arguments</span>
<span class="k">def</span> <span class="nf">_dispatch_call_args</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bound_call</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unbound_call</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">attr</span><span class="o">=</span><span class="s1">&#39;_call&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check the arguments of ``_call()`` or similar for conformity.</span>

<span class="sd">    The ``_call()`` method of `Operator` is allowed to have the</span>
<span class="sd">    following signatures:</span>

<span class="sd">    Python 2 and 3:</span>
<span class="sd">        - ``_call(self, x)``</span>
<span class="sd">        - ``_call(self, vec, out)``</span>
<span class="sd">        - ``_call(self, x, out=None)``</span>

<span class="sd">    Python 3 only:</span>
<span class="sd">        - ``_call(self, x, *, out=None)`` (``out`` as keyword-only</span>
<span class="sd">          argument)</span>

<span class="sd">    For disambiguation, the instance name (the first argument) **must**</span>
<span class="sd">    be &#39;self&#39;.</span>

<span class="sd">    The name of the ``out`` argument **must** be &#39;out&#39;, the second</span>
<span class="sd">    argument may have any name.</span>

<span class="sd">    Additional variable ``**kwargs`` and keyword-only arguments</span>
<span class="sd">    (Python 3 only) are also allowed.</span>

<span class="sd">    Not allowed:</span>
<span class="sd">        - ``_call(self)`` -- No arguments except instance:</span>
<span class="sd">        - ``_call(x)`` -- &#39;self&#39; missing, i.e. ``@staticmethod``</span>
<span class="sd">        - ``_call(cls, x)``  -- &#39;self&#39; missing, i.e. ``@classmethod``</span>
<span class="sd">        - ``_call(self, out, x)`` -- ``out`` as second argument</span>
<span class="sd">        - ``_call(self, *x)`` -- Variable arguments</span>
<span class="sd">        - ``_call(self, x, y, out=None)`` -- more positional arguments</span>
<span class="sd">        - ``_call(self, x, out=False)`` -- default other than None for</span>
<span class="sd">          ``out``</span>

<span class="sd">    In particular, static or class methods are not allowed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cls : `class`, optional</span>
<span class="sd">        The ``_call()`` method of this class is checked. If omitted,</span>
<span class="sd">        provide ``unbound_call`` instead to check directly.</span>
<span class="sd">    bound_call : callable, optional</span>
<span class="sd">        Check this bound method instead of ``cls``</span>
<span class="sd">    unbound_call : callable, optional</span>
<span class="sd">        Check this unbound function instead of ``cls``</span>
<span class="sd">    attr : string, optional</span>
<span class="sd">        Check this attribute instead of ``_call``, e.g. ``__call__``</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    has_out : bool</span>
<span class="sd">        Whether the call has an ``out`` argument</span>
<span class="sd">    out_is_optional : bool</span>
<span class="sd">        Whether the ``out`` argument is optional</span>
<span class="sd">    spec : `inspect.ArgSpec` or `inspect.FullArgSpec`</span>
<span class="sd">        Argument specification of the checked call function</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        if the signature of the function is malformed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">py3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">specs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_call(self, x[, **kwargs])&#39;</span><span class="p">,</span>
             <span class="s1">&#39;_call(self, x, out[, **kwargs])&#39;</span><span class="p">,</span>
             <span class="s1">&#39;_call(self, x, out=None[, **kwargs])&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">py3</span><span class="p">:</span>
        <span class="n">specs</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;_call(self, x, *, out=None[, **kwargs])&#39;</span><span class="p">]</span>

    <span class="n">spec_msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Possible signatures are (&#39;[, **kwargs]&#39; means optional):</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="n">spec_msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
    <span class="n">spec_msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">Static or class methods are not allowed.&#39;</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bound_call</span><span class="p">,</span> <span class="n">unbound_call</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;exactly one object to check must be given&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get the actual implementation, including ancestors</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">mro</span><span class="p">():</span>
            <span class="n">call</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c1"># Static and class methods are not allowed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">&#39; is a static method. &quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">call</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">&#39; is a class method. &quot;</span>
                            <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">bound_call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">bound_call</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">call</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a bound method&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">call</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">call</span> <span class="o">=</span> <span class="n">unbound_call</span>

    <span class="k">if</span> <span class="n">py3</span><span class="p">:</span>
        <span class="c1"># support kw-only args and annotations</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>
        <span class="n">kw_only</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">kwonlyargs</span>
        <span class="n">kw_only_defaults</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">kwonlydefaults</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>
        <span class="n">kw_only</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">kw_only_defaults</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="n">_function_signature</span><span class="p">(</span><span class="n">call</span><span class="p">)</span>

    <span class="n">pos_args</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">args</span>
    <span class="k">if</span> <span class="n">unbound_call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add &#39;self&#39; to positional arg list to satisfy the checker</span>
        <span class="n">pos_args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;self&#39;</span><span class="p">)</span>

    <span class="n">pos_defaults</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">defaults</span>
    <span class="n">varargs</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">varargs</span>

    <span class="c1"># Variable args are not allowed</span>
    <span class="k">if</span> <span class="n">varargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: variable arguments not allowed&quot;</span>
                         <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_args</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>

    <span class="n">true_pos_args</span> <span class="o">=</span> <span class="n">pos_args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_pos_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># &#39;out&#39; kw-only</span>
        <span class="k">if</span> <span class="s1">&#39;out&#39;</span> <span class="ow">in</span> <span class="n">true_pos_args</span><span class="p">:</span>  <span class="c1"># &#39;out&#39; positional and &#39;x&#39; kw-only -&gt; no</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: `out` cannot be the only &quot;</span>
                             <span class="s2">&quot;positional argument&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;out&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw_only</span><span class="p">:</span>
                <span class="n">has_out</span> <span class="o">=</span> <span class="n">out_optional</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">kw_only_defaults</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: `out` can only default to &quot;</span>
                    <span class="s2">&quot;`None`, got &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">kw_only_defaults</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span> <span class="o">+</span>
                    <span class="n">spec_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">has_out</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">out_optional</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_pos_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Both args positional</span>
        <span class="k">if</span> <span class="n">true_pos_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;out&#39;</span><span class="p">:</span>  <span class="c1"># out must come second</span>
            <span class="n">py3_txt</span> <span class="o">=</span> <span class="s1">&#39; or keyword-only. &#39;</span> <span class="k">if</span> <span class="n">py3</span> <span class="k">else</span> <span class="s1">&#39;. &#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: `out` can only be the &quot;</span>
                             <span class="s2">&quot;second positional argument&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">py3_txt</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">true_pos_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;out&#39;</span><span class="p">:</span>  <span class="c1"># &#39;out&#39; must be &#39;out&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: output parameter must &quot;</span>
                             <span class="s2">&quot;be called &#39;out&#39;, got &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                             <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">true_pos_args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                             <span class="n">spec_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_out</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out_optional</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">pos_defaults</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pos_defaults</span> <span class="ow">and</span> <span class="n">pos_defaults</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: `out` can only &quot;</span>
                                 <span class="s2">&quot;default to `None`, got &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span>
                                 <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">pos_defaults</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span>
                                 <span class="n">spec_msg</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># Too many positional args</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;bad signature &#39;</span><span class="si">{}</span><span class="s2">&#39;: too many positional arguments&quot;</span>
                         <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span> <span class="o">+</span> <span class="n">spec_msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">has_out</span><span class="p">,</span> <span class="n">out_optional</span><span class="p">,</span> <span class="n">spec</span>


<div class="viewcode-block" id="Operator"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator.html#odl.operator.operator.Operator">[docs]</a><span class="k">class</span> <span class="nc">Operator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Abstract mathematical operator.</span>

<span class="sd">    An operator is a mapping</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{A}: \mathcal{X} \to \mathcal{Y}</span>

<span class="sd">    between sets :math:`\mathcal{X}` (domain) and :math:`\mathcal{Y}`</span>
<span class="sd">    (range). The evaluation of :math:`\mathcal{A}` at an element</span>
<span class="sd">    :math:`x \in \mathcal{X}` is denoted by :math:`\mathcal{A}(x)`</span>
<span class="sd">    and produces an element in :math:`\mathcal{Y}`:</span>

<span class="sd">    .. math::</span>
<span class="sd">        y = \mathcal{A}(x) \in \mathcal{Y}.</span>

<span class="sd">    Programmatically, these properties are reflected in the `Operator`</span>
<span class="sd">    class described in the following.</span>

<span class="sd">    **Abstract attributes and methods**</span>

<span class="sd">    `Operator` is an **abstract** class, i.e. it can only be</span>
<span class="sd">    subclassed, not used directly.</span>

<span class="sd">    Any subclass of `Operator` must have the following</span>
<span class="sd">    attributes:</span>

<span class="sd">    ``domain`` : `Set`</span>
<span class="sd">        The set of elements this operator can be applied to</span>

<span class="sd">    ``range`` : `Set`</span>
<span class="sd">        The set this operator maps to</span>

<span class="sd">    It is **highly** recommended to call</span>
<span class="sd">    ``super(MyOp, self).__init__(domain, range)``  in the ``__init__()``</span>
<span class="sd">    method of any subclass  ``MyOp``, where ``domain`` and ``range`` are</span>
<span class="sd">    the arguments specifying domain and range of the new operator. In that</span>
<span class="sd">    case, the attributes `Operator.domain` and `Operator.range` are</span>
<span class="sd">    automatically provided by the parent class `Operator`.</span>

<span class="sd">    In addition, any subclass **must** implement the private method</span>
<span class="sd">    `Operator._call()`. It signature determines how it is interpreted:</span>


<span class="sd">    **In-place-only evaluation:** ``_call(self, x, out[, **kwargs])``</span>

<span class="sd">    In-place evaluation means that the operator is applied, and the</span>
<span class="sd">    result is written to an existing element ``out`` provided,</span>
<span class="sd">    i.e.</span>

<span class="sd">        ``_call(self, x, out)  &lt;==&gt;  out &lt;-- operator(x)``</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    x : `Operator.domain` element</span>
<span class="sd">        An object in the operator domain to which the operator is</span>
<span class="sd">        applied</span>

<span class="sd">    out : `Operator.range` element</span>
<span class="sd">        An object in the operator range to which the result of the</span>
<span class="sd">        operator evaluation is written.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    None (return value is ignored)</span>


<span class="sd">    **Out-of-place-only evaluation:** ``_call(self, x[, **kwargs])``</span>

<span class="sd">    Out-of-place evaluation means that the operator is applied,</span>
<span class="sd">    and the result is written to a **new** element which is returned.</span>
<span class="sd">    In this case, a subclass has to implement the method</span>

<span class="sd">        ``_call(self, x)  &lt;==&gt;  operator(x)``</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    x : `Operator.domain` element</span>
<span class="sd">        An object in the operator domain to which the operator is</span>
<span class="sd">        applied</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    out : `Operator.range` `element-like`</span>
<span class="sd">        An object in the operator range holding the result of the</span>
<span class="sd">        operator evaluation</span>


<span class="sd">    **Dual-use evaluation:** ``_call(self, x, out=None[, **kwargs])``</span>

<span class="sd">    Evaluate in-place if ``out`` is given, otherwise out-of-place.</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    x : `Operator.domain` element</span>
<span class="sd">        An object in the operator domain to which the operator is</span>
<span class="sd">        applied</span>

<span class="sd">    out : `Operator.range` element, optional</span>
<span class="sd">        An object in the operator range to which the result of the</span>
<span class="sd">        operator evaluation is written</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    None (return value is ignored)</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `Operator._call` is implemented in-place-only or</span>
<span class="sd">      out-of-place-only and the `Operator.range` is a `LinearSpace`,</span>
<span class="sd">      a default implementation of the respective other is provided.</span>

<span class="sd">    - `Operator._call` is allowed to have keyword-only arguments (Python</span>
<span class="sd">      3 only).</span>

<span class="sd">    - The term &quot;element-like&quot; means that an object must be convertible</span>
<span class="sd">      to an element by the ``domain.element()`` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new instance.&quot;&quot;&quot;</span>
        <span class="n">call_has_out</span><span class="p">,</span> <span class="n">call_out_optional</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_dispatch_call_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_call_has_out</span> <span class="o">=</span> <span class="n">call_has_out</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_call_out_optional</span> <span class="o">=</span> <span class="n">call_out_optional</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">call_has_out</span><span class="p">:</span>
            <span class="c1"># Out-of-place _call</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_call_in_place</span> <span class="o">=</span> <span class="n">_default_call_in_place</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_call_out_of_place</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_call</span>
        <span class="k">elif</span> <span class="n">call_out_optional</span><span class="p">:</span>
            <span class="c1"># Dual-use _call</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_call_in_place</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_call_out_of_place</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_call</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In-place-only _call</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_call_in_place</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_call</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_call_out_of_place</span> <span class="o">=</span> <span class="n">_default_call_out_of_place</span>

        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

<div class="viewcode-block" id="Operator.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator.html#odl.operator.operator.Operator.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : `Set`</span>
<span class="sd">            The domain of this operator, i.e., the set of elements to</span>
<span class="sd">            which this operator can be applied</span>
<span class="sd">        range : `Set`</span>
<span class="sd">            The range of this operator, i.e., the set this operator</span>
<span class="sd">            maps to</span>
<span class="sd">        linear : bool, optional</span>
<span class="sd">            If ``True``, the operator is considered as linear. In this</span>
<span class="sd">            case, ``domain`` and ``range`` have to be instances of</span>
<span class="sd">            `LinearSpace`, or `Field`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> is not a `Set` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> is not a `Set` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_linear</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">linear</span><span class="p">)</span>

        <span class="c1"># Cache for efficiency since this is done in each call.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_functional</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">Field</span><span class="p">)</span>

        <span class="c1"># Mandatory out makes no sense for functionals.</span>
        <span class="c1"># However, we need to allow optional out to support vectorized</span>
        <span class="c1"># functions (which are functionals in the duck-typing sense).</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_functional</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_has_out</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_out_optional</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mandatory `out` parameter not allowed for &#39;</span>
                             <span class="s1">&#39;functionals&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or `Field` &#39;</span>
                                <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or `Field` &#39;</span>
                                <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span></div>

<div class="viewcode-block" id="Operator._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator._call.html#odl.operator.operator.Operator._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of the operator evaluation.</span>

<span class="sd">        This method is the private backend for the evaluation of an</span>
<span class="sd">        operator. It needs to match certain signature conventions,</span>
<span class="sd">        and its implementation type is inferred from its signature.</span>

<span class="sd">        The following signatures are allowed:</span>

<span class="sd">        Python 2 and 3:</span>
<span class="sd">            - ``_call(self, x)``  --&gt;  out-of-place evaluation</span>
<span class="sd">            - ``_call(self, vec, out)``  --&gt;  in-place evaluation</span>
<span class="sd">            - ``_call(self, x, out=None)``   --&gt; both</span>

<span class="sd">        Python 3 only:</span>
<span class="sd">            - ``_call(self, x, *, out=None)`` (``out`` as keyword-only</span>
<span class="sd">              argument)  --&gt; both</span>

<span class="sd">        For disambiguation, the instance name (the first argument) **must**</span>
<span class="sd">        be &#39;self&#39;.</span>

<span class="sd">        The name of the ``out`` argument **must** be &#39;out&#39;, the second</span>
<span class="sd">        argument may have any name.</span>

<span class="sd">        Additional variable ``**kwargs`` and keyword-only arguments</span>
<span class="sd">        (Python 3 only) are also allowed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Some general advice on how to implement operator evaluation:</span>

<span class="sd">        - If you just write a quick implementation or are not too</span>
<span class="sd">          worried about efficiency, it may be easiest to write the</span>
<span class="sd">          evaluation *out-of-place*.</span>
<span class="sd">        - We recommend advanced and performance-aware users to implement</span>
<span class="sd">          the *in-place* pattern if the wrapped code supports it.</span>
<span class="sd">          In-place evaluation is usually significantly faster since it</span>
<span class="sd">          avoids the allocation of new memory and a copy compared to</span>
<span class="sd">          out-of-place evaluation.</span>
<span class="sd">        - If there is a significant performance gain from implementing</span>
<span class="sd">          an out-of-place method separately, use the pattern for both</span>
<span class="sd">          (``out`` optional) and decide according to the given ``out``</span>
<span class="sd">          parameter which one to use.</span>
<span class="sd">        - If your evaluation code does not support in-place evaluation,</span>
<span class="sd">          use the out-of-place pattern.</span>

<span class="sd">        Note that the public call pattern ``op()`` using ``op.__call__``</span>
<span class="sd">        provides a default implementation of the underlying in-place or</span>
<span class="sd">        out-of-place call even if you choose the respective other</span>
<span class="sd">        pattern.</span>

<span class="sd">        See the `operator guide</span>
<span class="sd">        &lt;https://odlgroup.github.io/odl/guide/in_depth/operator_guide.html&gt;`_</span>
<span class="sd">        for more info on in-place vs. out-of-place evaluation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            Element to which the operator is applied</span>
<span class="sd">        out : `range` element, optional</span>
<span class="sd">            Element to which the result is written</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `range` `element-like`</span>
<span class="sd">            Result of the evaluation. If ``out`` was provided, the</span>
<span class="sd">            returned object is a reference to it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;this operator </span><span class="si">{!r}</span><span class="s1"> does not implement &#39;</span>
                                  <span class="s1">&#39;`_call`. See `Operator._call` for &#39;</span>
                                  <span class="s1">&#39;instructions on how to do this.&#39;</span>
                                  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set of objects on which this operator can be evaluated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__domain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set in which the result of an evaluation of this operator lies.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__range</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if this operator is linear.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_linear</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_functional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;``True`` if this operator&#39;s range is a `Field`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_functional</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator (abstract).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            Since the adjoint cannot be default implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;adjoint not implemented &#39;</span>
                                    <span class="s1">&#39;for operator </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Operator.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator.derivative.html#odl.operator.operator.Operator.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the operator derivative at ``point``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the operator is not linear, the derivative cannot be</span>
<span class="sd">            default implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;derivative not implemented &#39;</span>
                                        <span class="s1">&#39;for operator </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the operator inverse.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            Since the inverse cannot be default implemented.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;inverse not implemented for operator </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

<div class="viewcode-block" id="Operator.__call__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator.__call__.html#odl.operator.operator.Operator.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self(x[, out, **kwargs])``.</span>

<span class="sd">        Implementation of the call pattern ``op(x)`` with the private</span>
<span class="sd">        ``_call()`` method and added error checking.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            An object which can be converted into an element of this</span>
<span class="sd">            operator&#39;s domain with the ``self.domain.element`` method.</span>
<span class="sd">            The operator is applied to this object, which is treated</span>
<span class="sd">            as immutable, hence it is not modified during evaluation.</span>
<span class="sd">        out : `range` element, optional</span>
<span class="sd">            An object in the operator range to which the result of the</span>
<span class="sd">            operator evaluation is written. The result is independent</span>
<span class="sd">            of the initial state of this object.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Passed on to the underlying implementation in `_call`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : `range` element</span>
<span class="sd">            Result of the operator evaluation. If ``out`` was provided,</span>
<span class="sd">            the returned object is a reference to it.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rn = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.ScalingOperator(rn, 2.0)</span>
<span class="sd">        &gt;&gt;&gt; x = rn.element([1, 2, 3])</span>

<span class="sd">        Out-of-place evaluation:</span>

<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>

<span class="sd">        In-place evaluation:</span>

<span class="sd">        &gt;&gt;&gt; y = rn.element()</span>
<span class="sd">        &gt;&gt;&gt; op(x, out=y)</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        _call : Implementation of the method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">OpDomainError</span><span class="p">(</span>
                    <span class="s1">&#39;unable to cast </span><span class="si">{!r}</span><span class="s1"> to an element of &#39;</span>
                    <span class="s1">&#39;the domain </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># In-place evaluation</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OpRangeError</span><span class="p">(</span><span class="s1">&#39;`out` </span><span class="si">{!r}</span><span class="s1"> not an element of the range &#39;</span>
                                   <span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> of </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_functional</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`out` parameter cannot be used &#39;</span>
                                <span class="s1">&#39;when range is a field&#39;</span><span class="p">)</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_in_place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`op` returned a different value than `out`. &#39;</span>
                                 <span class="s1">&#39;With in-place evaluation, the operator can &#39;</span>
                                 <span class="s1">&#39;only return nothing (`None`) or the `out` &#39;</span>
                                 <span class="s1">&#39;parameter.&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Out-of-place evaluation</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_out_of_place</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">OpRangeError</span><span class="p">(</span>
                        <span class="s1">&#39;unable to cast </span><span class="si">{!r}</span><span class="s1"> to an element of &#39;</span>
                        <span class="s1">&#39;the range </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Operator.norm"><a class="viewcode-back" href="../../../generated/odl.operator.operator.Operator.norm.html#odl.operator.operator.Operator.norm">[docs]</a>    <span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">estimate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the operator norm of this operator.</span>

<span class="sd">        If this operator is non-linear, this should be the Lipschitz constant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        estimate : bool</span>
<span class="sd">            If true, estimate the operator norm. By default, it is estimated</span>
<span class="sd">            using `power_method_opnorm`, which is only applicable for linear</span>
<span class="sd">            operators.</span>
<span class="sd">            Subclasses are allowed to ignore this parameter if they can provide</span>
<span class="sd">            an exact value.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs :</span>
<span class="sd">            If ``estimate`` is True, pass these arguments to the</span>
<span class="sd">            `power_method_opnorm` call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm : float</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Some operators know their own operator norm and do not need an estimate</span>

<span class="sd">        &gt;&gt;&gt; spc = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; id = odl.IdentityOperator(spc)</span>
<span class="sd">        &gt;&gt;&gt; id.norm(True)</span>
<span class="sd">        1.0</span>

<span class="sd">        For others, there is no closed form expression and an estimate is</span>
<span class="sd">        needed:</span>

<span class="sd">        &gt;&gt;&gt; spc = odl.uniform_discr(0, 1, 3)</span>
<span class="sd">        &gt;&gt;&gt; grad = odl.Gradient(spc)</span>
<span class="sd">        &gt;&gt;&gt; opnorm = grad.norm(estimate=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">estimate</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;`Operator.norm()` not implemented, use &#39;</span>
                                      <span class="s1">&#39;`Operator.norm(estimate=True)` to &#39;</span>
                                      <span class="s1">&#39;obtain an estimate.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">norm</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__norm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">odl.operator.oputils</span> <span class="kn">import</span> <span class="n">power_method_opnorm</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span> <span class="o">=</span> <span class="n">power_method_opnorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__norm</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self + other``.</span>

<span class="sd">        If other is an element in self.range, this corresponds to</span>

<span class="sd">            ``self + other &lt;==&gt; (x --&gt; self(x) + other)``</span>

<span class="sd">        If other is an element in self.range.field, this corresponds to</span>

<span class="sd">            ``self + other &lt;==&gt; (x --&gt; self(x) + 1*other)``</span>

<span class="sd">        where ``1`` is the one-element in self.range.</span>

<span class="sd">        If other is an opertor, this corresponds to</span>

<span class="sd">            ``self + other &lt;==&gt; (x --&gt; self(x) + other(x))``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OperatorVectorSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="n">constant_vector</span> <span class="o">=</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">one</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">OperatorVectorSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant_vector</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``other + self``.&quot;&quot;&quot;</span>
        <span class="c1"># Use commutativity</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self - other``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``other - self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self * other``.</span>

<span class="sd">        If ``other`` is an operator, this corresponds to</span>
<span class="sd">        operator composition:</span>

<span class="sd">            ``(left * right)(x) == left(right(x))``</span>

<span class="sd">        If ``other`` is a scalar, this corresponds to scalar multiplication</span>
<span class="sd">        with the operator argument:</span>

<span class="sd">            ``(op * scalar)(x) == op(scalar * x)``</span>

<span class="sd">        If ``other`` is an ``op.domain`` element, this corresponds to</span>
<span class="sd">        vector multiplication with the operator argument:</span>

<span class="sd">            ``(op * y)(x) == op(y * x)``</span>

<span class="sd">        Note that left and right multiplications are generally</span>
<span class="sd">        different.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : `Operator`, `LinearSpaceElement` or scalar</span>
<span class="sd">            `Operator`:</span>
<span class="sd">                The `Operator.domain` of ``other`` must match this</span>
<span class="sd">                operator&#39;s `Operator.range`.</span>

<span class="sd">            `LinearSpaceElement`:</span>
<span class="sd">                ``other`` must be an element of this operator&#39;s</span>
<span class="sd">                `Operator.domain`.</span>

<span class="sd">            scalar:</span>
<span class="sd">                The `Operator.domain` of this operator must be a</span>
<span class="sd">                `LinearSpace` and ``other`` must be an</span>
<span class="sd">                element of the ``field`` of this operator&#39;s</span>
<span class="sd">                `Operator.domain`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mul : `Operator`</span>
<span class="sd">            The multiplication operator.</span>

<span class="sd">            If ``other`` is an operator, ``mul`` is an</span>
<span class="sd">            `OperatorComp`.</span>

<span class="sd">            If ``other`` is a scalar, ``mul`` is an</span>
<span class="sd">            `OperatorRightScalarMult`.</span>

<span class="sd">            If ``other`` is an ``op.domain`` element, ``mul`` is an</span>
<span class="sd">            `OperatorRightVectorMult`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rn = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.IdentityOperator(rn)</span>
<span class="sd">        &gt;&gt;&gt; x = rn.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        rn(3).element([ 1.,  2.,  3.])</span>
<span class="sd">        &gt;&gt;&gt; Scaled = op * 3</span>
<span class="sd">        &gt;&gt;&gt; Scaled(x)</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="c1"># Left multiplication is more efficient, so we can use this in the</span>
            <span class="c1"># case of linear operator.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">other</span> <span class="o">*</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">OperatorRightScalarMult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OperatorRightVectorMult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self @ other``.</span>

<span class="sd">        See `Operator.__mul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``other * self``.</span>

<span class="sd">        If ``other`` is an `Operator`, this corresponds to</span>
<span class="sd">        operator composition:</span>

<span class="sd">            ``(left * right)(x) == left(right(x))``</span>

<span class="sd">        If ``other`` is a scalar, this corresponds to scalar multiplication</span>
<span class="sd">        with the operator evaluation result:</span>

<span class="sd">            ``(scalar * op)(x) == scalar * op(x)``</span>

<span class="sd">        If ``other`` is an ``op.domain`` element, this corresponds to</span>
<span class="sd">        vector multiplication with the operator evaluation result:</span>

<span class="sd">            ``(y * op)(x) == y * op(x)``</span>

<span class="sd">        Note that left and right multiplications are generally</span>
<span class="sd">        different.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : {`Operator`, `LinearSpaceElement`, scalar}</span>
<span class="sd">            `Operator`:</span>
<span class="sd">                The `Operator.range` of ``other`` must match this</span>
<span class="sd">                operator&#39;s `Operator.domain`</span>

<span class="sd">            `LinearSpaceElement`:</span>
<span class="sd">                ``other`` must be an element of `Operator.range`.</span>

<span class="sd">            scalar:</span>
<span class="sd">                `Operator.range` must be a</span>
<span class="sd">                `LinearSpace` and ``other`` must be an</span>
<span class="sd">                element of ``self.range.field``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mul : `Operator`</span>
<span class="sd">            The multiplication operator.</span>

<span class="sd">            If ``other`` is an operator, ``mul`` is an</span>
<span class="sd">            `OperatorComp`.</span>

<span class="sd">            If ``other`` is a scalar, ``mul`` is an</span>
<span class="sd">            `OperatorLeftScalarMult`.</span>

<span class="sd">            If ``other`` is an ``op.range`` element, ``mul`` is an</span>
<span class="sd">            `OperatorLeftVectorMult`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rn = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.IdentityOperator(rn)</span>
<span class="sd">        &gt;&gt;&gt; x = rn.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        rn(3).element([ 1.,  2.,  3.])</span>
<span class="sd">        &gt;&gt;&gt; Scaled = 3 * op</span>
<span class="sd">        &gt;&gt;&gt; Scaled(x)</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">OperatorLeftScalarMult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OperatorLeftVectorMult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">other</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">FunctionalLeftVectorMult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``other @ op``.</span>

<span class="sd">        See `Operator.__rmul__`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__rmul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``op ** n``.</span>

<span class="sd">        This corresponds to the power of an operator:</span>

<span class="sd">            ``(op ** 1)(x) == op(x)``</span>
<span class="sd">            ``(op ** 2)(x) == op(op(x))``</span>
<span class="sd">            ``(op ** 3)(x) == op(op(op(x)))``</span>
<span class="sd">            ...</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : positive int</span>
<span class="sd">            The power the operator should be taken to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pow : `Operator`</span>
<span class="sd">            The power of this operator. If ``n == 1``, ``pow`` is</span>
<span class="sd">            this operator, for ``n &gt; 1``, an `OperatorComp`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rn = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.ScalingOperator(rn, 3)</span>
<span class="sd">        &gt;&gt;&gt; x = rn.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &gt;&gt;&gt; squared = op ** 2</span>
<span class="sd">        &gt;&gt;&gt; squared(x)</span>
<span class="sd">        rn(3).element([  9.,  18.,  27.])</span>
<span class="sd">        &gt;&gt;&gt; squared = op**3</span>
<span class="sd">        &gt;&gt;&gt; squared(x)</span>
<span class="sd">        rn(3).element([ 27.,  54.,  81.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">op</span> <span class="o">=</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">op</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``self / other``.</span>

<span class="sd">        If ``other`` is a scalar, this corresponds to right</span>
<span class="sd">        division of operators with scalars:</span>

<span class="sd">            ``(op / scalar)(x) == op(x / scalar)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : scalar</span>
<span class="sd">            If `Operator.range` is a `LinearSpace`, ``scalar`` must be</span>
<span class="sd">            an element of the ``field`` of this operator&#39;s range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rmul : `OperatorRightScalarMult`</span>
<span class="sd">            The &#39;divided&#39; operator.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; rn = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.IdentityOperator(rn)</span>
<span class="sd">        &gt;&gt;&gt; x = rn.element([3, 6, 9])</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &gt;&gt;&gt; Scaled = op / 3.0</span>
<span class="sd">        &gt;&gt;&gt; Scaled(x)</span>
<span class="sd">        rn(3).element([ 1.,  2.,  3.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="n">__div__</span> <span class="o">=</span> <span class="fm">__truediv__</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``-self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``+op``.</span>

<span class="sd">        The operator itself.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        The default `repr` implementation. Should be overridden by</span>
<span class="sd">        subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">: </span><span class="si">{!r}</span><span class="s1"> -&gt; </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.</span>

<span class="sd">        The default string implementation. Should be overridden by</span>
<span class="sd">        subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="c1"># Give a `Operator` a higher priority than any NumPy array type. This</span>
    <span class="c1"># forces the usage of `__op__` of `Operator` if the other operand</span>
    <span class="c1"># is a NumPy object (applies also to scalars!).</span>
    <span class="c1"># Set higher than LinearSpaceElement.__array_priority__ to handle</span>
    <span class="c1"># vector multiplication properly</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">2000000.0</span></div>


<div class="viewcode-block" id="OperatorSum"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorSum.html#odl.operator.operator.OperatorSum">[docs]</a><span class="k">class</span> <span class="nc">OperatorSum</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the sum of operators.</span>

<span class="sd">        ``OperatorSum(left, right)(x) == left(x) + right(x)``</span>

<span class="sd">    The sum is only well-defined for `Operator` instances where</span>
<span class="sd">    `Operator.range` is a `LinearSpace`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorSum.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorSum.html#odl.operator.operator.OperatorSum.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">tmp_ran</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmp_dom</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `Operator`</span>
<span class="sd">            First summand. Its `Operator.range` must be a `LinearSpace` or</span>
<span class="sd">            `Field`.</span>
<span class="sd">        right : `Operator`</span>
<span class="sd">            Second summand. Must have the same `Operator.domain` and</span>
<span class="sd">            `Operator.range` as ``left``.</span>
<span class="sd">        tmp_ran : `Operator.range` element, optional</span>
<span class="sd">            Used to avoid the creation of a temporary when applying the</span>
<span class="sd">            operator.</span>
<span class="sd">        tmp_dom : `Operator.domain` element, optional</span>
<span class="sd">            Used to avoid the creation of a temporary when applying the</span>
<span class="sd">            operator adjoint.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; x = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; out = r3.element()</span>
<span class="sd">        &gt;&gt;&gt; OperatorSum(op, op)(x, out)  # In-place, returns out</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; out</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>
<span class="sd">        &gt;&gt;&gt; OperatorSum(op, op)(x)</span>
<span class="sd">        rn(3).element([ 2.,  4.,  6.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;operator ranges </span><span class="si">{!r}</span><span class="s1"> and </span><span class="si">{!r}</span><span class="s1"> do not match&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;`left.range` </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or &#39;</span>
                              <span class="s1">&#39;`Field` instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;operator domains </span><span class="si">{!r}</span><span class="s1"> and </span><span class="si">{!r}</span><span class="s1"> do not match&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tmp_ran</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmp_ran</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpRangeError</span><span class="p">(</span><span class="s1">&#39;`tmp_ran` </span><span class="si">{!r}</span><span class="s1"> not an element of the operator &#39;</span>
                               <span class="s1">&#39;range </span><span class="si">{!r}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_ran</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">tmp_dom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmp_dom</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpDomainError</span><span class="p">(</span><span class="s1">&#39;`tmp_dom` </span><span class="si">{!r}</span><span class="s1"> not an element of the &#39;</span>
                                <span class="s1">&#39;operator domain </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp_dom</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorSum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span>
            <span class="n">linear</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">is_linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_ran</span> <span class="o">=</span> <span class="n">tmp_ran</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_dom</span> <span class="o">=</span> <span class="n">tmp_dom</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/first part of this sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__left</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/second part of this sum.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__right</span>

<div class="viewcode-block" id="OperatorSum._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorSum._call.html#odl.operator.operator.OperatorSum._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tmp_ran</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_ran</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                   <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">())</span>
            <span class="c1"># Write to `tmp` first, otherwise aliased `x` and `out` lead</span>
            <span class="c1"># to wrong result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="OperatorSum.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorSum.derivative.html#odl.operator.operator.OperatorSum.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the operator derivative at ``x``.</span>

<span class="sd">        The derivative of a sum of two operators is equal to the sum of</span>
<span class="sd">        the derivatives.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            Evaluation point of the derivative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OperatorSum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_dom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_ran</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator sum is the sum of the operator</span>
<span class="sd">        adjoints:</span>

<span class="sd">            ``OperatorSum(left, right).adjoint ==</span>
<span class="sd">            OperatorSum(left.adjoint, right.adjoint)``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `OperatorSum`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If either of the underlying operators are non-linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">OperatorSum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_dom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp_ran</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorVectorSum"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorVectorSum.html#odl.operator.operator.OperatorVectorSum">[docs]</a><span class="k">class</span> <span class="nc">OperatorVectorSum</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Operator that computes ``op(x) + y``.</span>

<span class="sd">        ``OperatorVectorSum(op, y)(x) == op(x) + y``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorVectorSum.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorVectorSum.html#odl.operator.operator.OperatorVectorSum.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`</span>
<span class="sd">            Operator to be used in the sum. Its</span>
<span class="sd">            `Operator.range` must be a `LinearSpace`.</span>
<span class="sd">        vector : ``operator.range`` `element-like`</span>
<span class="sd">            Vector to be added to the operator result.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; y = r3.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; ident_op = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; sum_op = odl.OperatorVectorSum(ident_op, y)</span>
<span class="sd">        &gt;&gt;&gt; x = r3.element([4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; sum_op(x)</span>
<span class="sd">        rn(3).element([ 5.,  7.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`op` </span><span class="si">{!r}</span><span class="s1"> not a Operator instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">LinearSpace</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`op.range` </span><span class="si">{!r}</span><span class="s1"> not a LinearSpace instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorVectorSum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The operator to apply.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constant operator range element to add.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span>

<div class="viewcode-block" id="OperatorVectorSum._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorVectorSum._call.html#odl.operator.operator.OperatorVectorSum._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the residual at ``x`` and write to ``out`` if given.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="OperatorVectorSum.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorVectorSum.derivative.html#odl.operator.operator.OperatorVectorSum.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Derivative the operator vector sum.</span>

<span class="sd">        It is equal to the derivative of the &quot;inner&quot; operator:</span>

<span class="sd">            ``OperatorVectorSum(op, y).derivative(z) == op.derivative(z)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : `domain` element</span>
<span class="sd">            Any element in the domain where the derivative should be taken</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; sum = odl.OperatorVectorSum(op, r3.element([1, 2, 3]))</span>
<span class="sd">        &gt;&gt;&gt; x = r3.element([4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; sum.derivative(x)(x)</span>
<span class="sd">        rn(3).element([ 4.,  5.,  6.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">point</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">{}</span><span class="s1"> + </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorComp"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorComp.html#odl.operator.operator.OperatorComp">[docs]</a><span class="k">class</span> <span class="nc">OperatorComp</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the composition of operators.</span>

<span class="sd">        ``OperatorComp(left, right)(x) == left(right(x))``</span>

<span class="sd">    The composition is only well-defined if ``left.domain == right.range``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorComp.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorComp.html#odl.operator.operator.OperatorComp.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new `OperatorComp` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `Operator`</span>
<span class="sd">            The left (&quot;outer&quot;) operator</span>
<span class="sd">        right : `Operator`</span>
<span class="sd">            The right (&quot;inner&quot;) operator. Its range must coincide with the</span>
<span class="sd">            domain of ``left``.</span>
<span class="sd">        tmp : element of the range of ``right``, optional</span>
<span class="sd">            Used to avoid the creation of a temporary when applying the</span>
<span class="sd">            operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">range</span> <span class="o">!=</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> of the right operator </span><span class="si">{!r}</span><span class="s1"> not &#39;</span>
                              <span class="s1">&#39;equal to the domain </span><span class="si">{!r}</span><span class="s1"> of the left &#39;</span>
                              <span class="s1">&#39;operator </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span>
                                        <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">left</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpDomainError</span><span class="p">(</span><span class="s1">&#39;`tmp` </span><span class="si">{!r}</span><span class="s1"> not an element of the left &#39;</span>
                                <span class="s1">&#39;operator domain </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorComp</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">right</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span>
            <span class="n">linear</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">is_linear</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span> <span class="o">=</span> <span class="n">tmp</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/first part of this composition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__left</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/second part of this composition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__right</span>

<div class="viewcode-block" id="OperatorComp._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorComp._call.html#odl.operator.operator.OperatorComp._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                   <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        The inverse of the operator composition is the composition of</span>
<span class="sd">        the inverses in reverse order:</span>

<span class="sd">            ``OperatorComp(left, right).inverse ==``</span>
<span class="sd">            ``OperatorComp(right.inverse, left.inverse)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span><span class="p">)</span>

<div class="viewcode-block" id="OperatorComp.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorComp.derivative.html#odl.operator.operator.OperatorComp.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the operator derivative.</span>

<span class="sd">        The derivative of the operator composition follows the chain</span>
<span class="sd">        rule:</span>

<span class="sd">            ``OperatorComp(left, right).derivative(y) ==</span>
<span class="sd">            OperatorComp(left.derivative(right(y)), right.derivative(y))``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            Evaluation point of the derivative. Needs to be usable as</span>
<span class="sd">            input for the ``right`` operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
                <span class="n">left_deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

            <span class="n">right_deriv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="n">left_deriv</span><span class="p">,</span> <span class="n">right_deriv</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator composition is the composition of</span>
<span class="sd">        the operator adjoints in reverse order:</span>

<span class="sd">            ``OperatorComp(left, right).adjoint ==</span>
<span class="sd">            OperatorComp(right.adjoint, left.adjoint)``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `OperatorComp`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If any of the underlying operators are non-linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> o </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorPointwiseProduct"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorPointwiseProduct.html#odl.operator.operator.OperatorPointwiseProduct">[docs]</a><span class="k">class</span> <span class="nc">OperatorPointwiseProduct</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the pointwise operator mulitplication.</span>

<span class="sd">        ``OperatorPointwiseProduct(left, right)(x) == left(x) * right(x)``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorPointwiseProduct.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorPointwiseProduct.html#odl.operator.operator.OperatorPointwiseProduct.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : `Operator`</span>
<span class="sd">            The first factor</span>
<span class="sd">        right : `Operator`</span>
<span class="sd">            The second factor. Must have the same domain and range as</span>
<span class="sd">            ``left``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;operator ranges </span><span class="si">{!r}</span><span class="s1"> and </span><span class="si">{!r}</span><span class="s1"> do not match&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;range </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or `Field` &#39;</span>
                              <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">domain</span> <span class="o">!=</span> <span class="n">right</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;operator domains </span><span class="si">{!r}</span><span class="s1"> and </span><span class="si">{!r}</span><span class="s1"> do not match&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorPointwiseProduct</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__right</span> <span class="o">=</span> <span class="n">right</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/first part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__left</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The left/second part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__right</span>

<div class="viewcode-block" id="OperatorPointwiseProduct._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorPointwiseProduct._call.html#odl.operator.operator.OperatorPointwiseProduct._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
            <span class="c1"># Write to `tmp` first, otherwise aliased `x` and `out` lead</span>
            <span class="c1"># to wrong result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="n">tmp</span></div>

<div class="viewcode-block" id="OperatorPointwiseProduct.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorPointwiseProduct.derivative.html#odl.operator.operator.OperatorPointwiseProduct.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span></div>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorLeftScalarMult"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftScalarMult.html#odl.operator.operator.OperatorLeftScalarMult">[docs]</a><span class="k">class</span> <span class="nc">OperatorLeftScalarMult</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the operator left scalar multiplication.</span>

<span class="sd">        ``OperatorLeftScalarMult(op, s)(x) == s * op(x)``</span>

<span class="sd">    The scalar multiplication is well-defined only if ``op.range`` is</span>
<span class="sd">    a `LinearSpace`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorLeftScalarMult.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftScalarMult.html#odl.operator.operator.OperatorLeftScalarMult.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new `OperatorLeftScalarMult` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`</span>
<span class="sd">            Operator in the scalar multiplication. Its `range` must be</span>
<span class="sd">            a `LinearSpace` or `Field`.</span>
<span class="sd">        scalar : ``operator.range.field`` element</span>
<span class="sd">            A real or complex number, depending on the field of</span>
<span class="sd">            the range.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorLeftScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op([1, 2, 3])</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;range </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or `Field` &#39;</span>
                              <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">scalar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`scalar` </span><span class="si">{!r}</span><span class="s1"> not in the field </span><span class="si">{!r}</span><span class="s1"> of the &#39;</span>
                            <span class="s1">&#39;operator range </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span>
                                      <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                                      <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">OperatorLeftScalarMult</span><span class="p">):</span>
            <span class="c1"># Shortcut to save performance in case of repeated multiplications</span>
            <span class="n">scalar</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">scalar</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">operator</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorLeftScalarMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__scalar</span> <span class="o">=</span> <span class="n">scalar</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The operator part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The scalar part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__scalar</span>

<div class="viewcode-block" id="OperatorLeftScalarMult._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftScalarMult._call.html#odl.operator.operator.OperatorLeftScalarMult._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        The inverse of ``scalar * op`` is given by</span>
<span class="sd">        ``op.inverse * 1/scalar`` if ``scalar != 0``. If ``scalar == 0``,</span>
<span class="sd">        the inverse is not defined.</span>

<span class="sd">            ``OperatorLeftScalarMult(op, s).inverse ==</span>
<span class="sd">            OperatorRightScalarMult(op.inverse, 1/s)``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorLeftScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op.inverse([3, 3, 3])</span>
<span class="sd">        rn(3).element([ 1.,  1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> not invertible&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span>

<div class="viewcode-block" id="OperatorLeftScalarMult.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftScalarMult.derivative.html#odl.operator.operator.OperatorLeftScalarMult.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.</span>

<span class="sd">        Left scalar multiplication and derivative are commutative:</span>

<span class="sd">            ``OperatorLeftScalarMult(op, s).derivative(y) ==</span>
<span class="sd">            OperatorLeftScalarMult(op.derivative(y), s)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            Evaluation point of the derivative</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivative : `OperatorLeftScalarMult`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space) - space.element([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorLeftScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; derivative = left_mul_op.derivative([0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; derivative([1, 1, 1])</span>
<span class="sd">        rn(3).element([ 3.,  3.,  3.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator scalar multiplication is the</span>
<span class="sd">        scalar multiplication of the operator adjoint:</span>

<span class="sd">            ``OperatorLeftScalarMult(op, s).adjoint ==</span>
<span class="sd">            OperatorLeftScalarMult(op.adjoint, s)``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the underlying operator is non-linear.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorLeftScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op.adjoint([1, 2, 3])</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorRightScalarMult"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightScalarMult.html#odl.operator.operator.OperatorRightScalarMult">[docs]</a><span class="k">class</span> <span class="nc">OperatorRightScalarMult</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the operator right scalar multiplication.</span>

<span class="sd">        ``OperatorRightScalarMult(op, s) == op(s * x)``</span>

<span class="sd">    The scalar multiplication is well-defined only if ``op.domain`` is</span>
<span class="sd">    a `LinearSpace`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorRightScalarMult.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightScalarMult.html#odl.operator.operator.OperatorRightScalarMult.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">tmp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new `OperatorLeftScalarMult` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`</span>
<span class="sd">            Operator in the scalar multiplication. Its `domain` must</span>
<span class="sd">            be a `LinearSpace` or `Field`.</span>
<span class="sd">        scalar : ``operator.range.field`` element</span>
<span class="sd">            A real or complex number, depending on the field of</span>
<span class="sd">            the operator domain.</span>
<span class="sd">        tmp : `domain` element, optional</span>
<span class="sd">            Used to avoid the creation of a temporary when applying the</span>
<span class="sd">            operator.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorRightScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op([1, 2, 3])</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="p">(</span><span class="n">LinearSpace</span><span class="p">,</span> <span class="n">Field</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;domain </span><span class="si">{!r}</span><span class="s1"> not a `LinearSpace` or `Field` &#39;</span>
                              <span class="s1">&#39;instance&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">scalar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`scalar` </span><span class="si">{!r}</span><span class="s1"> not in the field </span><span class="si">{!r}</span><span class="s1"> of the &#39;</span>
                            <span class="s1">&#39;operator domain </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">field</span><span class="p">,</span>
                                      <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tmp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpDomainError</span><span class="p">(</span><span class="s1">&#39;`tmp` </span><span class="si">{!r}</span><span class="s1"> not an element of the &#39;</span>
                                <span class="s1">&#39;operator domain </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">OperatorRightScalarMult</span><span class="p">):</span>
            <span class="c1"># Shortcut to save performance in case of repeated multiplications</span>
            <span class="n">scalar</span> <span class="o">=</span> <span class="n">scalar</span> <span class="o">*</span> <span class="n">operator</span><span class="o">.</span><span class="n">scalar</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">operator</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorRightScalarMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__scalar</span> <span class="o">=</span> <span class="n">scalar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span> <span class="o">=</span> <span class="n">tmp</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The operator part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The scalar part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__scalar</span>

<div class="viewcode-block" id="OperatorRightScalarMult._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightScalarMult._call.html#odl.operator.operator.OperatorRightScalarMult._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self * other``.</span>

<span class="sd">        An optimization for repeated multiplications.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">other</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">OperatorRightScalarMult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">other</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">__tmp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">OperatorRightScalarMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__rmul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        The inverse of ``op * scalar`` is given by</span>
<span class="sd">        ``1/scalar * op.inverse`` if ``scalar != 0``. If ``scalar == 0``,</span>
<span class="sd">        the inverse is not defined.</span>

<span class="sd">            ``OperatorRightScalarMult(op, s).inverse ==</span>
<span class="sd">            OperatorLeftScalarMult(op.inverse, 1/s)``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorRightScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op.inverse([3, 3, 3])</span>
<span class="sd">        rn(3).element([ 1.,  1.,  1.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> not invertible&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span>

<div class="viewcode-block" id="OperatorRightScalarMult.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightScalarMult.derivative.html#odl.operator.operator.OperatorRightScalarMult.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.</span>

<span class="sd">        The derivative of the right scalar operator multiplication</span>
<span class="sd">        follows the chain rule:</span>

<span class="sd">            ``OperatorRightScalarMult(op, s).derivative(y) ==</span>
<span class="sd">            OperatorLeftScalarMult(op.derivative(s * y), s)``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` `element-like`</span>
<span class="sd">            Evaluation point of the derivative.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space) - space.element([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorRightScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; derivative = left_mul_op.derivative([0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; derivative([1, 1, 1])</span>
<span class="sd">        rn(3).element([ 3.,  3.,  3.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalar</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator scalar multiplication is the</span>
<span class="sd">        scalar multiplication of the operator adjoint:</span>

<span class="sd">        ``OperatorLeftScalarMult(op, s).adjoint ==</span>
<span class="sd">        OperatorLeftScalarMult(op.adjoint, s)``</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the underlying operator is non-linear.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; operator = odl.IdentityOperator(space)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = OperatorRightScalarMult(operator, 3)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op.adjoint([1, 2, 3])</span>
<span class="sd">        rn(3).element([ 3.,  6.,  9.])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar</span><span class="p">)</span></div>


<div class="viewcode-block" id="FunctionalLeftVectorMult"><a class="viewcode-back" href="../../../generated/odl.operator.operator.FunctionalLeftVectorMult.html#odl.operator.operator.FunctionalLeftVectorMult">[docs]</a><span class="k">class</span> <span class="nc">FunctionalLeftVectorMult</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the functional left vector multiplication.</span>

<span class="sd">    A functional is an `Operator` whose `Operator.range` is</span>
<span class="sd">    a `Field`. It is multiplied from left with a `LinearSpaceElement`,</span>
<span class="sd">    resulting in an operator mapping from the `Operator.domain` to the</span>
<span class="sd">    element&#39;s `LinearSpaceElement.space`.</span>

<span class="sd">        ``FunctionalLeftVectorMult(op, y)(x) == y * op(x)``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="FunctionalLeftVectorMult.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.FunctionalLeftVectorMult.html#odl.operator.operator.FunctionalLeftVectorMult.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">functional</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        functional : `Operator`</span>
<span class="sd">            Functional in the vector multiplication. Its `range` must</span>
<span class="sd">            be a `Field`.</span>
<span class="sd">        vector : ``functional.range`` `element-like`</span>
<span class="sd">            The element to multiply with. Its space&#39;s `LinearSpace.field`</span>
<span class="sd">            must be the same as ``functional.range``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create the operator ``(y * y^T)(x) = y * &lt;x, y&gt;``</span>

<span class="sd">        &gt;&gt;&gt; space = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; y = space.element([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; functional = odl.InnerProductOperator(y)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op = FunctionalLeftVectorMult(functional, y)</span>
<span class="sd">        &gt;&gt;&gt; left_mul_op([1, 2, 3])</span>
<span class="sd">        rn(3).element([ 14.,  28.,  42.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">LinearSpaceElement</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`vector` </span><span class="si">{!r}</span><span class="s1"> not is not a LinearSpaceElement&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vector</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">functional</span><span class="o">.</span><span class="n">range</span> <span class="o">!=</span> <span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpTypeError</span><span class="p">(</span><span class="s1">&#39;range </span><span class="si">{!r}</span><span class="s1"> not is not vector.space.field </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                              <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">functional</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">field</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">FunctionalLeftVectorMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">functional</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">functional</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__functional</span> <span class="o">=</span> <span class="n">functional</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span> <span class="o">=</span> <span class="n">vector</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The functional part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__functional</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The element part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span>

<div class="viewcode-block" id="FunctionalLeftVectorMult._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.FunctionalLeftVectorMult._call.html#odl.operator.operator.FunctionalLeftVectorMult._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">lincomb</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="FunctionalLeftVectorMult.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.FunctionalLeftVectorMult.derivative.html#odl.operator.operator.FunctionalLeftVectorMult.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.</span>

<span class="sd">        Left scalar multiplication and derivative are commutative:</span>

<span class="sd">            ``FunctionalLeftVectorMult(op, y).derivative(z) ==</span>
<span class="sd">            FunctionalLeftVectorMult(op.derivative(z), y)``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivative : `FunctionalLeftVectorMult`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FunctionalLeftVectorMult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">            ``FunctionalLeftVectorMult(op, y).adjoint ==</span>
<span class="sd">            OperatorComp(op.adjoint, y.T)``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `OperatorComp`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the underlying operator is non-linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">OperatorComp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">adjoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">functional</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorLeftVectorMult"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftVectorMult.html#odl.operator.operator.OperatorLeftVectorMult">[docs]</a><span class="k">class</span> <span class="nc">OperatorLeftVectorMult</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the operator left vector multiplication.</span>

<span class="sd">        ``OperatorLeftVectorMult(op, y)(x) &lt;==&gt; y * op(x)``</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorLeftVectorMult.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftVectorMult.html#odl.operator.operator.OperatorLeftVectorMult.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`</span>
<span class="sd">            The range of ``op`` must be a `LinearSpace`.</span>
<span class="sd">        vector : `LinearSpaceElement` in ``op.range``</span>
<span class="sd">            The vector to multiply by</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vector</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpRangeError</span><span class="p">(</span><span class="s1">&#39;`vector` </span><span class="si">{!r}</span><span class="s1"> not in operator.range </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                               <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorLeftVectorMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span> <span class="o">=</span> <span class="n">vector</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The operator part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fixed element to multiply with.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span>

<div class="viewcode-block" id="OperatorLeftVectorMult._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftVectorMult._call.html#odl.operator.operator.OperatorLeftVectorMult._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        The inverse of ``y * op`` is given by</span>
<span class="sd">        ``op.inverse / y``.</span>

<span class="sd">        ``OperatorLeftVectorMult(op, y).inverse ==</span>
<span class="sd">        OperatorRightVectorMult(op.inverse, 1/y)``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

<div class="viewcode-block" id="OperatorLeftVectorMult.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorLeftVectorMult.derivative.html#odl.operator.operator.OperatorLeftVectorMult.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.</span>

<span class="sd">        Left scalar multiplication and derivative are commutative:</span>

<span class="sd">            ``OperatorLeftVectorMult(op, y).derivative(z) ==</span>
<span class="sd">            OperatorLeftVectorMult(op.derivative(z), y)``</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        OperatorLeftVectorMult : the result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator left vector multiplication is the right</span>
<span class="sd">        multiplication of the given operator by the complex conjugate of the</span>
<span class="sd">        given vector.</span>

<span class="sd">            ``OperatorLeftVectorMult(op, y).adjoint ==</span>
<span class="sd">            OperatorRightVectorMult(op.adjoint, y.conj())``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `OperatorRightVectorMult`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the underlying operator is non-linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="c1"># The complex conjugate of a real vector is the vector itself.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span></div>


<div class="viewcode-block" id="OperatorRightVectorMult"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightVectorMult.html#odl.operator.operator.OperatorRightVectorMult">[docs]</a><span class="k">class</span> <span class="nc">OperatorRightVectorMult</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Expression type for the operator right vector multiplication.</span>

<span class="sd">        ``OperatorRightVectorMult(op, y)(x) == op(y * x)``</span>

<span class="sd">    The scalar multiplication is well-defined only if ``y`` is in</span>
<span class="sd">    ``op.domain``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OperatorRightVectorMult.__init__"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightVectorMult.html#odl.operator.operator.OperatorRightVectorMult.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a new `OperatorRightVectorMult` instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator : `Operator`</span>
<span class="sd">            The domain of ``operator`` must be a ``vector.space``.</span>
<span class="sd">        vector : ``op.domain`` element</span>
<span class="sd">            The fixed element to multiply with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`operator` </span><span class="si">{!r}</span><span class="s1"> not an `Operator` instance&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operator</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">vector</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpDomainError</span><span class="p">(</span><span class="s1">&#39;`vector` </span><span class="si">{!r}</span><span class="s1"> not in operator.domain </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">OperatorRightVectorMult</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">operator</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span> <span class="o">=</span> <span class="n">vector</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The operator part of this multiplication.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operator</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The fixed element to multiply with.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vector</span>

<div class="viewcode-block" id="OperatorRightVectorMult._call"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightVectorMult._call.html#odl.operator.operator.OperatorRightVectorMult._call">[docs]</a>    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implement ``self(x[, out])``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">()</span>
            <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        The inverse of ``op * y`` is given by</span>
<span class="sd">        ``(1/y) * op.inverse``.</span>

<span class="sd">            ``OperatorRightVectorMult(op, y).inverse ==</span>
<span class="sd">            OperatorLeftVectorMult(op.inverse, 1/y)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">inverse</span>

<div class="viewcode-block" id="OperatorRightVectorMult.derivative"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OperatorRightVectorMult.derivative.html#odl.operator.operator.OperatorRightVectorMult.derivative">[docs]</a>    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the derivative at ``x``.</span>

<span class="sd">        Left vector multiplication and derivative are commutative:</span>

<span class="sd">        ``OperatorRightVectorMult(op, y).derivative(x) &lt;==&gt;</span>
<span class="sd">        OperatorRightVectorMult(op.derivative(x), y)``</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        OperatorRightVectorMult : the result</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint of the operator right vector multiplication is the left</span>
<span class="sd">        multiplication of the given operator by the complex conjugate of the</span>
<span class="sd">        given vector.</span>

<span class="sd">            ``OperatorRightVectorMult(op, y).adjoint ==</span>
<span class="sd">            OperatorLeftVectorMult(op.adjoint, y.conj())``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `OperatorLeftVectorMult`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        OpNotImplementedError</span>
<span class="sd">            If the underlying operator is non-linear.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">OpNotImplementedError</span><span class="p">(</span><span class="s1">&#39;nonlinear operators have no adjoint&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">space</span><span class="o">.</span><span class="n">is_real</span><span class="p">:</span>
            <span class="c1"># The complex conjugate of a real vector is the vector itself.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">adjoint</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``str(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> * </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span></div>


<div class="viewcode-block" id="OpTypeError"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OpTypeError.html#odl.operator.operator.OpTypeError">[docs]</a><span class="k">class</span> <span class="nc">OpTypeError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception for operator type errors.</span>

<span class="sd">    Domain errors are raised by `Operator` subclasses when trying to call</span>
<span class="sd">    them with input not in the domain (`Operator.domain`) or with the wrong</span>
<span class="sd">    range (`Operator.range`).</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpDomainError"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OpDomainError.html#odl.operator.operator.OpDomainError">[docs]</a><span class="k">class</span> <span class="nc">OpDomainError</span><span class="p">(</span><span class="n">OpTypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception for domain errors.</span>

<span class="sd">    Domain errors are raised by `Operator` subclasses when trying to call</span>
<span class="sd">    them with input not in the domain (`Operator.domain`).</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpRangeError"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OpRangeError.html#odl.operator.operator.OpRangeError">[docs]</a><span class="k">class</span> <span class="nc">OpRangeError</span><span class="p">(</span><span class="n">OpTypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception for domain errors.</span>

<span class="sd">    Domain errors are raised by `Operator` subclasses when the returned</span>
<span class="sd">    value does not lie in the range (`Operator.range`).</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="OpNotImplementedError"><a class="viewcode-back" href="../../../generated/odl.operator.operator.OpNotImplementedError.html#odl.operator.operator.OpNotImplementedError">[docs]</a><span class="k">class</span> <span class="nc">OpNotImplementedError</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exception for not implemented errors in `LinearSpace`&#39;s.</span>

<span class="sd">    These are raised when a method in `LinearSpace` that has not been</span>
<span class="sd">    defined in a specific space is called.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2014-2020 The ODL Contributors.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>