<!DOCTYPE html>
<html class="writer-html5" lang="english" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>odl.operator.pspace_ops &mdash; odl 1.0.0.dev0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b76e3c8a" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=d6003e95" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/documentation_options.js?v=293a974f"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            odl
          </a>
              <div class="version">
                1.0.0.dev0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/getting_started.html">Getting Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Working with ODL</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/guide.html">User's guide -- selected topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math/math.html">Mathematical Background</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer zone</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/dev.html">Contributing to ODL</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Useful facts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/faq.html">Frequently asked questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../guide/glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../refs.html">References</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../odl.html">odl</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">odl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">odl.operator.pspace_ops</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for odl.operator.pspace_ops</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2014-2019 The ODL contributors</span>
<span class="c1">#</span>
<span class="c1"># This file is part of ODL.</span>
<span class="c1">#</span>
<span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public License,</span>
<span class="c1"># v. 2.0. If a copy of the MPL was not distributed with this file, You can</span>
<span class="c1"># obtain one at https://mozilla.org/MPL/2.0/.</span>

<span class="sd">&quot;&quot;&quot;Default operators defined on any `ProductSpace`.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">odl.operator.operator</span> <span class="kn">import</span> <span class="n">Operator</span>
<span class="kn">from</span> <span class="nn">odl.operator.default_ops</span> <span class="kn">import</span> <span class="n">ZeroOperator</span>
<span class="kn">from</span> <span class="nn">odl.space</span> <span class="kn">import</span> <span class="n">ProductSpace</span>
<span class="kn">from</span> <span class="nn">odl.util</span> <span class="kn">import</span> <span class="n">COOMatrix</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ProductSpaceOperator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ComponentProjection&#39;</span><span class="p">,</span> <span class="s1">&#39;ComponentProjectionAdjoint&#39;</span><span class="p">,</span>
           <span class="s1">&#39;BroadcastOperator&#39;</span><span class="p">,</span> <span class="s1">&#39;ReductionOperator&#39;</span><span class="p">,</span> <span class="s1">&#39;DiagonalOperator&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="ProductSpaceOperator">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ProductSpaceOperator.html#odl.operator.pspace_ops.ProductSpaceOperator">[docs]</a>
<span class="k">class</span> <span class="nc">ProductSpaceOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A &quot;matrix of operators&quot; on product spaces.</span>

<span class="sd">    For example a matrix of operators can act on a vector by</span>

<span class="sd">        ``ProductSpaceOperator([[A, B], [C, D]])([x, y]) =</span>
<span class="sd">        [A(x) + B(y), C(x) + D(y)]``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is intended for the case where an operator can be decomposed</span>
<span class="sd">    as a linear combination of &quot;sub-operators&quot;, e.g.</span>

<span class="sd">    .. math::</span>
<span class="sd">        \left(</span>
<span class="sd">        \begin{array}{ccc}</span>
<span class="sd">        A &amp; B &amp; 0 \\</span>
<span class="sd">        0 &amp; C &amp; 0 \\</span>
<span class="sd">        0 &amp; 0 &amp; D</span>
<span class="sd">        \end{array}\right)</span>
<span class="sd">        \left(</span>
<span class="sd">        \begin{array}{c}</span>
<span class="sd">        x \\</span>
<span class="sd">        y \\</span>
<span class="sd">        z</span>
<span class="sd">        \end{array}\right)</span>
<span class="sd">        =</span>
<span class="sd">        \left(</span>
<span class="sd">        \begin{array}{c}</span>
<span class="sd">        A(x) + B(y) \\</span>
<span class="sd">        C(y) \\</span>
<span class="sd">        D(z)</span>
<span class="sd">        \end{array}\right)</span>

<span class="sd">    Mathematically, a `ProductSpaceOperator` is an operator</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{A}: \mathcal{X} \to \mathcal{Y}</span>

<span class="sd">    between product spaces</span>
<span class="sd">    :math:`\mathcal{X}=\mathcal{X}_1 \times\dots\times \mathcal{X}_m`</span>
<span class="sd">    and</span>
<span class="sd">    :math:`\mathcal{Y}=\mathcal{Y}_1 \times\dots\times \mathcal{Y}_n`</span>
<span class="sd">    which can be written in the form</span>

<span class="sd">    .. math::</span>
<span class="sd">        \mathcal{A} = (\mathcal{A}_{ij})_{i,j},  \quad</span>
<span class="sd">                          i = 1, \dots, n, \ j = 1, \dots, m</span>

<span class="sd">    with *component operators*</span>
<span class="sd">    :math:`\mathcal{A}_{ij}: \mathcal{X}_j \to \mathcal{Y}_i`.</span>

<span class="sd">    Its action on a vector :math:`x = (x_1, \dots, x_m)` is defined as</span>
<span class="sd">    the matrix multiplication</span>

<span class="sd">    .. math::</span>
<span class="sd">        [\mathcal{A}(x)]_i = \sum_{j=1}^m \mathcal{A}_{ij}(x_j).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    BroadcastOperator : Case when a single argument is used by several ops.</span>
<span class="sd">    ReductionOperator : Calculates sum of operator results.</span>
<span class="sd">    DiagonalOperator : Case where the &#39;matrix&#39; is diagonal.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ProductSpaceOperator.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ProductSpaceOperator.html#odl.operator.pspace_ops.ProductSpaceOperator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operators : `array-like`</span>
<span class="sd">            An array of `Operator`&#39;s, must be 2-dimensional.</span>
<span class="sd">        domain : `ProductSpace`, optional</span>
<span class="sd">            Domain of the operator. If not provided, it is tried to be</span>
<span class="sd">            inferred from the operators. This requires each **column**</span>
<span class="sd">            to contain at least one operator.</span>
<span class="sd">        range : `ProductSpace`, optional</span>
<span class="sd">            Range of the operator. If not provided, it is tried to be</span>
<span class="sd">            inferred from the operators. This requires each **row**</span>
<span class="sd">            to contain at least one operator.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r3, r3)</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; x = pspace.element([[1, 2, 3],</span>
<span class="sd">        ...                     [4, 5, 6]])</span>

<span class="sd">        Create an operator that sums two inputs:</span>

<span class="sd">        &gt;&gt;&gt; prod_op = odl.ProductSpaceOperator([[I, I]])</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 1).element([</span>
<span class="sd">            [ 5.,  7.,  9.]</span>
<span class="sd">        ])</span>

<span class="sd">        Diagonal operator -- 0 or ``None`` means ignore, or the implicit</span>
<span class="sd">        zero operator:</span>

<span class="sd">        &gt;&gt;&gt; prod_op = odl.ProductSpaceOperator([[I, 0],</span>
<span class="sd">        ...                                     [0, I]])</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [ 4.,  5.,  6.]</span>
<span class="sd">        ])</span>

<span class="sd">        If a column is empty, the operator domain must be specified. The</span>
<span class="sd">        same holds for an empty row and the range of the operator:</span>

<span class="sd">        &gt;&gt;&gt; prod_op = odl.ProductSpaceOperator([[I, 0],</span>
<span class="sd">        ...                                     [I, 0]], domain=r3 ** 2)</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [ 1.,  2.,  3.]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; prod_op = odl.ProductSpaceOperator([[I, I],</span>
<span class="sd">        ...                                     [0, 0]], range=r3 ** 2)</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 5.,  7.,  9.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span>

        <span class="c1"># Validate input data</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`domain` </span><span class="si">{!r}</span><span class="s1"> not a ProductSpace instance&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">domain</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">domain</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;weighted spaces not supported&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">ProductSpace</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`range` </span><span class="si">{!r}</span><span class="s1"> not a ProductSpace instance&#39;</span>
                                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">range</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">range</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;weighted spaces not supported&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">Operator</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;sparse matrix `operator` contains non-&#39;</span>
                                 <span class="s1">&#39;`Operator` entries&#39;</span><span class="p">)</span>
            <span class="c1"># scipy sparse matrix not supported (deprecated due to API changes)</span>
            <span class="c1"># keep now for backward compatibility</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: scipy.sparse.spmatrix is deprecated.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span> <span class="o">=</span> <span class="n">COOMatrix</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">col</span><span class="p">),</span>
                                   <span class="n">operators</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">COOMatrix</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span> <span class="o">=</span> <span class="n">operators</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_spmatrix</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>

        <span class="c1"># Set domain and range (or verify if given)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">domains</span> <span class="o">=</span> <span class="n">domain</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="nb">range</span>

        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">domains</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">domains</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span>
            <span class="k">elif</span> <span class="n">domains</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;column </span><span class="si">{}</span><span class="s1">, has inconsistent domains, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">domains</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">op</span><span class="o">.</span><span class="n">domain</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ranges</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ranges</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span>
            <span class="k">elif</span> <span class="n">ranges</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">!=</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;row </span><span class="si">{}</span><span class="s1">, has inconsistent ranges, &#39;</span>
                                 <span class="s1">&#39;got </span><span class="si">{}</span><span class="s1"> and </span><span class="si">{}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">ranges</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="n">op</span><span class="o">.</span><span class="n">range</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">sub_domain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">domains</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sub_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;col </span><span class="si">{}</span><span class="s1"> empty, unable to determine &#39;</span>
                                     <span class="s1">&#39;domain, please use `domain` parameter&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>

            <span class="n">domain</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="n">domains</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">sub_range</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sub_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;row </span><span class="si">{}</span><span class="s1"> empty, unable to determine &#39;</span>
                                     <span class="s1">&#39;range, please use `range` parameter&#39;</span>
                                     <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">))</span>

            <span class="nb">range</span> <span class="o">=</span> <span class="n">ProductSpace</span><span class="p">(</span><span class="o">*</span><span class="n">ranges</span><span class="p">)</span>

        <span class="c1"># Set linearity</span>
        <span class="n">linear</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">is_linear</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ProductSpaceOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="nb">range</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_to_spmatrix</span><span class="p">(</span><span class="n">operators</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an array-like object of operators to a sparse matrix.&quot;&quot;&quot;</span>

        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="c1"># import scipy.sparse</span>

        <span class="c1"># Convert ops to sparse representation. This is not trivial because</span>
        <span class="c1"># operators can be indexable themselves and give the wrong impression</span>
        <span class="c1"># of an extra dimension. So we have to infer the shape manually</span>
        <span class="c1"># first and extract the indices of nonzero positions.</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operators</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">iter</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`operators` must be a matrix of `Operator` objects, `0` &#39;</span>
                    <span class="s1">&#39;or `None`, got </span><span class="si">{!r}</span><span class="s1"> (row </span><span class="si">{}</span><span class="s1"> = </span><span class="si">{!r}</span><span class="s1"> is not iterable)&#39;</span>
                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`operators` must be a matrix of `Operator` objects, `0` &#39;</span>
                    <span class="s1">&#39;or `None`, but row </span><span class="si">{}</span><span class="s1"> is an `Operator` </span><span class="si">{!r}</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ncols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncols</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;all rows in `operators` must have the same length, but &#39;</span>
                    <span class="s1">&#39;length </span><span class="si">{}</span><span class="s1"> of row </span><span class="si">{}</span><span class="s1"> differs from previous common length &#39;</span>
                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">ncols</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Operator</span><span class="p">):</span>
                    <span class="n">irow</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">icol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;`operators` must be a matrix of `Operator` objects, &#39;</span>
                        <span class="s1">&#39;`0` or `None`, got entry </span><span class="si">{!r}</span><span class="s1"> at (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="c1"># Create object array explicitly, threby avoiding erroneous conversion</span>
        <span class="c1"># in `coo_matrix.__init__`</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">data_arr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>

        <span class="k">return</span> <span class="n">COOMatrix</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="p">(</span><span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">),</span> <span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The sparse operator matrix representing this operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ops</span>

<div class="viewcode-block" id="ProductSpaceOperator._call">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ProductSpaceOperator._call.html#odl.operator.pspace_ops.ProductSpaceOperator._call">[docs]</a>
    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call the operators on the parts of ``x``.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: add optimization in case an operator appears repeatedly in a</span>
        <span class="c1"># row</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_evaluated_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">has_evaluated_row</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># TODO: optimize</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">op</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                <span class="n">has_evaluated_row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">evaluated</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">has_evaluated_row</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">evaluated</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_zero</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="ProductSpaceOperator.derivative">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ProductSpaceOperator.derivative.html#odl.operator.pspace_ops.ProductSpaceOperator.derivative">[docs]</a>
    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derivative of the product space operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            The point to take the derivative in</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : linear`ProductSpaceOperator`</span>
<span class="sd">            The derivative</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r3, r3)</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; x = pspace.element([[1, 2, 3], [4, 5, 6]])</span>

<span class="sd">        Example with linear operator (derivative is itself)</span>

<span class="sd">        &gt;&gt;&gt; prod_op = ProductSpaceOperator([[0, I], [0, 0]],</span>
<span class="sd">        ...                                domain=pspace, range=pspace)</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 4.,  5.,  6.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; prod_op.derivative(x)(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 4.,  5.,  6.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>

<span class="sd">        Example with affine operator</span>

<span class="sd">        &gt;&gt;&gt; residual_op = I - r3.element([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; op = ProductSpaceOperator([[0, residual_op], [0, 0]],</span>
<span class="sd">        ...                           domain=pspace, range=pspace)</span>

<span class="sd">        Calling operator gives offset by [1, 1, 1]</span>

<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 3.,  4.,  5.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>

<span class="sd">        Derivative of affine operator does not have this offset</span>

<span class="sd">        &gt;&gt;&gt; op.derivative(x)(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 4.,  5.,  6.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span>

        <span class="c1"># Short circuit optimization</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_linear</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">deriv_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">)]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deriv_ops</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">deriv_ops</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">]</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">deriv_matrix</span> <span class="o">=</span> <span class="n">COOMatrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ProductSpaceOperator</span><span class="p">(</span><span class="n">deriv_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        The adjoint is given by taking the transpose of the matrix</span>
<span class="sd">        and the adjoint of each component operator.</span>

<span class="sd">        In weighted product spaces, the adjoint needs to take the</span>
<span class="sd">        weightings into account. This is currently not supported.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `ProductSpaceOperator`</span>
<span class="sd">            The adjoint</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r3, r3)</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; x = pspace.element([[1, 2, 3],</span>
<span class="sd">        ...                     [4, 5, 6]])</span>

<span class="sd">        Matrix is transposed:</span>

<span class="sd">        &gt;&gt;&gt; prod_op = ProductSpaceOperator([[0, I], [0, 0]],</span>
<span class="sd">        ...                                domain=pspace, range=pspace)</span>
<span class="sd">        &gt;&gt;&gt; prod_op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 4.,  5.,  6.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>
<span class="sd">        &gt;&gt;&gt; prod_op.adjoint(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 0.,  0.,  0.],</span>
<span class="sd">            [ 1.,  2.,  3.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span>

        <span class="n">adjoint_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">adjoint</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">adjoint_ops</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">adjoint_ops</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>  <span class="c1"># Swap col/row -&gt; transpose</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">adj_matrix</span> <span class="o">=</span> <span class="n">COOMatrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ProductSpaceOperator</span><span class="p">(</span><span class="n">adj_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

<div class="viewcode-block" id="ProductSpaceOperator.__getitem__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ProductSpaceOperator.__getitem__.html#odl.operator.pspace_ops.ProductSpaceOperator.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get sub-operator by index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or tuple of int</span>
<span class="sd">            A pair of integers given as (row, col).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        suboperator : `ReductionOperator`, `Operator` or ``0``</span>
<span class="sd">            If index is an integer, return the row given by the index.</span>

<span class="sd">            If index is a tuple, it must have two elements.</span>
<span class="sd">            if there is an operator at ``(row, col)``,  the operator is</span>
<span class="sd">            returned, otherwise ``0``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r3, r3)</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; prod_op = ProductSpaceOperator([[0, I],</span>
<span class="sd">        ...                                 [0, 0]],</span>
<span class="sd">        ...                                domain=pspace, range=pspace)</span>
<span class="sd">        &gt;&gt;&gt; prod_op[0, 0]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; prod_op[0, 1]</span>
<span class="sd">        IdentityOperator(rn(3))</span>
<span class="sd">        &gt;&gt;&gt; prod_op[1, 0]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; prod_op[1, 1]</span>
<span class="sd">        0</span>

<span class="sd">        By accessing single indices, a row is extracted as a</span>
<span class="sd">        `ReductionOperator`:</span>

<span class="sd">        &gt;&gt;&gt; prod_op[0]</span>
<span class="sd">        ReductionOperator(ZeroOperator(rn(3)), IdentityOperator(rn(3)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">index</span>

            <span class="n">linear_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">row</span><span class="p">)</span> <span class="o">&amp;</span>
                                          <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">col</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">linear_index</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">linear_index</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="n">ops</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="n">ops</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ops</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ZeroOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">ReductionOperator</span><span class="p">(</span><span class="o">*</span><span class="n">ops</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of the matrix of operators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total size of the matrix of operators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.&quot;&quot;&quot;</span>
        <span class="n">aslist</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">aslist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">aslist</span><span class="p">)</span></div>



<div class="viewcode-block" id="ComponentProjection">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjection.html#odl.operator.pspace_ops.ComponentProjection">[docs]</a>
<span class="k">class</span> <span class="nc">ComponentProjection</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Projection onto the subspace identified by an index.</span>

<span class="sd">    For a product space :math:`\mathcal{X} = \mathcal{X}_1 \times \dots</span>
<span class="sd">    \times \mathcal{X}_n`, the component projection</span>

<span class="sd">    .. math::</span>
<span class="sd">       \mathcal{P}_i: \mathcal{X} \to \mathcal{X}_i</span>

<span class="sd">    is given by :math:`\mathcal{P}_i(x) = x_i` for an element</span>
<span class="sd">    :math:`x = (x_1, \dots, x_n) \in \mathcal{X}`.</span>

<span class="sd">    More generally, for an index set :math:`I \subset \{1, \dots, n\}`,</span>
<span class="sd">    the projection operator :math:`\mathcal{P}_I` is defined by</span>
<span class="sd">    :math:`\mathcal{P}_I(x) = (x_i)_{i \in I}`.</span>

<span class="sd">    Note that this is a special case of a product space operator where</span>
<span class="sd">    the &quot;operator matrix&quot; has only one row and contains only</span>
<span class="sd">    identity operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ComponentProjection.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjection.html#odl.operator.pspace_ops.ComponentProjection.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `ProductSpace`</span>
<span class="sd">            Space to project from.</span>
<span class="sd">        index : int, slice, or list</span>
<span class="sd">            Indices defining the subspace. If ``index`` is not an integer,</span>
<span class="sd">            the `Operator.range` of this operator is also a `ProductSpace`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r1 = odl.rn(1)</span>
<span class="sd">        &gt;&gt;&gt; r2 = odl.rn(2)</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r1, r2, r3)</span>

<span class="sd">        Projection on n-th component:</span>

<span class="sd">        &gt;&gt;&gt; proj = odl.ComponentProjection(pspace, 0)</span>
<span class="sd">        &gt;&gt;&gt; x = [[1],</span>
<span class="sd">        ...      [2, 3],</span>
<span class="sd">        ...      [4, 5, 6]]</span>
<span class="sd">        &gt;&gt;&gt; proj(x)</span>
<span class="sd">        rn(1).element([ 1.])</span>

<span class="sd">        Projection on sub-space:</span>

<span class="sd">        &gt;&gt;&gt; proj = odl.ComponentProjection(pspace, [0, 2])</span>
<span class="sd">        &gt;&gt;&gt; proj(x)</span>
<span class="sd">        ProductSpace(rn(1), rn(3)).element([</span>
<span class="sd">            [ 1.],</span>
<span class="sd">            [ 4.,  5.,  6.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ComponentProjection</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="p">,</span> <span class="n">space</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index of the subspace.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

<div class="viewcode-block" id="ComponentProjection._call">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjection._call.html#odl.operator.pspace_ops.ComponentProjection._call">[docs]</a>
    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project ``x`` onto the subspace.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The adjoint operator.</span>

<span class="sd">        The adjoint is given by extending along `ComponentProjection.index`,</span>
<span class="sd">        and setting zero along the others.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ComponentProjectionAdjoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ComponentProjectionAdjoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(odl.rn(1), odl.rn(2))</span>
<span class="sd">        &gt;&gt;&gt; odl.ComponentProjection(pspace, 0)</span>
<span class="sd">        ComponentProjection(ProductSpace(rn(1), rn(2)), 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span></div>



<div class="viewcode-block" id="ComponentProjectionAdjoint">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjectionAdjoint.html#odl.operator.pspace_ops.ComponentProjectionAdjoint">[docs]</a>
<span class="k">class</span> <span class="nc">ComponentProjectionAdjoint</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjoint operator to `ComponentProjection`.</span>

<span class="sd">    As a special case of the adjoint of a `ProductSpaceOperator`,</span>
<span class="sd">    this operator is given as a column vector of identity operators</span>
<span class="sd">    and zero operators, with the identities placed in the positions</span>
<span class="sd">    defined by `ComponentProjectionAdjoint.index`.</span>

<span class="sd">    In weighted product spaces, the adjoint needs to take the</span>
<span class="sd">    weightings into account. This is currently not supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ComponentProjectionAdjoint.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjectionAdjoint.html#odl.operator.pspace_ops.ComponentProjectionAdjoint.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : `ProductSpace`</span>
<span class="sd">            Space to project to.</span>
<span class="sd">        index : int, slice, or list</span>
<span class="sd">            Indexes to project from.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r1 = odl.rn(1)</span>
<span class="sd">        &gt;&gt;&gt; r2 = odl.rn(2)</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(r1, r2, r3)</span>
<span class="sd">        &gt;&gt;&gt; x = pspace.element([[1],</span>
<span class="sd">        ...                     [2, 3],</span>
<span class="sd">        ...                     [4, 5, 6]])</span>

<span class="sd">        Projection on the 0-th component:</span>

<span class="sd">        &gt;&gt;&gt; proj_adj = odl.ComponentProjectionAdjoint(pspace, 0)</span>
<span class="sd">        &gt;&gt;&gt; proj_adj(x[0])</span>
<span class="sd">        ProductSpace(rn(1), rn(2), rn(3)).element([</span>
<span class="sd">            [ 1.],</span>
<span class="sd">            [ 0.,  0.],</span>
<span class="sd">            [ 0.,  0.,  0.]</span>
<span class="sd">        ])</span>

<span class="sd">        Projection on a sub-space corresponding to indices 0 and 2:</span>

<span class="sd">        &gt;&gt;&gt; proj_adj = odl.ComponentProjectionAdjoint(pspace, [0, 2])</span>
<span class="sd">        &gt;&gt;&gt; proj_adj(x[[0, 2]])</span>
<span class="sd">        ProductSpace(rn(1), rn(2), rn(3)).element([</span>
<span class="sd">            [ 1.],</span>
<span class="sd">            [ 0.,  0.],</span>
<span class="sd">            [ 4.,  5.,  6.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ComponentProjectionAdjoint</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">space</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">space</span><span class="p">,</span> <span class="n">linear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Index of the subspace.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__index</span>

<div class="viewcode-block" id="ComponentProjectionAdjoint._call">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ComponentProjectionAdjoint._call.html#odl.operator.pspace_ops.ComponentProjectionAdjoint._call">[docs]</a>
    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend ``x`` from the subspace.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">set_zero</span><span class="p">()</span>

        <span class="n">out</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `ComponentProjection`</span>
<span class="sd">            The adjoint is given by the `ComponentProjection` related to this</span>
<span class="sd">            operator&#39;s `index`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ComponentProjection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pspace = odl.ProductSpace(odl.rn(1), odl.rn(2))</span>
<span class="sd">        &gt;&gt;&gt; odl.ComponentProjectionAdjoint(pspace, 0)</span>
<span class="sd">        ComponentProjectionAdjoint(ProductSpace(rn(1), rn(2)), 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span></div>



<div class="viewcode-block" id="BroadcastOperator">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.BroadcastOperator.html#odl.operator.pspace_ops.BroadcastOperator">[docs]</a>
<span class="k">class</span> <span class="nc">BroadcastOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Broadcast argument to set of operators.</span>

<span class="sd">    An argument is broadcast by evaluating several operators in the same</span>
<span class="sd">    point::</span>

<span class="sd">        BroadcastOperator(op1, op2)(x) = [op1(x), op2(x)]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProductSpaceOperator : More general case, used as backend.</span>
<span class="sd">    ReductionOperator : Calculates sum of operator results.</span>
<span class="sd">    DiagonalOperator : Case where each operator should have its own argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BroadcastOperator.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.BroadcastOperator.html#odl.operator.pspace_ops.BroadcastOperator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operators</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator1,...,operatorN : `Operator` or `int`</span>
<span class="sd">            The individual operators that should be evaluated.</span>
<span class="sd">            Can also be given as ``operator, n`` with ``n`` integer,</span>
<span class="sd">            in which case ``operator`` is repeated ``n`` times.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Initialize an operator:</span>

<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = BroadcastOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op.domain</span>
<span class="sd">        rn(3)</span>
<span class="sd">        &gt;&gt;&gt; op.range</span>
<span class="sd">        ProductSpace(rn(3), 2)</span>

<span class="sd">        Evaluate the operator:</span>

<span class="sd">        &gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [ 2.,  4.,  6.]</span>
<span class="sd">        ])</span>

<span class="sd">        Can also initialize by calling an operator repeatedly:</span>

<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = BroadcastOperator(I, 2)</span>
<span class="sd">        &gt;&gt;&gt; op.operators</span>
<span class="sd">        (IdentityOperator(rn(3)), IdentityOperator(rn(3)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">*</span> <span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span> <span class="o">=</span> <span class="n">operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__prod_op</span> <span class="o">=</span> <span class="n">ProductSpaceOperator</span><span class="p">([[</span><span class="n">op</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operators</span><span class="p">])</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BroadcastOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">range</span><span class="p">,</span>
            <span class="n">linear</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prod_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`ProductSpaceOperator` implementation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prod_op</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tuple of sub-operators that comprise ``self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span>

<div class="viewcode-block" id="BroadcastOperator.__getitem__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.BroadcastOperator.__getitem__.html#odl.operator.pspace_ops.BroadcastOperator.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``self(index)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of sub-operators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="BroadcastOperator._call">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.BroadcastOperator._call.html#odl.operator.pspace_ops.BroadcastOperator._call">[docs]</a>
    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate all operators in ``x`` and broadcast.&quot;&quot;&quot;</span>
        <span class="n">wrapped_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">cast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="p">(</span><span class="n">wrapped_x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="BroadcastOperator.derivative">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.BroadcastOperator.derivative.html#odl.operator.pspace_ops.BroadcastOperator.derivative">[docs]</a>
    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derivative of the broadcast operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            The point to take the derivative in</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : linear `BroadcastOperator`</span>
<span class="sd">            The derivative</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Example with an affine operator:</span>

<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; residual_op = I - I.domain.element([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; op = BroadcastOperator(residual_op, 2 * residual_op)</span>

<span class="sd">        Calling operator offsets by ``[1, 1, 1]``:</span>

<span class="sd">        &gt;&gt;&gt; x = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; op(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 0.,  1.,  2.],</span>
<span class="sd">            [ 0.,  2.,  4.]</span>
<span class="sd">        ])</span>

<span class="sd">        The derivative of this affine operator does not have an offset:</span>

<span class="sd">        &gt;&gt;&gt; op.derivative(x)(x)</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [ 2.,  4.,  6.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BroadcastOperator</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">])</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : linear `BroadcastOperator`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = BroadcastOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op.adjoint([[1, 2, 3], [2, 3, 4]])</span>
<span class="sd">        rn(3).element([  5.,   8.,  11.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ReductionOperator</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">adjoint</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; spc = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; id = odl.IdentityOperator(spc)</span>
<span class="sd">        &gt;&gt;&gt; odl.BroadcastOperator(id, 3)</span>
<span class="sd">        BroadcastOperator(IdentityOperator(rn(3)), 3)</span>
<span class="sd">        &gt;&gt;&gt; scale = odl.ScalingOperator(spc, 3)</span>
<span class="sd">        &gt;&gt;&gt; odl.BroadcastOperator(id, scale)</span>
<span class="sd">        BroadcastOperator(IdentityOperator(rn(3)), ScalingOperator(rn(3), 3.0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_repr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">op_repr</span><span class="p">)</span></div>



<div class="viewcode-block" id="ReductionOperator">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ReductionOperator.html#odl.operator.pspace_ops.ReductionOperator">[docs]</a>
<span class="k">class</span> <span class="nc">ReductionOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reduce argument over set of operators.</span>

<span class="sd">    An argument is reduced by evaluating several operators and summing the</span>
<span class="sd">    result::</span>

<span class="sd">        ReductionOperator(op1, op2)(x) = op1(x[0]) + op2(x[1])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProductSpaceOperator : More general case, used as backend.</span>
<span class="sd">    BroadcastOperator : Calls several operators with same argument.</span>
<span class="sd">    DiagonalOperator : Case where each operator should have its own argument.</span>
<span class="sd">    SeparableSum : Corresponding construction for functionals.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ReductionOperator.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ReductionOperator.html#odl.operator.pspace_ops.ReductionOperator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operators</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator1,...,operatorN : `Operator` or `int`</span>
<span class="sd">            The individual operators that should be evaluated and summed.</span>
<span class="sd">            Can also be given as ``operator, n`` with ``n`` integer,</span>
<span class="sd">            in which case ``operator`` is repeated ``n`` times.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = ReductionOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op.domain</span>
<span class="sd">        ProductSpace(rn(3), 2)</span>
<span class="sd">        &gt;&gt;&gt; op.range</span>
<span class="sd">        rn(3)</span>

<span class="sd">        Evaluating in a point gives the sum of the evaluation results of</span>
<span class="sd">        the individual operators:</span>

<span class="sd">        &gt;&gt;&gt; op([[1, 2, 3],</span>
<span class="sd">        ...     [4, 6, 8]])</span>
<span class="sd">        rn(3).element([  9.,  14.,  19.])</span>

<span class="sd">        An ``out`` argument can be given for in-place evaluation:</span>

<span class="sd">        &gt;&gt;&gt; out = op.range.element()</span>
<span class="sd">        &gt;&gt;&gt; result = op([[1, 2, 3],</span>
<span class="sd">        ...              [4, 6, 8]], out=out)</span>
<span class="sd">        &gt;&gt;&gt; out</span>
<span class="sd">        rn(3).element([  9.,  14.,  19.])</span>
<span class="sd">        &gt;&gt;&gt; result is out</span>
<span class="sd">        True</span>

<span class="sd">        There is a simplified syntax for the case that all operators are</span>
<span class="sd">        the same:</span>

<span class="sd">        &gt;&gt;&gt; op = ReductionOperator(I, 2)</span>
<span class="sd">        &gt;&gt;&gt; op.operators</span>
<span class="sd">        (IdentityOperator(rn(3)), IdentityOperator(rn(3)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">*</span> <span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span> <span class="o">=</span> <span class="n">operators</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__prod_op</span> <span class="o">=</span> <span class="n">ProductSpaceOperator</span><span class="p">([</span><span class="n">operators</span><span class="p">])</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">ReductionOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">linear</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">is_linear</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prod_op</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;`ProductSpaceOperator` implementation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__prod_op</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tuple of sub-operators that comprise ``self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span>

<div class="viewcode-block" id="ReductionOperator.__getitem__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ReductionOperator.__getitem__.html#odl.operator.pspace_ops.ReductionOperator.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an operator by index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of sub-operators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="ReductionOperator._call">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ReductionOperator._call.html#odl.operator.pspace_ops.ReductionOperator._call">[docs]</a>
    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply operators to ``x`` and sum.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapped_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="o">.</span><span class="n">range</span><span class="o">.</span><span class="n">element</span><span class="p">([</span><span class="n">out</span><span class="p">],</span> <span class="n">cast</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">pspace_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_op</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">wrapped_out</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pspace_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="ReductionOperator.derivative">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.ReductionOperator.derivative.html#odl.operator.pspace_ops.ReductionOperator.derivative">[docs]</a>
    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derivative of the reduction operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : `domain` element</span>
<span class="sd">            The point to take the derivative in.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivative : linear `BroadcastOperator`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; r3 = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(r3)</span>
<span class="sd">        &gt;&gt;&gt; x = [1.0, 2.0, 3.0]</span>
<span class="sd">        &gt;&gt;&gt; y = [4.0, 6.0, 8.0]</span>

<span class="sd">        Example with linear operator (derivative is itself)</span>

<span class="sd">        &gt;&gt;&gt; op = ReductionOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op([x, y])</span>
<span class="sd">        rn(3).element([  9.,  14.,  19.])</span>
<span class="sd">        &gt;&gt;&gt; op.derivative([x, y])([x, y])</span>
<span class="sd">        rn(3).element([  9.,  14.,  19.])</span>

<span class="sd">        Example with affine operator</span>

<span class="sd">        &gt;&gt;&gt; residual_op = I - r3.element([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; op = ReductionOperator(residual_op, 2 * residual_op)</span>

<span class="sd">        Calling operator gives offset by [3, 3, 3]</span>

<span class="sd">        &gt;&gt;&gt; op([x, y])</span>
<span class="sd">        rn(3).element([  6.,  11.,  16.])</span>

<span class="sd">        Derivative of affine operator does not have this offset</span>

<span class="sd">        &gt;&gt;&gt; op.derivative([x, y])([x, y])</span>
<span class="sd">        rn(3).element([  9.,  14.,  19.])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ReductionOperator</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">,</span> <span class="n">x</span><span class="p">)])</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : linear `BroadcastOperator`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = ReductionOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op.adjoint([1, 2, 3])</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [ 2.,  4.,  6.]</span>
<span class="sd">        ])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BroadcastOperator</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">adjoint</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; spc = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; id = odl.IdentityOperator(spc)</span>
<span class="sd">        &gt;&gt;&gt; odl.ReductionOperator(id, 3)</span>
<span class="sd">        ReductionOperator(IdentityOperator(rn(3)), 3)</span>
<span class="sd">        &gt;&gt;&gt; scale = odl.ScalingOperator(spc, 3)</span>
<span class="sd">        &gt;&gt;&gt; odl.ReductionOperator(id, scale)</span>
<span class="sd">        ReductionOperator(IdentityOperator(rn(3)), ScalingOperator(rn(3), 3.0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_repr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">op_repr</span><span class="p">)</span></div>



<div class="viewcode-block" id="DiagonalOperator">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.DiagonalOperator.html#odl.operator.pspace_ops.DiagonalOperator">[docs]</a>
<span class="k">class</span> <span class="nc">DiagonalOperator</span><span class="p">(</span><span class="n">ProductSpaceOperator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Diagonal &#39;matrix&#39; of operators.</span>

<span class="sd">    For example, if ``A`` and ``B`` are operators, the diagonal operator</span>
<span class="sd">    can be seen as a matrix of operators::</span>

<span class="sd">        [[A, 0],</span>
<span class="sd">         [0, B]]</span>

<span class="sd">    When evaluated it gives::</span>

<span class="sd">         DiagonalOperator(op1, op2)(x) = [op1(x[0]), op2(x[1])]</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ProductSpaceOperator : Case when the &#39;matrix&#39; is dense.</span>
<span class="sd">    BroadcastOperator : Case when a single argument is used by several ops.</span>
<span class="sd">    ReductionOperator : Calculates sum of operator results.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DiagonalOperator.__init__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.DiagonalOperator.html#odl.operator.pspace_ops.DiagonalOperator.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operators</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a new instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        operator1,...,operatorN : `Operator` or int</span>
<span class="sd">            The individual operators in the diagonal.</span>
<span class="sd">            Can be specified as ``operator, n`` with ``n`` integer,</span>
<span class="sd">            in which case the diagonal operator with ``n`` multiples of</span>
<span class="sd">            ``operator`` is created.</span>
<span class="sd">        kwargs :</span>
<span class="sd">            Keyword arguments passed to the `ProductSpaceOperator` backend.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; I = odl.IdentityOperator(odl.rn(3))</span>
<span class="sd">        &gt;&gt;&gt; op = DiagonalOperator(I, 2 * I)</span>
<span class="sd">        &gt;&gt;&gt; op.domain</span>
<span class="sd">        ProductSpace(rn(3), 2)</span>
<span class="sd">        &gt;&gt;&gt; op.range</span>
<span class="sd">        ProductSpace(rn(3), 2)</span>

<span class="sd">        Evaluation is distributed so each argument is given to one operator.</span>
<span class="sd">        The argument order is the same as the order of the operators:</span>

<span class="sd">        &gt;&gt;&gt; op([[1, 2, 3],</span>
<span class="sd">        ...     [4, 5, 6]])</span>
<span class="sd">        ProductSpace(rn(3), 2).element([</span>
<span class="sd">            [ 1.,  2.,  3.],</span>
<span class="sd">            [  8.,  10.,  12.]</span>
<span class="sd">        ])</span>

<span class="sd">        Can also be created using a multiple of a single operator</span>

<span class="sd">        &gt;&gt;&gt; op = DiagonalOperator(I, 2)</span>
<span class="sd">        &gt;&gt;&gt; op.operators</span>
<span class="sd">        (IdentityOperator(rn(3)), IdentityOperator(rn(3)))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lazy import to improve `import odl` time</span>
        <span class="kn">import</span> <span class="nn">scipy.sparse</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Operator</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">operators</span> <span class="o">=</span> <span class="p">(</span><span class="n">operators</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">*</span> <span class="n">operators</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">n_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span>
        <span class="n">irow</span> <span class="o">=</span> <span class="n">icol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_ops</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_ops</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">operators</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_ops</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">)</span>
        <span class="n">op_matrix</span> <span class="o">=</span> <span class="n">COOMatrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">irow</span><span class="p">,</span> <span class="n">icol</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiagonalOperator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">op_matrix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operators</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tuple of sub-operators that comprise ``self``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__operators</span>

<div class="viewcode-block" id="DiagonalOperator.__getitem__">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.DiagonalOperator.__getitem__.html#odl.operator.pspace_ops.DiagonalOperator.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an operator by index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></div>


    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``len(self)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of sub-operators.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="DiagonalOperator.derivative">
<a class="viewcode-back" href="../../../generated/odl.operator.pspace_ops.DiagonalOperator.derivative.html#odl.operator.pspace_ops.DiagonalOperator.derivative">[docs]</a>
    <span class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Derivative of this operator.</span>

<span class="sd">        For example, if A and B are operators</span>

<span class="sd">            [[A, 0],</span>
<span class="sd">             [0, B]]</span>

<span class="sd">        The derivative is given by:</span>

<span class="sd">            [[A&#39;, 0],</span>
<span class="sd">             [0, B&#39;]]</span>

<span class="sd">        This is only well defined if each sub-operator has a derivative</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        point : `element-like` in ``domain``</span>
<span class="sd">            The point in which the derivative should be taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        derivative : `DiagonalOperator`</span>
<span class="sd">            The derivative operator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpaceOperator.derivative</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">element</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="n">derivs</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">,</span> <span class="n">point</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="o">*</span><span class="n">derivs</span><span class="p">,</span>
                                <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">adjoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjoint of this operator.</span>

<span class="sd">        For example, if A and B are operators::</span>

<span class="sd">            [[A, 0],</span>
<span class="sd">             [0, B]]</span>

<span class="sd">        The adjoint is given by::</span>

<span class="sd">            [[A^*, 0],</span>
<span class="sd">             [0, B^*]]</span>

<span class="sd">        This is only well defined if each sub-operator has an adjoint</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjoint : `DiagonalOperator`</span>
<span class="sd">            The adjoint operator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpaceOperator.adjoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adjoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">adjoint</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="o">*</span><span class="n">adjoints</span><span class="p">,</span>
                                <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inverse of this operator.</span>

<span class="sd">        For example, if A and B are operators::</span>

<span class="sd">            [[A, 0],</span>
<span class="sd">             [0, B]]</span>

<span class="sd">        The inverse is given by::</span>

<span class="sd">            [[A^-1, 0],</span>
<span class="sd">             [0, B^-1]]</span>

<span class="sd">        This is only well defined if each sub-operator has an inverse</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inverse : `DiagonalOperator`</span>
<span class="sd">            The inverse operator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ProductSpaceOperator.inverse</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inverses</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">inverse</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operators</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="o">*</span><span class="n">inverses</span><span class="p">,</span>
                                <span class="n">domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">range</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ``repr(self)``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; spc = odl.rn(3)</span>
<span class="sd">        &gt;&gt;&gt; id = odl.IdentityOperator(spc)</span>
<span class="sd">        &gt;&gt;&gt; odl.DiagonalOperator(id, 3)</span>
<span class="sd">        DiagonalOperator(IdentityOperator(rn(3)), 3)</span>
<span class="sd">        &gt;&gt;&gt; scale = odl.ScalingOperator(spc, 3)</span>
<span class="sd">        &gt;&gt;&gt; odl.DiagonalOperator(id, scale)</span>
<span class="sd">        DiagonalOperator(IdentityOperator(rn(3)), ScalingOperator(rn(3), 3.0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{!r}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_repr</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">op_repr</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">odl.util.testutils</span> <span class="kn">import</span> <span class="n">run_doctests</span>
    <span class="n">run_doctests</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014-2020 The ODL Contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>